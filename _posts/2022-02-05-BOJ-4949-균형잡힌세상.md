---
layout: post
title: BOJ_4949_균형잡힌세상_JAVA
author: hjs
date: 2022-02-05
---

## 문제 : 균형잡힌세상  
링크 : [BOJ_4949_균형잡힌세상](https://www.acmicpc.net/problem/4949)


## 접근 방식
스택을 이용해서 풀 수 있다. '(' 와 '['를 만날 때 스택을 쌓고, 해당하는 스택의 top을  
조사하여 각각 ')', ']'과 합쳐졌을때 스택에서 꺼내도록 코드를 짜면 쉽게 풀 수 있다.


## 풀이 방법
처음에는, '()'과 '[]'용으로 각각 다른 스택을 만들어 쌓아서 풀이를 해보려 했다.  
stack1,2를 만들고 주어진 문자열을 탐색한다. 각각 '[' 과 '('을 만나면 스택에 push한다. 이후 같은 문자열에서 계속 탐색하며 '[', ']' 이 만나면 pop, '(',')'이 만나면 pop하도록 했다.  

하지만 이렇게 하니 문제가 생긴 것이, '('와 ']'이 만나는 경우에도 no처리를 해야 하는데, 각각의 스택으로 분리를 하니, 짝을 잘못지은 괄호를 잡아내지 못했다.

그래서, 스택을 하나로 합치고, 잘못된 짝이 지어졌을 때는 바로 no를 출력하고 다음 문자열로 넘어가도록 했다. 또한, 잘못된 짝이 지어지지 않았더라도, 문자열을 모두 탐색한 후 스택에 값이 남아있다면, 짝지어지지 못한 괄호가 있는 것이므로 no를 출력하도록 했다.


## 소스 코드
~~~
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class BOJ_4949_균형잡힌세상 {

	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		go:while (true) {
			// (), [] 담을 스택
			Stack<Integer> stack1 = new Stack<>();

			char[] chars = in.readLine().toCharArray();
			// 종료 조건
			if (chars.length == 1 && chars[0] == '.') {
				break;
			}
			for (int i = 0; i < chars.length; i++) {
				switch (chars[i]) {
				case '(':
					stack1.push((int) chars[i]);
					break;
				case ')':
					if (!stack1.empty()&&stack1.peek() == '(') {
						stack1.pop();
					} else {
						System.out.println("no");
						continue go;
					}
					break;
				case '[':
					stack1.push((int) chars[i]);
					break;
				case ']':
					if (!stack1.empty()&&stack1.peek() == '[') {
						stack1.pop();
					} else {
						System.out.println("no");
						continue go;
					}
					break;
				}
			}
			if (stack1.empty()) {
				System.out.println("yes");
			}else {
				System.out.println("no");
			}
		}
	}

}
~~~
