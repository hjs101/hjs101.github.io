<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hjs101.github.io/tag/unity/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hjs101.github.io/" rel="alternate" type="text/html" />
  <updated>2022-03-17T03:30:17+09:00</updated>
  <id>https://hjs101.github.io/tag/unity/feed.xml</id>

  
  
  

  
    <title type="html">hjs’s Blog | </title>
  

  
    <subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">유니티 토막 지식_08</title>
      <link href="https://hjs101.github.io/Unity-15" rel="alternate" type="text/html" title="유니티 토막 지식_08" />
      <published>2022-03-16T09:00:00+09:00</published>
      <updated>2022-03-16T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-15</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-15">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;유니런이라는 게임을 제작하는 실습을 진행하는데, 간단한 2D 플랫포머 게임인 것 같다. 예전에 골드메탈이라는 유튜버 분의 2D플랫포머 게임 강좌를 따라 만들어 보았던 기억이 나 어떤 부분에서 다른지 찾아보는 재미가 있었다. 오늘은 플레이어 조작 부분까지 구현하였다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;오늘 알아볼 것은 스트레티지 패턴이다.&lt;/p&gt;

&lt;h5 id=&quot;스트래티지-패턴&quot;&gt;스트래티지 패턴&lt;/h5&gt;

&lt;p&gt;스트레티지 패턴(Strategy pattern)은 알고리즘군을 정의하고, 각각을 캡슐화하여 교환해서 사용하는 패턴이다.&lt;/p&gt;

&lt;p&gt;스트레티지 패턴을 이용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;여러가지 알고리즘의 추상적인 접근점을 만든다. 그리고 해당 접근점에서 상호 교체가 가능하도록 하는 패턴을 말한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_15_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림의 방식이 스트레티지 패턴의 기본 모양이라고 생각하면 된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Weapon이라는 Strategy가 있고, 각 Strategy에 대해 구현하는 무기의 종류가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Actor는 해당 Strategy를 Has a 관계로 가지게 된다. (소유 관계) 전략을 바꿀 수 있는 Setter 를 사용하도록 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 구조대로, 액터는 무기를 Has a 관계로 가지고 있어 무기를 바꿀 수 있고, 무기를 바꾸는 데 있어서 액터는 추가적인 로직 없이 무기 객체를 갈아 끼우기만 하면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;장점&quot;&gt;장점&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Strategy 패턴이라는 단어 자체가 전략 패턴이라는 뜻이다. 의미처럼 여러가지 전략을 간단하게 바꿀 수 있도록 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;게임 제작에서 상황에 따라 전략을 바꿔야 하는 경우가 (무기 변경, 공격 방어 회피 상태 변경 등)많아 유용하게 사용가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 동작에 대해 객체에 종속적이지 않게 되고, 다양한 방식으로 구현할 수 있게 된다.(인터페이스를 사용하기 떄문)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;단점&quot;&gt;단점&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;조건이 증가하면 관리해야할 클래스의 수가 늘어날 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;통신 오버헤드가 커지는 경우가 생긴다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;오늘은 시간이 부족해 실습을 추가로 진행하지 못했다. 내일 스트레티지 패턴에 대해 실습해보도록 하자.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_07</title>
      <link href="https://hjs101.github.io/Unity-14" rel="alternate" type="text/html" title="유니티 토막 지식_07" />
      <published>2022-03-15T09:00:00+09:00</published>
      <updated>2022-03-15T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-14</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-14">&lt;p&gt;어제는 싱글톤 패턴을 알아보았다. 오늘 알아볼 것은 옵저버 패턴이다.&lt;/p&gt;

&lt;h5 id=&quot;옵저버-패턴&quot;&gt;옵저버 패턴&lt;/h5&gt;

&lt;p&gt;옵저버 패턴은 특정 객체의 상태가 변화하면, 해당 객체와 연결 되어있는 다른 객체들이 영향을 받도록 하는 패턴이다. 1 : N 의 의존성을 가진다.&lt;/p&gt;

&lt;p&gt;이때, 상태 변화를 알려주는 객체를 Subject 라고 하고,  메시지를 받아 동작을 수행하는 객체를 Observer 라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_14_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 처럼 옵저버 패턴을 이용하면 옵저버들이 주체자의 상태변화를 감지하고 각각의 동작을 개별적으로 수행할 수 있다.&lt;/p&gt;

&lt;h6 id=&quot;옵저버-패턴의-장단점&quot;&gt;옵저버 패턴의 장단점&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;장점 : 객체간 결합도 낮추고, 응집도를 높인다. 이는 객체지향적인 면에서 큰 이점이 있다. 또한 일대다 객체간의 상호작용에서 이벤트 단위로 처리하는 상황에 유용하게 쓰인다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단점 : 코드의 상호작용이 일어나는지 한눈에 알아보기 어려워 디버깅을 통해 확인하는 방법을 사용해야 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;옵저버-패턴의-특징&quot;&gt;옵저버 패턴의 특징&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;주체자가 옵저버 각각의 객체에 대해 정보를 가지고 있을 필요가 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;옵저버는 언제든지 새롭게 추가할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새로운 기능을 사용하는 옵저버를 추가한다 하더라도 주체자는 바뀌는 것이 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주체자와 옵저버는 서로 독립적으로 재사용 가능하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주체자나 옵저버가 변경되더라도 서로에게 영향을 끼치지 않는다. (낮은 의존성)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h6 id=&quot;옵저버-패턴의-사용&quot;&gt;옵저버 패턴의 사용&lt;/h6&gt;

&lt;p&gt;유니티, C#에서는 delegate, event를 이용해 옵저버 패턴을 구현할 수 있다. 하지만 델리게이트에 대해서 아직 잘 모르기 때문에, 기본 형식으로 옵저버 패턴을 구현해보도록 하겠다. 간단하게 오브젝트의 색깔을 바꾸는 기능을 구현해보겠다.&lt;/p&gt;

&lt;p&gt;먼저 옵저버의 추상 클래스를 구현한다.&lt;/p&gt;

&lt;p&gt;Observer.cs&lt;/p&gt;
&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;colorChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 위 추상클래스를 상속받을 객체 4개를 생성하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_14_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구체를 4개 생성했다. 이제 각각의 구체가 위 추상클래스를 상속받아 정의되어있는 추상메서드를 재정의하여 구현할 것이다.&lt;/p&gt;

&lt;p&gt;ChangeRed.cs&lt;/p&gt;
&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ChangeRed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;colorChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Renderer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;material&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추상메서드를 Overriding 하여 내부를 구현하였다. 구체가 4개 있으니 각각 다른 색깔로 만들어보자.&lt;/p&gt;

&lt;p&gt;이제 옵저버를 관리할 Subject를 만들어보자. 음, 스페이스바 버튼을 누르면 각 옵저버들에 구현되어있는 colorChange 메서드를 실행시키도록 해보자.&lt;/p&gt;

&lt;p&gt;Subject.cs&lt;/p&gt;
&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Subject&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;


    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;observerAdd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;observerRemove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;IndexOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obs&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;observers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;obs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;colorChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetKeyDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_14_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 스크립트를 빈 오브젝트를 생성해 이름은 Subject으로 바꿔주고 컴포넌트에 추가해주었다. Observer를 Public로 설정해두었기 때문에 위처럼 엘리멘트 추가가 가능하다. 변경한 김에 구의 이름도 바꿔주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_14_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각 옵저버에 만들었던 스크립트들을 색깔별로 4개 구 게임오브젝트에 각각 집어넣어 주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_14_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스크립트를 컴포넌트로 추가한 구 게임 오브젝트를 드래그앤 드롭하여 Subject 오브젝트의 Observer 목록에 추가시킨다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_14_06.gif&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SpaceBar 키를 누름과 동시에 각 구체들의 colorChange 메서드가 실행되는 화면이다.&lt;/p&gt;

&lt;p&gt;C#에서 제공하는 delegate와 event를 사용하는 방법은 다음에 실습해보도록 하자.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">어제는 싱글톤 패턴을 알아보았다. 오늘 알아볼 것은 옵저버 패턴이다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_05</title>
      <link href="https://hjs101.github.io/Unity-12" rel="alternate" type="text/html" title="유니티 토막 지식_05" />
      <published>2022-03-13T09:00:00+09:00</published>
      <updated>2022-03-13T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-12</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-12">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 공간과 움직임 파트를 공부했다. 내용이 이해하기 쉽지 않아 조금 더 살펴봐야 할 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2021.1/Manual/EventFunctions.html&quot;&gt;이벤트 함수&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 이벤트 함수이다.&lt;/p&gt;

&lt;h5 id=&quot;정의&quot;&gt;정의&lt;/h5&gt;

&lt;p&gt;유니티의 스크립트는, 전통적인 프로그램처럼 작업이 완료될 때까지 코드가 루프를 계속 실행하는 프로그램과는 개념이 다르다. 이전 게시글에 잠깐 설명한 적이 있는데, 특정한 일(event)이 일어났음을 외부의 subscriber들에게 알려준다(브로드캐스팅). 이후 해당하는 이벤트에 등록되어있는 함수들은 브로드캐스팅된 메시지를 받아 자동적으로 실행이 되는 구조이다. 이렇게 이벤트에 대응하여 코드를 실행하는 함수를 이벤트 함수라고 한다.&lt;/p&gt;

&lt;p&gt;유니티는 특정 이벤트에 대해, 호출할 함수를 확인하기 위해 이름을 지정하여 사용한다. 우리가 처음 스크립트를 만들면 자동으로 생성되는 Start함수(오브젝트가 처음 활성화 될 때 호출된다.)와 Update 함수도 이벤트 함수의 일종이다. 몇 가지 중요한 이벤트 함수에 대해 알아보자.&lt;/p&gt;

&lt;h5 id=&quot;정기-업데이트-이벤트&quot;&gt;정기 업데이트 이벤트&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Update
  게임 프로그래밍의 핵심 개념 중 하나는 각 프레임이 렌더링 되기 전에 게임에서 오브젝트의 위치, 상태 및 동작을 변경하는 것이다. 이런 코드는 주로 Update 함수에 주로 추가된다. Update함수는 프레임이 렌더링 되기 이전에 호출되며, 애니메이션이 계산되기 이전에도 호출된다.
  메뉴얼에는 어려운 말로 쓰여있지만, 실시간으로 계속 체크하고 변화해야되는 상황에 Update를 사용한다고 생각하면 될 것 같다.
  다만 이 함수는 &lt;strong&gt;프레임&lt;/strong&gt; 단위로 수행된다는 점은 기억해두자.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;speed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deltaTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetAxis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Horizontal&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Translate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;FixedUpdate
  이 함수는 물리의 Timestep에 설정된 값에 따라 수행된다. 이 함수는 Update 함수와 유사한 기능을 가지고 있지만 물리 Timestep에 따른 물리 업데이트 직전에 호출된다. 물리적인 이동과 관련된 코드는 Update가 아니라 FixedUpdate에 추가하면 더욱 정확한 결과를 얻을 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;FixedUpdate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driveForce&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetAxis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Vertical&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rigidbody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddForce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;force&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;LateUpdate
  이 함수는, Update 함수 또는 FixedUpdate 함수가 수행된 이후, 또는 모든 애니메이션이 계산된 이후에 수행되는 함수이다. 사용하는 예는 카메라가 타겟 오브젝트를 계속해서 따라갈 경우, 타겟이 이동 한 후에 카메라는 움직여야하기 때문에 사용합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LateUpdate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LookAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;초기화-이벤트&quot;&gt;초기화 이벤트&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start
  첫 프레임이나 오브젝트의 물리 업데이트가 시작되기 이전에 최초로 한 번 수행된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Awake
  씬이 로드될 때 씬의 각 오브젝트에 대해 호출된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;※ Start와 Awake의 차이점
  Awake는 항상 Start보다 먼저 수행하여 완료된다. 따라서 Start는 Awake의 초기화 된 값을 사용가능하다. 수행 순서를 기억해두자. &lt;strong&gt;Awake -&amp;gt; Start&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;gui-이벤트&quot;&gt;GUI 이벤트&lt;/h5&gt;

&lt;p&gt;유니티에서 GUI에 대한 이벤트는 예전에는 OnGui 함수를 통해 사용했다고 한다. 하지만 유니티의 공식 UI 시스템인 UGUI가 등장함에 따라 해당 함수는 쓰임새가 사라졌다고 한다. UGUI를 사용하 UI요소를 게임 오브젝트 &amp;amp; 컴포넌트처럼 다루고 편집할 수 있다.&lt;/p&gt;

&lt;h5 id=&quot;물리-이벤트&quot;&gt;물리 이벤트&lt;/h5&gt;

&lt;p&gt;물리 이벤트에 대 함수는 이전 글에 설명을 해두었다. 여기서는 물리 엔진이 오브젝트의 스크립트에 있는 이벤트 함수를 호출한다는 점만 알아두면 될 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnCollisionEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;otherObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Collision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;otherObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Arrow&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;ApplyDamage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_06</title>
      <link href="https://hjs101.github.io/Unity-13" rel="alternate" type="text/html" title="유니티 토막 지식_06" />
      <published>2022-03-13T09:00:00+09:00</published>
      <updated>2022-03-13T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-13</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-13">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 공간과 움직임 파트를 마쳤다. 내일부터 유니런 제작 실습을 할 예정이다.&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 디자인 패턴이다. 지금까지 제대로 유니티에 적용해본 패턴은 싱글톤 하나 뿐이지만, 다양한 디자인 패턴들을 익혀두면 게임 제작을 할 때 적용가능한 패턴이 자연스럽게 떠오를 것 같다.&lt;/p&gt;

&lt;h5 id=&quot;싱글톤-패턴&quot;&gt;싱글톤 패턴&lt;/h5&gt;

&lt;p&gt;유니티에서도 사용해봤고, 자바에서도 사용해봤다. 싱글톤의 핵심은 단일 인스턴스 반환이다. 객체의 인스턴스를 1개만 생성해두고 그 1개의 인스턴스에만 접근하는 것이다.&lt;/p&gt;

&lt;p&gt;유니티에서 싱글톤 패턴은 주로 게임 시스템 전체를 통괄하는 스크립트이거나,(ex. gameManager) 전역변수처럼 사용해야할 때 사용한다. 또는 씬이 변경될 때 파괴되면 안되는 오브젝트에도 싱글톤을 반영한다.&lt;/p&gt;

&lt;h6 id=&quot;싱글톤-패턴의-사용&quot;&gt;싱글톤 패턴의 사용&lt;/h6&gt;

&lt;p&gt;유니티에서 싱글톤 패턴을 사용하는 방법은 2가지가 있다. 첫 번째는 게임오브젝트로써 씬에 존재하게 할 수 있고(MonoBehaviour을 상속받는다.), 두 번째는 게임 오브젝트로 존재하지 않게 하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 처음 활성화 될 때 생성되고, DontDestroyOnLoad 메서드로 인해 씬이 변경된다 하더라도 파괴되지 않는다.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// static 변수로 선언했기 때문에 다른 클래스에서도 직접적으로 호출이 가능해진다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;nf&quot;&gt;DontDestroyOnLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 만약 씬이 바뀌었는데 바뀐 씬에 동일한 오브젝트가 이미 있는 경우 그 오브젝트를 파괴해준다.&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 만약 이 작업을 하지 않아 2개의 인스턴스가 생성되면 단일 인스턴스가 아니게 된다.&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Destroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 다른 클래스에서는 퍼블릭으로 선언되어있는 아래의 프로퍼티를 이용해 호출할 수 있다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Singleton&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Instance&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단한 사용방법이다. 위 방법은 MonoBehaviour에 상속을 받아 씬 내부에 존재할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;두 번째 방법은 자바에서와 같은 방식으로 생성한다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Singleton2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Singleton2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Singleton2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Instance&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 인스턴스가 존재하지 않는 경우 딱 한 번 생성하고, 그 후에는 생성한 인스턴스를 반환한다.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Singleton2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 두 가지 방법으로 싱글톤을 생성할 수 있다.&lt;/p&gt;

&lt;h6 id=&quot;장단점&quot;&gt;장단점&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;장점 : 고정된 영역의 인스턴스를 한 번만 생성하여 사용하기 때문에 메모리 절약이 된다. 또한 전역으로 사용할 수 있어 다른 클래스에서 접근이 용이하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단점 : 싱글톤 단일로만 사용할 경우 객체지향 원칙(SOLID)에 위배된다. OCP, Open-Closed Principle 원칙은 개방-폐쇄 원칙인데. 확장에는 개방되어야하고, 수정에는 폐쇄되어야하는 원칙이다. 싱글톤 패턴은 하나의 인스턴스와 다양한 클래스가 연결되기 때문에 결합도가 높아져 객체의 인터페이스가 제대로 분리되지 못하게 되어 객체지향적이지 않게 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_04</title>
      <link href="https://hjs101.github.io/Unity-11" rel="alternate" type="text/html" title="유니티 토막 지식_04" />
      <published>2022-03-11T09:00:00+09:00</published>
      <updated>2022-03-11T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-11</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-11">&lt;p&gt;오늘은 상당히 진빠지는 시험을 보게 되어 추가적인 유니티 공부는 하지 못했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2022.1/Manual/PhysicsOverview.html&quot;&gt;3D 물리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 유니티에서 사용하는 물리에 관한 컴포넌트들을 살펴보겠다.&lt;/p&gt;

&lt;h5 id=&quot;rigidbody&quot;&gt;RigidBody&lt;/h5&gt;

&lt;p&gt;리지드바디(RigidBody)는, 앞서서도 여러 번 설명한 적이 있는 컴포넌트이다. 게임 오브젝트가 물리적 동작을 가능하게 하는 주요 컴포넌트이다.&lt;/p&gt;

&lt;p&gt;리지드바디는 연결된 게임 오브젝트의 이동을 제어한다. 따라서 스크립트에서 포지션이나 회전처럼 TransForm의 프로퍼티를 변경시켜 오브젝트를 이동하려고 하면 안된다. 값을 변경하는 대신 Forces. 즉 오브젝트에 &lt;strong&gt;힘을 가하고, 그 힘에 대해 물리 엔진이 결과를 계산&lt;/strong&gt;할 수 있도록 해야한다.&lt;/p&gt;

&lt;p&gt;경우에 따라서 특정 게임 오브젝트에 리지드바디를 추가하되, 물리 엔진의 제어를 받는 것이 싫을 때가 있다. 예를 들면 스크립트 코드로 캐릭터를 직접 제어하면서도, 캐릭터가 트리거에 의해 감지되게 하려고 할 때가 있다.&lt;/p&gt;

&lt;p&gt;리지드바디에는 Is Kinematic 이라는 프로퍼티가 있다. 이 프로퍼티는 물리 엔진의 제어대상에서 해당 컴포넌트를 제외한다. 키네마틱 프로퍼티가 켜져 있는 상태라면 스크립트에서 비물리적인 모션을 적용할 수 있다. 이러한 모션을 키네마틱 모션이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_10_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림과 같이 체크박스를 통해 키네마틱을 켜고 끌 수 있다. 스크립트 안에서도 Is Kinematic의 값을 변경할 수 있지만, 성능 오버헤드가 발생한다고 하니 신중하게 사용하자.&lt;/p&gt;

&lt;p&gt;※ 리지드바디의 휴면 : 리지드바디가 정의된 최소 선형, 또는 회전 속도보다도 더 느리게 이동하면 물리 엔진에서는 정지했다고 간주한다. 움직이지 않는 리지드바디는 다시 힘이 가해지거나 충돌하기 전 까지는 움직이지 않기 때문에 이때 유니티에서는 리지드바디를 “휴면” 모드로 설정한다. 이러한 최적화는, 리지드바디가 다음번에 &lt;em&gt;WakeUp&lt;/em&gt; 할 때까지 프로세서의 자원이 사용되지 않는다.&lt;/p&gt;

&lt;h5 id=&quot;collider&quot;&gt;Collider&lt;/h5&gt;

&lt;p&gt;콜라이더 컴포넌트는 물리적 충돌을 위한 게임 오브젝트의 모양을 정의한다. 흔히들 많이 이야기하는 충돌판정에 대한 컴포넌트이다.&lt;/p&gt;

&lt;p&gt;콜라이더는 기본 콜라이더, 복합 콜라이더, 메시 콜라이더, 정적 콜라이더 등 많은 종류가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;기본 콜라이더 : 가장 간단하고, 자원을 적게 먹는 콜라이더다. 3D에선 박스 콜라이더, 스피어 콜라이더, 캡슐 콜라이더가 이에 해당한다. 2D에서는 박스 콜라이더2D, 써클 콜라이더2D를 사용할 수있다. 기본 콜라이더를 여러 개 중첩해 복합 콜라이더를 만들 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복합 콜라이더 : 자원을 적게 먹으면서도 게임 오브젝트의 대략적인 모양을 만들 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메시 콜라이더 : 복합 콜라이더를 통해서도 게임 오브젝트의 모양을 표현하기 힘들고, 더 정확한 콜라이더 표현이 필요한 경우 사용하는 콜라이더이다. 이 콜라이더는 게임 오브젝트의 메시 모양에 정확히 맞출 수 있지만, &lt;strong&gt;프로세서에 큰 부담&lt;/strong&gt;을 주기 때문에 꼭 필요한 경우에만 사용해야 한다. 또한 메시 콜라이더와 메시 콜라이더, 즉 메시 콜라이더끼리는 충돌이 일어나지 않는 문제가 있다. 이 문제를 해결하기 위해서 메시 콜라이더는 인스펙터 창에서 Convex로 설정해 “볼록 다각형” 모양의 콜라이더로 생성할 수 있다. (파인 부분이 사라짐)
 일반적으로 메시 콜라이더는 씬 지오메트리에 사용한다. 2D에서는 폴리곤 콜라이더 2D를 통해 세부 조절이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_10_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;정적 콜라이더 : RigidBody 컴포넌트 없이 콜라이더를 게임 오브젝트에 추가하여 바닥, 벽과 같은 고정된 오브젝트에 사용하는 콜라이더를 말한다. 반대로 RigidBody가 있는 콜라이더는 동적 콜라이더라고 부른다. 정적 콜라이더는 동적 클라이더와 상호작용이 가능하나, 충돌에 의한 물리 이동이 일어나지 않는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;트리거&quot;&gt;트리거&lt;/h5&gt;

&lt;p&gt;콜라이더에 트리거를 사용하면 해당 콜라이더는 솔리드 오브젝트로 동작하지 않는다. 간단히 말해 부딛히지 않는 다는 뜻이다. 하지만 스크립트 내부에서 OnTriggerEnter 함수를 이용하여 해당 콜라이더가 다른 콜라이더와 부딛혔을 때(겹쳤을 때)의 로직 처리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;※ 충돌에 대한 콜백 함수&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OnCollisionEnter : 충돌이 감지되었을 때 가장 먼저 일어난다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OnCollisionStay : 충돌 -&amp;gt; 접촉이 지속되는 상황동안 계속 호출 접촉이 해제될 때 OnCollisionExit가 호출된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;트리거의 경우 위에서 Collision을 Trigger으로 바꾼다. (OnTriggerEnter, OnTriggerStay, OnTriggerExit)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2D에서는 함수명 끝에 2D 첨자가 붙는다. ex) OnCollisionEnter2D&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;콜라이더-사이의-상호작용&quot;&gt;콜라이더 사이의 상호작용&lt;/h5&gt;

&lt;p&gt;콜라이더는 크게 정적 콜라이더, 동적 콜라이더로 나눌 수 있다. 이는 리지드바디의 유무에 따라서 구분하며, 추가적으로 키네마틱이 활성화된 리지드바디 콜라이더까지 추가하여 각각의 상호작용에 대해 알아보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;정적 콜라이더 : 정적콜라이더는 앞에서 설명했듯 리지드바디가 없다. 따라서 항상 같은 위치에 절대 움직이지 않는 것에 주로 사용된다. 다른 동적 콜라이더를 가진 객체와 충돌해도 정적콜라이더는 움직이지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리지드바디 콜라이더 : 일반적인 비키네마틱 리지드바디와 콜라이더를 가진 오브젝트가 동적 콜라이더이다. 물리엔진에 의해 제어되며 충돌, 힘 모두에 반응하여 움직일 수 있다. 가장 흔하게 사용되는 콜라이더이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;키네마틱 리지드바디 콜라이더 : 리지드바디와 콜라이더를 함께 가졌지만 해당 리지드바디에 Iskinematic이 활성화되어있는 콜라이더를 말한다. 키네마틱 리지드바디 콜라이더는 정적 콜라이더처럼 힘과 충돌에 반응하지 않지만, 스크립트에 의한 TransForm 컴포넌트 수정을 통해서는 움직일 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 콜라이더는 상황에 따라 움직일 수 있지만 그 외 상황에서는 정적 콜라이더처럼 작용한다. 예를 들면 평소에는 움직이지 않는 장애물처럼 동작하지만, 필요할 때는 열 수 있는 문과 같은 경우이다. 정적 콜라이더는 다른 오브젝트에 마찰이 작용할 수 있으며, 접촉이 일어난 경우 다른 리지드바디를 &lt;strong&gt;WakeUp&lt;/strong&gt; 시킬 수 있다.&lt;/p&gt;

&lt;p&gt;※ 리지드바디 컴포넌트는 Iskinematic 프로퍼티를 사용하여 언제는 키네마틱, 일반 리지드바티로 전환할 수 있다. 이를 이용하는 좋은 예로 래그돌 효과가 있다. 래그돌 효과는 사망 애니매이션을 고정된 애니메이션으로 사용하는 것이 아니라 물리적인 터리를 통해 다양한 사망 모션을 연출하기 위한 기법이다.&lt;/p&gt;

&lt;p&gt;이는 키네마틱 리지드바디를 이용하여 구현할 수 있다. 사망 직전까지는 키네마틱 리지드바디를 이용하여 애니메이션에 의해 일반적으로 움직이다가, 비활성화되는 순간 키네마틱을 비활성화시켜 물리오브젝트로 동작하게 하는 것이다. 폭발에 의해 날아가는 시체가 흐느적거리며 날아가는 장면 등이 이런 효과를 이용한 것이다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">오늘은 상당히 진빠지는 시험을 보게 되어 추가적인 유니티 공부는 하지 못했다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_03</title>
      <link href="https://hjs101.github.io/Unity-10" rel="alternate" type="text/html" title="유니티 토막 지식_03" />
      <published>2022-03-10T09:00:00+09:00</published>
      <updated>2022-03-10T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-10</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-10">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 벡터와 회전에 대해 공부했다. 고등학교 때 배웠던 내용이 조금이나마 떠올라서 조금 그리운 느낌도 들었다.&lt;/p&gt;

&lt;p&gt;그렇다고 매 포스팅을 한 줄짜리 일기로 끝낼 수 없기 때문에, 유니티 API 문서를 토대로 유니티를 사용하는데 도움이 되는 지식을 공부하고, 포스팅하려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2022.1/Manual/VectorCookbook.html&quot;&gt;Vector&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 Vector이다.&lt;/p&gt;

&lt;h4 id=&quot;정의&quot;&gt;정의&lt;/h4&gt;

&lt;p&gt;벡터는 &lt;strong&gt;방향&lt;/strong&gt;과 &lt;strong&gt;크기&lt;/strong&gt;를 설명할 수 있는 기본적인 수학적 개념이다. 게임이나 앱에서 벡터는 종종 캐릭터의 위치, 움직이는 속도, 두 물체 사이의 거리와 같은 기본 특성들을 묘사할 때 사용된다.&lt;/p&gt;

&lt;p&gt;벡터 연산은 그래픽스, 물리, 애니매이션 등과 같이 많은 요소에 핵심이 된다. Unity를 최대한 활용하기 위해서는 벡터 연산을 깊이 이해하는게 좋다고 한다.&lt;/p&gt;

&lt;p&gt;벡터는 여러 차원으로 표현이 가능하다. Unity는 2D,3D,4D 벡터작업이 가능한 각각의 클래스를 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;벡터의-연산&quot;&gt;벡터의 연산&lt;/h3&gt;

&lt;h5 id=&quot;덧셈&quot;&gt;덧셈&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_09_01.png&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 벡터의 덧셈은 두 개의 벡터의 좌표를 각각 더해주는 것을 말한다. 좌표를 더하는 순서가 달라지더라도 결과는 같기 때문에 더하는 &lt;strong&gt;순서는 상관없다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터가 힘을 나타내는 단위일 때 벡터를 힘의 크기인 강도와 방향으로 간주할 경우 더욱 와닿는다. 두 가지 힘의 벡터를 서로 더하면, 두 힘을 합한 값과 동일한 새로운 벡터가 생성된다. -&amp;gt; 동시에 다수의 서로 다른 컴포넌트에 힘을 가할 때 유용하다. ex) 활을 쏠 때 바람에 따라 세기와 방향이 변동할 수 있음.&lt;/p&gt;

&lt;p&gt;그림은 2D Vector로 예시를 들었지만, 3D와 4D에서도 동일하게 적용된다.&lt;/p&gt;

&lt;h5 id=&quot;뺄셈&quot;&gt;뺄셈&lt;/h5&gt;

&lt;p&gt;벡터의 뺄셈은 특정 오브젝트에서 다른 오브젝트까지의 거리, 방향을 구할 때 주로 사용한다. 이 과정에서 &lt;strong&gt;파라미터의 순서&lt;/strong&gt;는 매우 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_09_02.png&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 두 벡터 a, b의 뺄셈 b-a가 의미하는 것은 무엇일까? 바로 a에서 b까지의 거리, 방향 벡터를 의미한다. 물론 반대, a-b는 b에서 a까지의 거리, 방향 벡터이다.&lt;/p&gt;

&lt;p&gt;벡터는 값이 아닌 방향이 존재하기 때문에 당연하게도 a-b != b-a이다. 만약 a 위치에서 b위치까지의 거리를 알고싶다면 b의 벡터값에서 a의 벡터값을 뺄셈 해주면 해당하는 거리와 방향의 벡터를 얻을 수 있을 것이다.&lt;/p&gt;

&lt;h5 id=&quot;벡터의-정규화&quot;&gt;벡터의 정규화&lt;/h5&gt;

&lt;p&gt;정규화된 벡터란, 벡터의 길이가 1인 벡터를 말한다. 정규화 된 벡터를 구하는 방법은 2가지가 있다.&lt;/p&gt;

&lt;p&gt;벡터 A가 있다고 할 때&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 벡터의 길이&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;magnitude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 정규화 벡터&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 정규화 벡터&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;direction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normalized&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;스칼라-곱셈과-나눗셈&quot;&gt;스칼라 곱셈과 나눗셈&lt;/h5&gt;

&lt;p&gt;스칼라는 단순이 크기만을 가지고 있는 것을 말한다. 벡터는 앞서 말했듯 크기, 방향을 함께 가지고 있다.&lt;/p&gt;

&lt;p&gt;벡터에 스칼라를 곱한다면 그 결과는 오리지널과 &lt;strong&gt;동일한 방향&lt;/strong&gt; 을 가리키는 벡터이다. 벡터에 스칼라를 곱하거나 나누어도 방향은 변하지 않는다. 그러나 크기는 각각의 벡터의 크기에 해당하는 스칼라를 곱하거나 나눈 값과 같다. 앞의 정규화에서 먼저 사용했는데. A라는 벡터에 A벡터의 크기만큼 스칼라 값을 나눗셈 해주었더니, 크기가 1인 정규화된 벡터가 되었다. 영어로는 normalized Vector라고 한다.&lt;/p&gt;

&lt;h5 id=&quot;벡터의-내적&quot;&gt;벡터의 내적&lt;/h5&gt;

&lt;p&gt;벡터의 내적은 두 벡터를 받아 스칼라를 반환한다. 이 스칼라는 두 벡터의 크기를 곱한 후, 그 결과의 두 벡터 사이의 각도에 대해 코사인값을 곱한 것과 같다. 두개의 벡터가 모두 정규화된 벡터일 경우, 코사인 값은 첫 번째 벡터에서 2번째 벡터의 방향으로 기울어진 기울기를 나타낸다. 이 경우 두 벡터의 &lt;strong&gt;순서는 상관이 없다.&lt;/strong&gt; 스칼라는 부호가 없기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_09_03.png&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내적은 다른 벡터의 방향에 있는 한 벡터의 크기를 계산 할 때 유용하게 사용할 수 있다. 유니티에서는 내적을 간단하게 구할 수 있게 메서드를 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dot&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VecTor3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Dot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vec1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;벡터의-외적&quot;&gt;벡터의 외적&lt;/h5&gt;

&lt;p&gt;벡터의 외적은 3D 벡터에만 해당되는 개념이다. 두 개의 3D 벡터를 입력으로 사용하여, 다른 3D 벡터를 반환한다.
반환하는 벡터는 두 입력 벡터에 대해 수직이다. 오른손 법칙을 사용하여, 입력 벡터의 순서에서 출력 벡터의 방향을 기억할 수 있다. 2개의 벡터가 있을 때 순서를 서로 다르게 하여 벡터의 외적을 구하면 만들어진 두 외적은 서로 정확히 &lt;strong&gt;반대 방향&lt;/strong&gt;을 가리킬 것이다. 벡터의 외적의 크기는, 입력 벡터들의 크기를 곱하고, 그 결과에 두 벡터 사이 각도의 Sin 값을 곱한 것과 같다.&lt;/p&gt;

&lt;p&gt;벡터의 외적은 Sin, Cos 같은 함수를 써야할 상황에 외적을 이용하면 최적화에 많은 도움이 된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_02</title>
      <link href="https://hjs101.github.io/Unity-09" rel="alternate" type="text/html" title="유니티 토막 지식_02" />
      <published>2022-03-08T09:00:00+09:00</published>
      <updated>2022-03-08T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-09</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-09">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 닷지 게임을 완성하고 빌드하는 과정을 거쳤다.&lt;/p&gt;

&lt;p&gt;그렇다고 매 포스팅을 한 줄짜리 일기로 끝낼 수 없기 때문에, 유니티 API 문서를 토대로 유니티를 사용하는데 도움이 되는 지식을 공부하고, 포스팅하려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2022.1/Manual/class-GameObject.html&quot;&gt;GameObject&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 GameObject 이다.&lt;/p&gt;

&lt;h4 id=&quot;정의&quot;&gt;정의&lt;/h4&gt;

&lt;p&gt;GameObject는 씬 내에 존재할 수 있는 모든 요소를 나타낼 수 있는 클래스이다.&lt;/p&gt;

&lt;p&gt;일반적으로 스크립트에서 GameObject를 사용하는 목적은 대부분 다른 오브젝트를 관리하기 위함이다. 해당 스크립트를 컴포넌트로 갖는 오브젝트는 gameObject로 접근할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;※GameObject와 gameObject의 차이&lt;/p&gt;

&lt;p&gt;헷갈릴 수 있는데, 앞서 말했듯이 GameObject는 클래스이다. 실제 내용물이 아니라 틀이라고 생각하면 된다. 스크립트 내에서 GameObject 타입으로 변수를 선언할 수 있다. 즉, GameObject는 형(type)의 일종이라고 볼 수 있다. gameObject는 앞서 말한 것처럼 해당 스크립트를 컴포넌트로 갖는 오브젝트이다. gameObject는 스크립트를 컴포넌트로 게임오브젝트에 부착한 순간부터 이미 값이 할당되어 있다고 생각하면 된다. 스크립트에서 gameObject를 사용하는 경우는 자기 자신 오브젝트에 접근하는 경우이고, GameObject를 사용하는 경우는 다른 오브젝트에 접근하는 경우에 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;기본-구성&quot;&gt;기본 구성&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_08_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;게임 오브젝트는 씬에서 생성하면 기본적으로 활성화된 상태이다. 체크박스를 해제하여 비활성화를 할 수 있다.&lt;/p&gt;

&lt;p&gt;게임 오브젝트를 비활성화하면 게임 오브젝트에 연결된 모든 컴포넌트가 해제된다. 일반적으로 비활성화 시킨 게임 오브젝트는 화면에 보이지 않게 되고, Update, FixedUpdate 등과 같은 정규 콜백이나 이벤트를 수신하지 않는다.&lt;/p&gt;

&lt;p&gt;스크립트 내에서 GameObject.SetActive(boolean값) 을 이용하여 게임 오브젝트의 활성상태를 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;그 오른쪽에 있는 static 체크박스는, 게임 오브젝트가 움직일 수 있는지 가능 여부를 고를 수 있다. 해당 부분은 최적화에 쓰이는데, 예를 들어 움직이지 않는 게임 오브젝트들을 batch(배치)라는 하나의 큰 오브젝트로 결합시킴으로써 렌더링을 최적화 할 수 있다.&lt;/p&gt;

&lt;p&gt;오브젝트에는 태그와 레이어가 존재하는데, 태그는 씬에서 게임 오브젝트의 타입을 표시, 식별할 수 있게 한다.
레이어는 렌더링 또는 물리 충돌 같은 특정 빌트인 동작에 대해 게임 오브젝트를 그룹화하여 제어할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;게임 오브젝트에 컴포넌트를 자유롭게 부착, 제거할 수 있다. 기초 글에도 있듯이, 게임 오브젝트에 부착하는 각 컴포넌트는 독립적으로 구성된다.&lt;/p&gt;

&lt;p&gt;스크립트에서 컴포넌트에 접근할 때는 GetComponent 메서드를 사용하여 접근할 수 있다. 해당 메서드는 스크립트 내에서 단독으로 사용하면 현재 게임 오브젝트의 컴포넌트를 읽어온다. 이 때, 제네릭의 개념이 사용되는데.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;RigidBody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RigidBody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;라고 한다면, &lt;RigidBody&gt; 부분을 제네릭이라고 생각하면 된다. 유니티의 관점에서 생각해보면, 컴포넌트는 수 없이 많다. 그런데 제네릭이 없이 그냥 GetComponent만으로 컴포넌트를 읽어온다고 생각해보자. 이 경우 조건문 같은 사후 처리를 통해 읽어온 컴포넌트가 내가 원하는 컴포넌트인지 확인하는 작업이 따로 필요해진다. 이 때 미스매치가 되는 경우 Exception이 발생할 수도 있다. 반면 제네릭을 사용하여 &quot;나는 이러한 타입의 컴포넌트를 읽어올거야&quot; 라고 미리 지정해 두면, 컴파일 과정에서 해당하는 타입의 컴포넌트를 바로 읽어올 수 있는 것이다.&lt;/RigidBody&gt;&lt;/p&gt;

&lt;h4 id=&quot;부모자식-관계&quot;&gt;부모자식 관계&lt;/h4&gt;

&lt;p&gt;게임 오브젝트는 Transform 컴포넌트를 기본적으로 가지고 있다. TransForm 컴포넌트는 Parenting, 부모자식관계를 사용할 수 있다. 스크립트에서 이 부모자식관계를 이용해 부모 게임 오브젝트로부터 자식 오브젝트를 검색하여 가져올 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_01</title>
      <link href="https://hjs101.github.io/Unity-08" rel="alternate" type="text/html" title="유니티 토막 지식_01" />
      <published>2022-03-07T09:00:00+09:00</published>
      <updated>2022-03-07T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-08</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-08">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;어제와 오늘에 걸쳐서, 닷지 게임 제작의 2/3을 완료했다. 내일은 닷지 게임 완성에 들어갈 듯 하다.&lt;/p&gt;

&lt;p&gt;그렇다고 매 포스팅을 한 줄짜리 일기로 끝낼 수 없기 때문에, 유니티 API 문서를 토대로 유니티를 사용하는데 도움이 되는 지식을 공부하고, 포스팅하려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/530/ScriptReference/Transform.html&quot;&gt;Transform&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 Transform 컴포넌트에 대한 것이다.&lt;/p&gt;

&lt;p&gt;Transform 컴포넌트는 씬에 존재하는 모든 오브젝트가 가지고 있는 컴포넌트이다. 이는 각각의 오브젝트의 위치, 회전, 크기를 저장해두고 다루기 위해 사용한다.&lt;/p&gt;

&lt;p&gt;또한 Transform 컴포넌트는 계층적으로 위치, 회전 스케일을 적용할 수 있는 부모 Transform을 가질 수 있는데, 이를 이해하기 위해 계층에 대한 내용을 먼저 알아보겠다.&lt;/p&gt;

&lt;p&gt;유니티의 Hierarchy Window 가 직역하면 계층 창이다. 유니티에서는 상속과 비슷하게 Parenting이라는 개념을 사용할 수 있는데, 특정 게임오브젝트를 다른 오브젝트의 자식으로 둘 수 있는 개념을 말한다. 이 때, 자식 오브젝트는 부모의 이동, 회전을 계승한다.&lt;/p&gt;

&lt;p&gt;여기서 이동, 회전을 계승한다는 의미가 앞서 설명한 Transform의 계층적으로 부모 Transform을 가지는 것을 말한다. 이 말은 자식 오브젝트의 Transform이 부모오브젝트의 Transform에 종속된다는 뜻이다. 실제 화면으로 한 번 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기 Plane의 자식 오브젝트인 Cube가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_02.gif&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 화면처럼, 부모 오브젝트 Plane의 위치를 움직이면 그 자식 오브젝트인 cube는 부모오브젝트가 이동하는 만큼 함께 이동한다. 부모 오브젝트의 Scale를 변경하면 자식 오브젝트의 Scale도 부모의 변동 폭에 맞춰서 같은 비율로 변경될 것이다.&lt;/p&gt;

&lt;p&gt;이것을 응용하는 간단한 사례중 하나는 플레이어를 따라다니는 카메라이다. 이것도 한 번 구현해보자. 아주 간단하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_03.gif&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;적당한 바닥에 움직이는 큐브를 구현해두었다. 카메라가 Cube와 독립적으로 존재할 때는 Cube가 움직인다고 해도 카메라는 요지부동이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 카메라를 큐브에 드래그&amp;amp;드롭 하여 Cube의 자식으로 만든다. 이렇게 하면 카메라의 Transform의 좌표가 Cube를 기준으로 변경되는데 해당하는 좌표를 적당히 Cube의 중앙에 오게끔 해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_05.gif&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 후 테스트를 한 장면이다. 큐브가 움직임에 따라 메인 카메라가 큐브와 같은 방향으로 이동하는 모습이다.&lt;/p&gt;

&lt;p&gt;Transform은 또한 enumerator를 지원하기 때문에 foreach문에 적용이 가능하다고 한다.&lt;/p&gt;

&lt;p&gt;Transform의 변수 중 forward는 3D기준 파란색 축, z축을 나타내고, right는 x축, up은 y축을 나타낸다. position 변수는 vector3으로 선언되어 있으며 Transform의 현재 위치를 나낸다.&lt;/p&gt;

&lt;p&gt;Transform 컴포넌트의 변수, 메서드는 API 문서 링크에 설명이 잘 되어 있으니 한 번쯤 찾아보면 좋을 것 같다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티_초급학습_07</title>
      <link href="https://hjs101.github.io/Unity-07" rel="alternate" type="text/html" title="유니티_초급학습_07" />
      <published>2022-03-05T09:00:00+09:00</published>
      <updated>2022-03-05T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-07</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-07">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘은 이전 챕터에 이어서 클래스를 조금 더 만져보겠다.&lt;/p&gt;

&lt;h3 id=&quot;기본형과-참조형&quot;&gt;기본형과 참조형&lt;/h3&gt;

&lt;p&gt;변수의 타입은 기본형과 참조형으로 구분할 수 있다. 자바에서는 이를 Primitive Type과 References Type으로 나누는데, C#에서 명칭이 조금 다른 듯 하다. C#에서는 기본형을 Primitive Type이 아닌 Value 타입이라 부른다.&lt;/p&gt;

&lt;p&gt;기본형 : 변수에 주소가 아닌 값을 할당하는 타입, int, bool, float … 등의 기본형이 있다.&lt;/p&gt;

&lt;p&gt;※ 자바와 C#의 차이점&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;자바는 String 타입 변수가 참조형이지만 C#은 string 타입으로 기본형이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C#에서는 C에서 사용하던 struct, 구조체라는 것이 있는데, 이 구조체 타입의 변수는 기본형에 해당한다.
  ex) Vector3, Vector2, Color …&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참조형 : 변수에 할당하는 것이 주소값으로, 해당 주소를 통해서 메모리의 객체에 접근하는 변수. 자바와 의미가 같으며, 유니티에서 사용하는 모든 컴포넌트, 스크립트는 참조형에 해당한다.&lt;/p&gt;

&lt;p&gt;자 그럼, 이제 이 참조형 변수를 통해 오브젝트를 제어해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 오브젝트 큐브를 하나 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 후, RigidBody 컴포넌트를 큐브에 추가한다. 예전에, RigidBody는 오브젝트를 물리제어로 동작하게 하는 컴포넌트라고 설명했었다. 이 RigidBody 컴포넌트를 변수로 읽어와 코드를 통해 작동하게 해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 C# 스크립트를 하나 생성했다. 스크립트의 이름은 Jumper로 한다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Jumper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// RigidBody 타입의 변수 선언&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rigidbody&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myRigidbody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// RigidBody 타입의 메서드 AddForce 지정한 방향(x,y,z)으로 입력한 값만큼 힘을 부여한다.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;myRigidbody&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddForce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Update is called once per frame&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Jumper 스크립트에는 다음과 같이 적는다. 코드의 내용은 주석을 참고하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제, 큐브 오브젝트에 Jumper 스크립트를 컴포넌트로 추가한다. 위 사진처럼 검색해서 추가해도 되고, 그냥 스크립트 파일을 드래그해서 놓아도 된다.&lt;/p&gt;

&lt;p&gt;이제 Zoo C# 스크립트 파일을 새로 하나 더 생성하겠다. 해당 스크립트에서 Animal 클래스를 이용해 동물 인스턴스를 생성해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 컴포넌트의 상태이다. Public으로 변수를 선언해두었기 때문에 Inspector Window에 할당 할 수 있게 칸이 생겼다. 현재 상태는 내용물 없이 그릇만 준비되어있는 상태라고 생각하면 된다. 이제 아무것도 가리키고 있지 않은 이 참조형 변수 myRigidbody에 Rigidbody를 할당해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Inspector Window에서, RigidBody 컴포넌트를 드래그해서 사진의 위치에 드롭한다. 이 상태가 변수에 컴포넌트의 주소가 할당되어 실제 cube Object의 RigidBody 컴포넌트와 연결된 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_07.gif&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행시켜보면 다음과 같이 큐브가 위로 한 번 튀어오르는 것을 볼 수 있다. 위 과정을 글로 써보면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Jumper 스크립트의 Start() 메서드 실행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;myRigidbody.AddForce(0,500,0)이 실행.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 과정에서, 2번은 myRigidbody 변수에 연결된 컴포넌트에 있는 메서드를 실행하는 것이다. Jumper 스크립트에서 해당 메서드를 수행하는 것이 아닌, myRigidbody에 연결된 컴포넌트에서 수행한다는 점을 기억하자.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 클래스를 조금 더 다루어보았다. 기본형과 참조형의 차이, 참조형 변수는 주소를 가지고 있다는 것을 기억해두자.&lt;/p&gt;

&lt;p&gt;출판사에 보냈던 메일에 대한 답변으로 책 내용의 30% 이상은 포스팅하면 안된다는 의견을 받아, 교재 내용을 통해 포스팅하는 것은 이 글이 마지막이다. 퍼센트로 따지면 이 글까지 범위가 25%쯤 된다. 뒷내용은 게임을 제작하는 부분이므로. 앞으로 교재를 통해서 실습을 진행하겠지만, 해당 내용은 포스팅 되지 않을 것이다. 다음부터는 다른 내용의 실습으로 포스팅을 하겠다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티_초급학습_06</title>
      <link href="https://hjs101.github.io/Unity-06" rel="alternate" type="text/html" title="유니티_초급학습_06" />
      <published>2022-03-04T09:00:00+09:00</published>
      <updated>2022-03-04T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-06</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-06">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번에는 매우 중요한 개념인 객체지향에 대해서 간단하게 알아보겠다. 언어만 다를 뿐, 자바에서의 객체지향과 의미는 같아보인다. (개념에 대한 설명은 교재에 나와있지 않은 내용이니 참고해주세요.)&lt;/p&gt;

&lt;h3 id=&quot;객체&quot;&gt;객체&lt;/h3&gt;

&lt;p&gt;객체 : 개발자의 관점에서 객체는, 우리 주변에 있는 모든 것으로, 프로그래밍의 대상이 될 수 있는 모든 것을 객체로 정의한다. 이는 사물, 개념, 논리가 될 수도 있다.&lt;/p&gt;

&lt;p&gt;객체지향 프로그래밍은 다음을 의미한다. 주변의 많은 객체화 할 수 있는 대상을 객체화 시켜 프로그래밍 하는 것이다. 프로그램 밖에 있는 것들을 프로그램 안으로 끌어들이는 것이라고 생각한다.&lt;/p&gt;

&lt;p&gt;###클래스와 인스턴스&lt;/p&gt;

&lt;p&gt;클래스 : 클래스는 객체를 정의해 놓은 것이다. 즉 객체를 생성하기 위한 설계도이다. 흔히들 붕어빵 틀에 비유하곤 한다. 붕어빵 틀은 붕어빵을 찍어내기 위한 틀이고, 틀을 이용해서 붕어빵을 만들 수 있다. 여기서 틀에 해당하는 것이 클래스, 붕어빵에 해당하는 것이 인스턴스이다.&lt;/p&gt;

&lt;p&gt;인스턴스 : 위에서 말했듯, 클래스를 통해 데이터 타입으로 생성되어 메모리에 적재된 것을 인스턴스라고 한다. 교재에서 새롭게 알게 된 사실로, 오브젝트가 인스턴스를 포함하는 개념이기 때문에, 같은 의미로 혼용하기도 한다고 한다.&lt;/p&gt;

&lt;p&gt;추가적으로 멤버변수와 지역변수의 차이까지만 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;변수&quot;&gt;변수&lt;/h2&gt;

&lt;p&gt;멤버변수 : 클래스 내부에서 선언되는 변수이다. 해당 클래스에 있는 생성자, 메서드에서 사용가능하다. 멤버변수는 또 2가지로 나눌 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;static 변수 : Class 변수이다. class가 로딩 시에 자동으로 메모리에 적재된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;non-static 변수 : Instance 변수, 필요시에 new 클래스이름()으로 인스턴스를 생성할 때 같이 메모리에 적재된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞서 클래스와 인스턴스를 구분해서 설명한 것과 이어서 생각해보자. static과 non-static의 차이에 대해 느낌이 좀 올 것이다.&lt;/p&gt;

&lt;p&gt;이 이외에도 추상화, 상속, 다형성, 캡슐화 등 설명하지 못한 많은 내용이 남아있지만 유니티로 넘어가기 위해 일단 여기까지만 설명하고 넘어가도록 하겠다.&lt;/p&gt;

&lt;h2 id=&quot;c-클래스&quot;&gt;C# 클래스&lt;/h2&gt;

&lt;p&gt;이제 유니티에서 클래스와 오브젝트에 대한 예제를 풀어 실습해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 프로젝트를 하나 생성했다. 프로젝트 이름은 Hello Class로 지었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티의 project window에 오른쪽 클릭을 하고 Create -&amp;gt; C# Script를 하나 생성했다. 이름은 Animal로 지었다. 이제 이 스크립트를 수정해보겠다. 교재에서 주어진 요구사항은 Animal 클래스는 멤버변수로 이름과 울음소리를 가지며, 울음소리를 재생하는 메서드 PlaySound를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요구사항대로 수정한 Animal 클래스이다. 변수와 메서드의 접근제한자는 public으로 두었다. 앞서 설명했듯 이것은 객체를 생성하기 위한 틀이기 때문에 이 자체로는 아무런 일도 일어나지 않는다. 기왕 실습하는 거 생성자까지 만들어보았다. 생성자는 객체가 생성될 때 초기화 해야할 변수, 또는 수행해야되는 로직이 있다면 객체가 생성되면서 수행할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 Zoo C# 스크립트 파일을 새로 하나 더 생성하겠다. 해당 스크립트에서 Animal 클래스를 이용해 동물 인스턴스를 생성해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로생성한 Zoo 스크립트 파일을 수정해서 gaji라는 동물을 하나 생성해보겠다. 가지는 친구집 고양이 이름이다 ^^&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성자 규칙대로 객체를 하나 생성했다. 잘 동작하는지 테스트해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트에 빈 오브젝트를 하나 생성해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_08.jpg&quot; alt=&quot;Unity_08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 후, Zoo 스크립트를 컴포넌트로 빈 오브젝트에 추가해주었다. 이제 실행 버튼을 눌러 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_09.jpg&quot; alt=&quot;Unity_09&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zoo에서 Animal 클래스를 이용해 Animal타입 gaji 라는 변수명의 객체를 생성하였고, 설정한 변수명이 제대로 입력되어있는 것과, PlaySound 기능이 잘 동작하는 것을 확인 할 수있다.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 클래스를 만들어 테스트해보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
</feed>
