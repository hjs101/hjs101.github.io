<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hjs101.github.io/tag/unity/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hjs101.github.io/" rel="alternate" type="text/html" />
  <updated>2022-03-15T02:41:50+09:00</updated>
  <id>https://hjs101.github.io/tag/unity/feed.xml</id>

  
  
  

  
    <title type="html">hjs’s Blog | </title>
  

  
    <subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">유니티 토막 지식_05</title>
      <link href="https://hjs101.github.io/Unity-12" rel="alternate" type="text/html" title="유니티 토막 지식_05" />
      <published>2022-03-13T09:00:00+09:00</published>
      <updated>2022-03-13T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-12</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-12">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 공간과 움직임 파트를 공부했다. 내용이 이해하기 쉽지 않아 조금 더 살펴봐야 할 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2021.1/Manual/EventFunctions.html&quot;&gt;이벤트 함수&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 이벤트 함수이다.&lt;/p&gt;

&lt;h5 id=&quot;정의&quot;&gt;정의&lt;/h5&gt;

&lt;p&gt;유니티의 스크립트는, 전통적인 프로그램처럼 작업이 완료될 때까지 코드가 루프를 계속 실행하는 프로그램과는 개념이 다르다. 이전 게시글에 잠깐 설명한 적이 있는데, 특정한 일(event)이 일어났음을 외부의 subscriber들에게 알려준다(브로드캐스팅). 이후 해당하는 이벤트에 등록되어있는 함수들은 브로드캐스팅된 메시지를 받아 자동적으로 실행이 되는 구조이다. 이렇게 이벤트에 대응하여 코드를 실행하는 함수를 이벤트 함수라고 한다.&lt;/p&gt;

&lt;p&gt;유니티는 특정 이벤트에 대해, 호출할 함수를 확인하기 위해 이름을 지정하여 사용한다. 우리가 처음 스크립트를 만들면 자동으로 생성되는 Start함수(오브젝트가 처음 활성화 될 때 호출된다.)와 Update 함수도 이벤트 함수의 일종이다. 몇 가지 중요한 이벤트 함수에 대해 알아보자.&lt;/p&gt;

&lt;h5 id=&quot;정기-업데이트-이벤트&quot;&gt;정기 업데이트 이벤트&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Update
  게임 프로그래밍의 핵심 개념 중 하나는 각 프레임이 렌더링 되기 전에 게임에서 오브젝트의 위치, 상태 및 동작을 변경하는 것이다. 이런 코드는 주로 Update 함수에 주로 추가된다. Update함수는 프레임이 렌더링 되기 이전에 호출되며, 애니메이션이 계산되기 이전에도 호출된다.
  메뉴얼에는 어려운 말로 쓰여있지만, 실시간으로 계속 체크하고 변화해야되는 상황에 Update를 사용한다고 생각하면 될 것 같다.
  다만 이 함수는 &lt;strong&gt;프레임&lt;/strong&gt; 단위로 수행된다는 점은 기억해두자.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;void Update() {
    float distance = speed * Time.deltaTime * Input.GetAxis(&quot;Horizontal&quot;);
    transform.Translate(Vector3.right * distance);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;FixedUpdate
  이 함수는 물리의 Timestep에 설정된 값에 따라 수행된다. 이 함수는 Update 함수와 유사한 기능을 가지고 있지만 물리 Timestep에 따른 물리 업데이트 직전에 호출된다. 물리적인 이동과 관련된 코드는 Update가 아니라 FixedUpdate에 추가하면 더욱 정확한 결과를 얻을 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;void FixedUpdate() {
    Vector3 force = transform.forward * driveForce * Input.GetAxis(&quot;Vertical&quot;);
    rigidbody.AddForce(force);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;LateUpdate
  이 함수는, Update 함수 또는 FixedUpdate 함수가 수행된 이후, 또는 모든 애니메이션이 계산된 이후에 수행되는 함수이다. 사용하는 예는 카메라가 타겟 오브젝트를 계속해서 따라갈 경우, 타겟이 이동 한 후에 카메라는 움직여야하기 때문에 사용합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;void LateUpdate() {
    Camera.main.transform.LookAt(target.transform);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;초기화-이벤트&quot;&gt;초기화 이벤트&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start
  첫 프레임이나 오브젝트의 물리 업데이트가 시작되기 이전에 최초로 한 번 수행된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Awake
  씬이 로드될 때 씬의 각 오브젝트에 대해 호출된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;※ Start와 Awake의 차이점
  Awake는 항상 Start보다 먼저 수행하여 완료된다. 따라서 Start는 Awake의 초기화 된 값을 사용가능하다. 수행 순서를 기억해두자. &lt;strong&gt;Awake -&amp;gt; Start&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;gui-이벤트&quot;&gt;GUI 이벤트&lt;/h5&gt;

&lt;p&gt;유니티에서 GUI에 대한 이벤트는 예전에는 OnGui 함수를 통해 사용했다고 한다. 하지만 유니티의 공식 UI 시스템인 UGUI가 등장함에 따라 해당 함수는 쓰임새가 사라졌다고 한다. UGUI를 사용하 UI요소를 게임 오브젝트 &amp;amp; 컴포넌트처럼 다루고 편집할 수 있다.&lt;/p&gt;

&lt;h5 id=&quot;물리-이벤트&quot;&gt;물리 이벤트&lt;/h5&gt;

&lt;p&gt;물리 이벤트에 대 함수는 이전 글에 설명을 해두었다. 여기서는 물리 엔진이 오브젝트의 스크립트에 있는 이벤트 함수를 호출한다는 점만 알아두면 될 것 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;void OnCollisionEnter(otherObj: Collision) {
    if (otherObj.tag == &quot;Arrow&quot;) {
        ApplyDamage(10);
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_06</title>
      <link href="https://hjs101.github.io/Unity-13" rel="alternate" type="text/html" title="유니티 토막 지식_06" />
      <published>2022-03-13T09:00:00+09:00</published>
      <updated>2022-03-13T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-13</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-13">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 공간과 움직임 파트를 마쳤다. 내일부터 유니런 제작 실습을 할 예정이다.&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 디자인 패턴이다. 지금까지 제대로 유니티에 적용해본 패턴은 싱글톤 하나 뿐이지만, 다양한 디자인 패턴들을 익혀두면 게임 제작을 할 때 적용가능한 패턴이 자연스럽게 떠오를 것 같다.&lt;/p&gt;

&lt;h5 id=&quot;싱글톤-패턴&quot;&gt;싱글톤 패턴&lt;/h5&gt;

&lt;p&gt;유니티에서도 사용해봤고, 자바에서도 사용해봤다. 싱글톤의 핵심은 단일 인스턴스 반환이다. 객체의 인스턴스를 1개만 생성해두고 그 1개의 인스턴스에만 접근하는 것이다.&lt;/p&gt;

&lt;p&gt;유니티에서 싱글톤 패턴은 주로 게임 시스템 전체를 통괄하는 스크립트이거나,(ex. gameManager) 전역변수처럼 사용해야할 때 사용한다. 또는 씬이 변경될 때 파괴되면 안되는 오브젝트에도 싱글톤을 반영한다.&lt;/p&gt;

&lt;h6 id=&quot;싱글톤-패턴의-사용&quot;&gt;싱글톤 패턴의 사용&lt;/h6&gt;

&lt;p&gt;유니티에서 싱글톤 패턴을 사용하는 방법은 2가지가 있다. 첫 번째는 게임오브젝트로써 씬에 존재하게 할 수 있고(MonoBehaviour을 상속받는다.), 두 번째는 게임 오브젝트로 존재하지 않게 하는 방법이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Singleton : MonoBehaviour
{

    private static Singleton instance = null;

    // 처음 활성화 될 때 생성되고, DontDestroyOnLoad 메서드로 인해 씬이 변경된다 하더라도 파괴되지 않는다.
    // static 변수로 선언했기 때문에 다른 클래스에서도 직접적으로 호출이 가능해진다.
    void awake()
    {
        if (instance == null)
        {
            instance = this;

            DontDestroyOnLoad(this.gameObject);
        }
        else
        {
            // 만약 씬이 바뀌었는데 바뀐 씬에 동일한 오브젝트가 이미 있는 경우 그 오브젝트를 파괴해준다.
            // 만약 이 작업을 하지 않아 2개의 인스턴스가 생성되면 단일 인스턴스가 아니게 된다.
            Destroy(this.gameObject);
        }
    }

    // 다른 클래스에서는 퍼블릭으로 선언되어있는 아래의 프로퍼티를 이용해 호출할 수 있다.
    public static Singleton Instance
    {
        get
        {
            if (instance == null)
            {
                return null;
            }

            return instance;
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;간단한 사용방법이다. 위 방법은 MonoBehaviour에 상속을 받아 씬 내부에 존재할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;두 번째 방법은 자바에서와 같은 방식으로 생성한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Singleton2
{
    private static Singleton2 instance;

    public static Singleton2 Instance
    {
        get
        {
            // 인스턴스가 존재하지 않는 경우 딱 한 번 생성하고, 그 후에는 생성한 인스턴스를 반환한다.
            if (null == instance)
            {
                instance = new Singleton2();
            }
            return instance;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 두 가지 방법으로 싱글톤을 생성할 수 있다.&lt;/p&gt;

&lt;h6 id=&quot;장단점&quot;&gt;장단점&lt;/h6&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;장점 : 고정된 영역의 인스턴스를 한 번만 생성하여 사용하기 때문에 메모리 절약이 된다. 또한 전역으로 사용할 수 있어 다른 클래스에서 접근이 용이하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단점 : 싱글톤 단일로만 사용할 경우 객체지향 원칙(SOLID)에 위배된다. OCP, Open-Closed Principle 원칙은 개방-폐쇄 원칙인데. 확장에는 개방되어야하고, 수정에는 폐쇄되어야하는 원칙이다. 싱글톤 패턴은 하나의 인스턴스와 다양한 클래스가 연결되기 때문에 결합도가 높아져 객체의 인터페이스가 제대로 분리되지 못하게 되어 객체지향적이지 않게 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_04</title>
      <link href="https://hjs101.github.io/Unity-11" rel="alternate" type="text/html" title="유니티 토막 지식_04" />
      <published>2022-03-11T09:00:00+09:00</published>
      <updated>2022-03-11T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-11</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-11">&lt;p&gt;오늘은 상당히 진빠지는 시험을 보게 되어 추가적인 유니티 공부는 하지 못했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2022.1/Manual/PhysicsOverview.html&quot;&gt;3D 물리&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 유니티에서 사용하는 물리에 관한 컴포넌트들을 살펴보겠다.&lt;/p&gt;

&lt;h5 id=&quot;rigidbody&quot;&gt;RigidBody&lt;/h5&gt;

&lt;p&gt;리지드바디(RigidBody)는, 앞서서도 여러 번 설명한 적이 있는 컴포넌트이다. 게임 오브젝트가 물리적 동작을 가능하게 하는 주요 컴포넌트이다.&lt;/p&gt;

&lt;p&gt;리지드바디는 연결된 게임 오브젝트의 이동을 제어한다. 따라서 스크립트에서 포지션이나 회전처럼 TransForm의 프로퍼티를 변경시켜 오브젝트를 이동하려고 하면 안된다. 값을 변경하는 대신 Forces. 즉 오브젝트에 &lt;strong&gt;힘을 가하고, 그 힘에 대해 물리 엔진이 결과를 계산&lt;/strong&gt;할 수 있도록 해야한다.&lt;/p&gt;

&lt;p&gt;경우에 따라서 특정 게임 오브젝트에 리지드바디를 추가하되, 물리 엔진의 제어를 받는 것이 싫을 때가 있다. 예를 들면 스크립트 코드로 캐릭터를 직접 제어하면서도, 캐릭터가 트리거에 의해 감지되게 하려고 할 때가 있다.&lt;/p&gt;

&lt;p&gt;리지드바디에는 Is Kinematic 이라는 프로퍼티가 있다. 이 프로퍼티는 물리 엔진의 제어대상에서 해당 컴포넌트를 제외한다. 키네마틱 프로퍼티가 켜져 있는 상태라면 스크립트에서 비물리적인 모션을 적용할 수 있다. 이러한 모션을 키네마틱 모션이라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_10_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림과 같이 체크박스를 통해 키네마틱을 켜고 끌 수 있다. 스크립트 안에서도 Is Kinematic의 값을 변경할 수 있지만, 성능 오버헤드가 발생한다고 하니 신중하게 사용하자.&lt;/p&gt;

&lt;p&gt;※ 리지드바디의 휴면 : 리지드바디가 정의된 최소 선형, 또는 회전 속도보다도 더 느리게 이동하면 물리 엔진에서는 정지했다고 간주한다. 움직이지 않는 리지드바디는 다시 힘이 가해지거나 충돌하기 전 까지는 움직이지 않기 때문에 이때 유니티에서는 리지드바디를 “휴면” 모드로 설정한다. 이러한 최적화는, 리지드바디가 다음번에 &lt;em&gt;WakeUp&lt;/em&gt; 할 때까지 프로세서의 자원이 사용되지 않는다.&lt;/p&gt;

&lt;h5 id=&quot;collider&quot;&gt;Collider&lt;/h5&gt;

&lt;p&gt;콜라이더 컴포넌트는 물리적 충돌을 위한 게임 오브젝트의 모양을 정의한다. 흔히들 많이 이야기하는 충돌판정에 대한 컴포넌트이다.&lt;/p&gt;

&lt;p&gt;콜라이더는 기본 콜라이더, 복합 콜라이더, 메시 콜라이더, 정적 콜라이더 등 많은 종류가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;기본 콜라이더 : 가장 간단하고, 자원을 적게 먹는 콜라이더다. 3D에선 박스 콜라이더, 스피어 콜라이더, 캡슐 콜라이더가 이에 해당한다. 2D에서는 박스 콜라이더2D, 써클 콜라이더2D를 사용할 수있다. 기본 콜라이더를 여러 개 중첩해 복합 콜라이더를 만들 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복합 콜라이더 : 자원을 적게 먹으면서도 게임 오브젝트의 대략적인 모양을 만들 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;메시 콜라이더 : 복합 콜라이더를 통해서도 게임 오브젝트의 모양을 표현하기 힘들고, 더 정확한 콜라이더 표현이 필요한 경우 사용하는 콜라이더이다. 이 콜라이더는 게임 오브젝트의 메시 모양에 정확히 맞출 수 있지만, &lt;strong&gt;프로세서에 큰 부담&lt;/strong&gt;을 주기 때문에 꼭 필요한 경우에만 사용해야 한다. 또한 메시 콜라이더와 메시 콜라이더, 즉 메시 콜라이더끼리는 충돌이 일어나지 않는 문제가 있다. 이 문제를 해결하기 위해서 메시 콜라이더는 인스펙터 창에서 Convex로 설정해 “볼록 다각형” 모양의 콜라이더로 생성할 수 있다. (파인 부분이 사라짐)
 일반적으로 메시 콜라이더는 씬 지오메트리에 사용한다. 2D에서는 폴리곤 콜라이더 2D를 통해 세부 조절이 가능하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_10_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;정적 콜라이더 : RigidBody 컴포넌트 없이 콜라이더를 게임 오브젝트에 추가하여 바닥, 벽과 같은 고정된 오브젝트에 사용하는 콜라이더를 말한다. 반대로 RigidBody가 있는 콜라이더는 동적 콜라이더라고 부른다. 정적 콜라이더는 동적 클라이더와 상호작용이 가능하나, 충돌에 의한 물리 이동이 일어나지 않는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;트리거&quot;&gt;트리거&lt;/h5&gt;

&lt;p&gt;콜라이더에 트리거를 사용하면 해당 콜라이더는 솔리드 오브젝트로 동작하지 않는다. 간단히 말해 부딛히지 않는 다는 뜻이다. 하지만 스크립트 내부에서 OnTriggerEnter 함수를 이용하여 해당 콜라이더가 다른 콜라이더와 부딛혔을 때(겹쳤을 때)의 로직 처리를 할 수 있다.&lt;/p&gt;

&lt;p&gt;※ 충돌에 대한 콜백 함수&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OnCollisionEnter : 충돌이 감지되었을 때 가장 먼저 일어난다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;OnCollisionStay : 충돌 -&amp;gt; 접촉이 지속되는 상황동안 계속 호출 접촉이 해제될 때 OnCollisionExit가 호출된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;트리거의 경우 위에서 Collision을 Trigger으로 바꾼다. (OnTriggerEnter, OnTriggerStay, OnTriggerExit)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2D에서는 함수명 끝에 2D 첨자가 붙는다. ex) OnCollisionEnter2D&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;콜라이더-사이의-상호작용&quot;&gt;콜라이더 사이의 상호작용&lt;/h5&gt;

&lt;p&gt;콜라이더는 크게 정적 콜라이더, 동적 콜라이더로 나눌 수 있다. 이는 리지드바디의 유무에 따라서 구분하며, 추가적으로 키네마틱이 활성화된 리지드바디 콜라이더까지 추가하여 각각의 상호작용에 대해 알아보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;정적 콜라이더 : 정적콜라이더는 앞에서 설명했듯 리지드바디가 없다. 따라서 항상 같은 위치에 절대 움직이지 않는 것에 주로 사용된다. 다른 동적 콜라이더를 가진 객체와 충돌해도 정적콜라이더는 움직이지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리지드바디 콜라이더 : 일반적인 비키네마틱 리지드바디와 콜라이더를 가진 오브젝트가 동적 콜라이더이다. 물리엔진에 의해 제어되며 충돌, 힘 모두에 반응하여 움직일 수 있다. 가장 흔하게 사용되는 콜라이더이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;키네마틱 리지드바디 콜라이더 : 리지드바디와 콜라이더를 함께 가졌지만 해당 리지드바디에 Iskinematic이 활성화되어있는 콜라이더를 말한다. 키네마틱 리지드바디 콜라이더는 정적 콜라이더처럼 힘과 충돌에 반응하지 않지만, 스크립트에 의한 TransForm 컴포넌트 수정을 통해서는 움직일 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 콜라이더는 상황에 따라 움직일 수 있지만 그 외 상황에서는 정적 콜라이더처럼 작용한다. 예를 들면 평소에는 움직이지 않는 장애물처럼 동작하지만, 필요할 때는 열 수 있는 문과 같은 경우이다. 정적 콜라이더는 다른 오브젝트에 마찰이 작용할 수 있으며, 접촉이 일어난 경우 다른 리지드바디를 &lt;strong&gt;WakeUp&lt;/strong&gt; 시킬 수 있다.&lt;/p&gt;

&lt;p&gt;※ 리지드바디 컴포넌트는 Iskinematic 프로퍼티를 사용하여 언제는 키네마틱, 일반 리지드바티로 전환할 수 있다. 이를 이용하는 좋은 예로 래그돌 효과가 있다. 래그돌 효과는 사망 애니매이션을 고정된 애니메이션으로 사용하는 것이 아니라 물리적인 터리를 통해 다양한 사망 모션을 연출하기 위한 기법이다.&lt;/p&gt;

&lt;p&gt;이는 키네마틱 리지드바디를 이용하여 구현할 수 있다. 사망 직전까지는 키네마틱 리지드바디를 이용하여 애니메이션에 의해 일반적으로 움직이다가, 비활성화되는 순간 키네마틱을 비활성화시켜 물리오브젝트로 동작하게 하는 것이다. 폭발에 의해 날아가는 시체가 흐느적거리며 날아가는 장면 등이 이런 효과를 이용한 것이다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">오늘은 상당히 진빠지는 시험을 보게 되어 추가적인 유니티 공부는 하지 못했다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_03</title>
      <link href="https://hjs101.github.io/Unity-10" rel="alternate" type="text/html" title="유니티 토막 지식_03" />
      <published>2022-03-10T09:00:00+09:00</published>
      <updated>2022-03-10T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-10</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-10">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 벡터와 회전에 대해 공부했다. 고등학교 때 배웠던 내용이 조금이나마 떠올라서 조금 그리운 느낌도 들었다.&lt;/p&gt;

&lt;p&gt;그렇다고 매 포스팅을 한 줄짜리 일기로 끝낼 수 없기 때문에, 유니티 API 문서를 토대로 유니티를 사용하는데 도움이 되는 지식을 공부하고, 포스팅하려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2022.1/Manual/VectorCookbook.html&quot;&gt;Vector&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 Vector이다.&lt;/p&gt;

&lt;h4 id=&quot;정의&quot;&gt;정의&lt;/h4&gt;

&lt;p&gt;벡터는 &lt;strong&gt;방향&lt;/strong&gt;과 &lt;strong&gt;크기&lt;/strong&gt;를 설명할 수 있는 기본적인 수학적 개념이다. 게임이나 앱에서 벡터는 종종 캐릭터의 위치, 움직이는 속도, 두 물체 사이의 거리와 같은 기본 특성들을 묘사할 때 사용된다.&lt;/p&gt;

&lt;p&gt;벡터 연산은 그래픽스, 물리, 애니매이션 등과 같이 많은 요소에 핵심이 된다. Unity를 최대한 활용하기 위해서는 벡터 연산을 깊이 이해하는게 좋다고 한다.&lt;/p&gt;

&lt;p&gt;벡터는 여러 차원으로 표현이 가능하다. Unity는 2D,3D,4D 벡터작업이 가능한 각각의 클래스를 제공한다.&lt;/p&gt;

&lt;h3 id=&quot;벡터의-연산&quot;&gt;벡터의 연산&lt;/h3&gt;

&lt;h5 id=&quot;덧셈&quot;&gt;덧셈&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_09_01.png&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 벡터의 덧셈은 두 개의 벡터의 좌표를 각각 더해주는 것을 말한다. 좌표를 더하는 순서가 달라지더라도 결과는 같기 때문에 더하는 &lt;strong&gt;순서는 상관없다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;벡터가 힘을 나타내는 단위일 때 벡터를 힘의 크기인 강도와 방향으로 간주할 경우 더욱 와닿는다. 두 가지 힘의 벡터를 서로 더하면, 두 힘을 합한 값과 동일한 새로운 벡터가 생성된다. -&amp;gt; 동시에 다수의 서로 다른 컴포넌트에 힘을 가할 때 유용하다. ex) 활을 쏠 때 바람에 따라 세기와 방향이 변동할 수 있음.&lt;/p&gt;

&lt;p&gt;그림은 2D Vector로 예시를 들었지만, 3D와 4D에서도 동일하게 적용된다.&lt;/p&gt;

&lt;h5 id=&quot;뺄셈&quot;&gt;뺄셈&lt;/h5&gt;

&lt;p&gt;벡터의 뺄셈은 특정 오브젝트에서 다른 오브젝트까지의 거리, 방향을 구할 때 주로 사용한다. 이 과정에서 &lt;strong&gt;파라미터의 순서&lt;/strong&gt;는 매우 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_09_02.png&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 두 벡터 a, b의 뺄셈 b-a가 의미하는 것은 무엇일까? 바로 a에서 b까지의 거리, 방향 벡터를 의미한다. 물론 반대, a-b는 b에서 a까지의 거리, 방향 벡터이다.&lt;/p&gt;

&lt;p&gt;벡터는 값이 아닌 방향이 존재하기 때문에 당연하게도 a-b != b-a이다. 만약 a 위치에서 b위치까지의 거리를 알고싶다면 b의 벡터값에서 a의 벡터값을 뺄셈 해주면 해당하는 거리와 방향의 벡터를 얻을 수 있을 것이다.&lt;/p&gt;

&lt;h5 id=&quot;벡터의-정규화&quot;&gt;벡터의 정규화&lt;/h5&gt;

&lt;p&gt;정규화된 벡터란, 벡터의 길이가 1인 벡터를 말한다. 정규화 된 벡터를 구하는 방법은 2가지가 있다.&lt;/p&gt;

&lt;p&gt;벡터 A가 있다고 할 때&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;Vector3 A = (1,1,1);
// 벡터의 길이
float distance = A.magnitude;
// 정규화 벡터
Vector3 direction = A / distance;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;Vector3 A = (1,1,1);
// 정규화 벡터
Vector3 direction = A.normalized;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;스칼라-곱셈과-나눗셈&quot;&gt;스칼라 곱셈과 나눗셈&lt;/h5&gt;

&lt;p&gt;스칼라는 단순이 크기만을 가지고 있는 것을 말한다. 벡터는 앞서 말했듯 크기, 방향을 함께 가지고 있다.&lt;/p&gt;

&lt;p&gt;벡터에 스칼라를 곱한다면 그 결과는 오리지널과 &lt;strong&gt;동일한 방향&lt;/strong&gt; 을 가리키는 벡터이다. 벡터에 스칼라를 곱하거나 나누어도 방향은 변하지 않는다. 그러나 크기는 각각의 벡터의 크기에 해당하는 스칼라를 곱하거나 나눈 값과 같다. 앞의 정규화에서 먼저 사용했는데. A라는 벡터에 A벡터의 크기만큼 스칼라 값을 나눗셈 해주었더니, 크기가 1인 정규화된 벡터가 되었다. 영어로는 normalized Vector라고 한다.&lt;/p&gt;

&lt;h5 id=&quot;벡터의-내적&quot;&gt;벡터의 내적&lt;/h5&gt;

&lt;p&gt;벡터의 내적은 두 벡터를 받아 스칼라를 반환한다. 이 스칼라는 두 벡터의 크기를 곱한 후, 그 결과의 두 벡터 사이의 각도에 대해 코사인값을 곱한 것과 같다. 두개의 벡터가 모두 정규화된 벡터일 경우, 코사인 값은 첫 번째 벡터에서 2번째 벡터의 방향으로 기울어진 기울기를 나타낸다. 이 경우 두 벡터의 &lt;strong&gt;순서는 상관이 없다.&lt;/strong&gt; 스칼라는 부호가 없기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_09_03.png&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내적은 다른 벡터의 방향에 있는 한 벡터의 크기를 계산 할 때 유용하게 사용할 수 있다. 유니티에서는 내적을 간단하게 구할 수 있게 메서드를 제공한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;Vector3 vec1 = new Vector3(1,0,0);
Vector3 vec2 = new Vector3(0,1,0);
var dot = VecTor3.Dot(vec1, vec2);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;벡터의-외적&quot;&gt;벡터의 외적&lt;/h5&gt;

&lt;p&gt;벡터의 외적은 3D 벡터에만 해당되는 개념이다. 두 개의 3D 벡터를 입력으로 사용하여, 다른 3D 벡터를 반환한다.
반환하는 벡터는 두 입력 벡터에 대해 수직이다. 오른손 법칙을 사용하여, 입력 벡터의 순서에서 출력 벡터의 방향을 기억할 수 있다. 2개의 벡터가 있을 때 순서를 서로 다르게 하여 벡터의 외적을 구하면 만들어진 두 외적은 서로 정확히 &lt;strong&gt;반대 방향&lt;/strong&gt;을 가리킬 것이다. 벡터의 외적의 크기는, 입력 벡터들의 크기를 곱하고, 그 결과에 두 벡터 사이 각도의 Sin 값을 곱한 것과 같다.&lt;/p&gt;

&lt;p&gt;벡터의 외적은 Sin, Cos 같은 함수를 써야할 상황에 외적을 이용하면 최적화에 많은 도움이 된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_02</title>
      <link href="https://hjs101.github.io/Unity-09" rel="alternate" type="text/html" title="유니티 토막 지식_02" />
      <published>2022-03-08T09:00:00+09:00</published>
      <updated>2022-03-08T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-09</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-09">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;오늘은 닷지 게임을 완성하고 빌드하는 과정을 거쳤다.&lt;/p&gt;

&lt;p&gt;그렇다고 매 포스팅을 한 줄짜리 일기로 끝낼 수 없기 때문에, 유니티 API 문서를 토대로 유니티를 사용하는데 도움이 되는 지식을 공부하고, 포스팅하려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/2022.1/Manual/class-GameObject.html&quot;&gt;GameObject&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 GameObject 이다.&lt;/p&gt;

&lt;h4 id=&quot;정의&quot;&gt;정의&lt;/h4&gt;

&lt;p&gt;GameObject는 씬 내에 존재할 수 있는 모든 요소를 나타낼 수 있는 클래스이다.&lt;/p&gt;

&lt;p&gt;일반적으로 스크립트에서 GameObject를 사용하는 목적은 대부분 다른 오브젝트를 관리하기 위함이다. 해당 스크립트를 컴포넌트로 갖는 오브젝트는 gameObject로 접근할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;※GameObject와 gameObject의 차이&lt;/p&gt;

&lt;p&gt;헷갈릴 수 있는데, 앞서 말했듯이 GameObject는 클래스이다. 실제 내용물이 아니라 틀이라고 생각하면 된다. 스크립트 내에서 GameObject 타입으로 변수를 선언할 수 있다. 즉, GameObject는 형(type)의 일종이라고 볼 수 있다. gameObject는 앞서 말한 것처럼 해당 스크립트를 컴포넌트로 갖는 오브젝트이다. gameObject는 스크립트를 컴포넌트로 게임오브젝트에 부착한 순간부터 이미 값이 할당되어 있다고 생각하면 된다. 스크립트에서 gameObject를 사용하는 경우는 자기 자신 오브젝트에 접근하는 경우이고, GameObject를 사용하는 경우는 다른 오브젝트에 접근하는 경우에 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;기본-구성&quot;&gt;기본 구성&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_08_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;게임 오브젝트는 씬에서 생성하면 기본적으로 활성화된 상태이다. 체크박스를 해제하여 비활성화를 할 수 있다.&lt;/p&gt;

&lt;p&gt;게임 오브젝트를 비활성화하면 게임 오브젝트에 연결된 모든 컴포넌트가 해제된다. 일반적으로 비활성화 시킨 게임 오브젝트는 화면에 보이지 않게 되고, Update, FixedUpdate 등과 같은 정규 콜백이나 이벤트를 수신하지 않는다.&lt;/p&gt;

&lt;p&gt;스크립트 내에서 GameObject.SetActive(boolean값) 을 이용하여 게임 오브젝트의 활성상태를 제어할 수 있다.&lt;/p&gt;

&lt;p&gt;그 오른쪽에 있는 static 체크박스는, 게임 오브젝트가 움직일 수 있는지 가능 여부를 고를 수 있다. 해당 부분은 최적화에 쓰이는데, 예를 들어 움직이지 않는 게임 오브젝트들을 batch(배치)라는 하나의 큰 오브젝트로 결합시킴으로써 렌더링을 최적화 할 수 있다.&lt;/p&gt;

&lt;p&gt;오브젝트에는 태그와 레이어가 존재하는데, 태그는 씬에서 게임 오브젝트의 타입을 표시, 식별할 수 있게 한다.
레이어는 렌더링 또는 물리 충돌 같은 특정 빌트인 동작에 대해 게임 오브젝트를 그룹화하여 제어할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;게임 오브젝트에 컴포넌트를 자유롭게 부착, 제거할 수 있다. 기초 글에도 있듯이, 게임 오브젝트에 부착하는 각 컴포넌트는 독립적으로 구성된다.&lt;/p&gt;

&lt;p&gt;스크립트에서 컴포넌트에 접근할 때는 GetComponent 메서드를 사용하여 접근할 수 있다. 해당 메서드는 스크립트 내에서 단독으로 사용하면 현재 게임 오브젝트의 컴포넌트를 읽어온다. 이 때, 제네릭의 개념이 사용되는데.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;RigidBody rb = GetComponent&amp;lt;RigidBody&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;라고 한다면, &lt;RigidBody&gt; 부분을 제네릭이라고 생각하면 된다. 유니티의 관점에서 생각해보면, 컴포넌트는 수 없이 많다. 그런데 제네릭이 없이 그냥 GetComponent만으로 컴포넌트를 읽어온다고 생각해보자. 이 경우 조건문 같은 사후 처리를 통해 읽어온 컴포넌트가 내가 원하는 컴포넌트인지 확인하는 작업이 따로 필요해진다. 이 때 미스매치가 되는 경우 Exception이 발생할 수도 있다. 반면 제네릭을 사용하여 &quot;나는 이러한 타입의 컴포넌트를 읽어올거야&quot; 라고 미리 지정해 두면, 컴파일 과정에서 해당하는 타입의 컴포넌트를 바로 읽어올 수 있는 것이다.&lt;/RigidBody&gt;&lt;/p&gt;

&lt;h4 id=&quot;부모자식-관계&quot;&gt;부모자식 관계&lt;/h4&gt;

&lt;p&gt;게임 오브젝트는 Transform 컴포넌트를 기본적으로 가지고 있다. TransForm 컴포넌트는 Parenting, 부모자식관계를 사용할 수 있다. 스크립트에서 이 부모자식관계를 이용해 부모 게임 오브젝트로부터 자식 오브젝트를 검색하여 가져올 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티 토막 지식_01</title>
      <link href="https://hjs101.github.io/Unity-08" rel="alternate" type="text/html" title="유니티 토막 지식_01" />
      <published>2022-03-07T09:00:00+09:00</published>
      <updated>2022-03-07T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-08</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-08">&lt;p&gt;Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.&lt;/p&gt;

&lt;p&gt;어제와 오늘에 걸쳐서, 닷지 게임 제작의 2/3을 완료했다. 내일은 닷지 게임 완성에 들어갈 듯 하다.&lt;/p&gt;

&lt;p&gt;그렇다고 매 포스팅을 한 줄짜리 일기로 끝낼 수 없기 때문에, 유니티 API 문서를 토대로 유니티를 사용하는데 도움이 되는 지식을 공부하고, 포스팅하려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/kr/530/ScriptReference/Transform.html&quot;&gt;Transform&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘 알아볼 것은 Transform 컴포넌트에 대한 것이다.&lt;/p&gt;

&lt;p&gt;Transform 컴포넌트는 씬에 존재하는 모든 오브젝트가 가지고 있는 컴포넌트이다. 이는 각각의 오브젝트의 위치, 회전, 크기를 저장해두고 다루기 위해 사용한다.&lt;/p&gt;

&lt;p&gt;또한 Transform 컴포넌트는 계층적으로 위치, 회전 스케일을 적용할 수 있는 부모 Transform을 가질 수 있는데, 이를 이해하기 위해 계층에 대한 내용을 먼저 알아보겠다.&lt;/p&gt;

&lt;p&gt;유니티의 Hierarchy Window 가 직역하면 계층 창이다. 유니티에서는 상속과 비슷하게 Parenting이라는 개념을 사용할 수 있는데, 특정 게임오브젝트를 다른 오브젝트의 자식으로 둘 수 있는 개념을 말한다. 이 때, 자식 오브젝트는 부모의 이동, 회전을 계승한다.&lt;/p&gt;

&lt;p&gt;여기서 이동, 회전을 계승한다는 의미가 앞서 설명한 Transform의 계층적으로 부모 Transform을 가지는 것을 말한다. 이 말은 자식 오브젝트의 Transform이 부모오브젝트의 Transform에 종속된다는 뜻이다. 실제 화면으로 한 번 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기 Plane의 자식 오브젝트인 Cube가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_02.gif&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 화면처럼, 부모 오브젝트 Plane의 위치를 움직이면 그 자식 오브젝트인 cube는 부모오브젝트가 이동하는 만큼 함께 이동한다. 부모 오브젝트의 Scale를 변경하면 자식 오브젝트의 Scale도 부모의 변동 폭에 맞춰서 같은 비율로 변경될 것이다.&lt;/p&gt;

&lt;p&gt;이것을 응용하는 간단한 사례중 하나는 플레이어를 따라다니는 카메라이다. 이것도 한 번 구현해보자. 아주 간단하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_03.gif&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;적당한 바닥에 움직이는 큐브를 구현해두었다. 카메라가 Cube와 독립적으로 존재할 때는 Cube가 움직인다고 해도 카메라는 요지부동이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 카메라를 큐브에 드래그&amp;amp;드롭 하여 Cube의 자식으로 만든다. 이렇게 하면 카메라의 Transform의 좌표가 Cube를 기준으로 변경되는데 해당하는 좌표를 적당히 Cube의 중앙에 오게끔 해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_07_05.gif&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 후 테스트를 한 장면이다. 큐브가 움직임에 따라 메인 카메라가 큐브와 같은 방향으로 이동하는 모습이다.&lt;/p&gt;

&lt;p&gt;Transform은 또한 enumerator를 지원하기 때문에 foreach문에 적용이 가능하다고 한다.&lt;/p&gt;

&lt;p&gt;Transform의 변수 중 forward는 3D기준 파란색 축, z축을 나타내고, right는 x축, up은 y축을 나타낸다. position 변수는 vector3으로 선언되어 있으며 Transform의 현재 위치를 나낸다.&lt;/p&gt;

&lt;p&gt;Transform 컴포넌트의 변수, 메서드는 API 문서 링크에 설명이 잘 되어 있으니 한 번쯤 찾아보면 좋을 것 같다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">Retr0의 교재를 따르는 실습은 저작권상 앞으로는 짤막하게 한 줄씩만 적도록 하겠다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티_초급학습_07</title>
      <link href="https://hjs101.github.io/Unity-07" rel="alternate" type="text/html" title="유니티_초급학습_07" />
      <published>2022-03-05T09:00:00+09:00</published>
      <updated>2022-03-05T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-07</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-07">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘은 이전 챕터에 이어서 클래스를 조금 더 만져보겠다.&lt;/p&gt;

&lt;h3 id=&quot;기본형과-참조형&quot;&gt;기본형과 참조형&lt;/h3&gt;

&lt;p&gt;변수의 타입은 기본형과 참조형으로 구분할 수 있다. 자바에서는 이를 Primitive Type과 References Type으로 나누는데, C#에서 명칭이 조금 다른 듯 하다. C#에서는 기본형을 Primitive Type이 아닌 Value 타입이라 부른다.&lt;/p&gt;

&lt;p&gt;기본형 : 변수에 주소가 아닌 값을 할당하는 타입, int, bool, float … 등의 기본형이 있다.&lt;/p&gt;

&lt;p&gt;※ 자바와 C#의 차이점&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;자바는 String 타입 변수가 참조형이지만 C#은 string 타입으로 기본형이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C#에서는 C에서 사용하던 struct, 구조체라는 것이 있는데, 이 구조체 타입의 변수는 기본형에 해당한다.
  ex) Vector3, Vector2, Color …&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참조형 : 변수에 할당하는 것이 주소값으로, 해당 주소를 통해서 메모리의 객체에 접근하는 변수. 자바와 의미가 같으며, 유니티에서 사용하는 모든 컴포넌트, 스크립트는 참조형에 해당한다.&lt;/p&gt;

&lt;p&gt;자 그럼, 이제 이 참조형 변수를 통해 오브젝트를 제어해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 오브젝트 큐브를 하나 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 후, RigidBody 컴포넌트를 큐브에 추가한다. 예전에, RigidBody는 오브젝트를 물리제어로 동작하게 하는 컴포넌트라고 설명했었다. 이 RigidBody 컴포넌트를 변수로 읽어와 코드를 통해 작동하게 해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 C# 스크립트를 하나 생성했다. 스크립트의 이름은 Jumper로 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Jumper : MonoBehaviour
{
    // RigidBody 타입의 변수 선언
    public Rigidbody myRigidbody;

    void Start()
    {
      // RigidBody 타입의 메서드 AddForce 지정한 방향(x,y,z)으로 입력한 값만큼 힘을 부여한다.
        myRigidbody.AddForce(0, 500, 0);
    }

    // Update is called once per frame
    void Update()
    {

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jumper 스크립트에는 다음과 같이 적는다. 코드의 내용은 주석을 참고하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제, 큐브 오브젝트에 Jumper 스크립트를 컴포넌트로 추가한다. 위 사진처럼 검색해서 추가해도 되고, 그냥 스크립트 파일을 드래그해서 놓아도 된다.&lt;/p&gt;

&lt;p&gt;이제 Zoo C# 스크립트 파일을 새로 하나 더 생성하겠다. 해당 스크립트에서 Animal 클래스를 이용해 동물 인스턴스를 생성해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 컴포넌트의 상태이다. Public으로 변수를 선언해두었기 때문에 Inspector Window에 할당 할 수 있게 칸이 생겼다. 현재 상태는 내용물 없이 그릇만 준비되어있는 상태라고 생각하면 된다. 이제 아무것도 가리키고 있지 않은 이 참조형 변수 myRigidbody에 Rigidbody를 할당해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Inspector Window에서, RigidBody 컴포넌트를 드래그해서 사진의 위치에 드롭한다. 이 상태가 변수에 컴포넌트의 주소가 할당되어 실제 cube Object의 RigidBody 컴포넌트와 연결된 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_07.gif&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행시켜보면 다음과 같이 큐브가 위로 한 번 튀어오르는 것을 볼 수 있다. 위 과정을 글로 써보면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Jumper 스크립트의 Start() 메서드 실행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;myRigidbody.AddForce(0,500,0)이 실행.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 과정에서, 2번은 myRigidbody 변수에 연결된 컴포넌트에 있는 메서드를 실행하는 것이다. Jumper 스크립트에서 해당 메서드를 수행하는 것이 아닌, myRigidbody에 연결된 컴포넌트에서 수행한다는 점을 기억하자.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 클래스를 조금 더 다루어보았다. 기본형과 참조형의 차이, 참조형 변수는 주소를 가지고 있다는 것을 기억해두자.&lt;/p&gt;

&lt;p&gt;출판사에 보냈던 메일에 대한 답변으로 책 내용의 30% 이상은 포스팅하면 안된다는 의견을 받아, 교재 내용을 통해 포스팅하는 것은 이 글이 마지막이다. 퍼센트로 따지면 이 글까지 범위가 25%쯤 된다. 뒷내용은 게임을 제작하는 부분이므로. 앞으로 교재를 통해서 실습을 진행하겠지만, 해당 내용은 포스팅 되지 않을 것이다. 다음부터는 다른 내용의 실습으로 포스팅을 하겠다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티_초급학습_06</title>
      <link href="https://hjs101.github.io/Unity-06" rel="alternate" type="text/html" title="유니티_초급학습_06" />
      <published>2022-03-04T09:00:00+09:00</published>
      <updated>2022-03-04T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-06</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-06">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번에는 매우 중요한 개념인 객체지향에 대해서 간단하게 알아보겠다. 언어만 다를 뿐, 자바에서의 객체지향과 의미는 같아보인다. (개념에 대한 설명은 교재에 나와있지 않은 내용이니 참고해주세요.)&lt;/p&gt;

&lt;h3 id=&quot;객체&quot;&gt;객체&lt;/h3&gt;

&lt;p&gt;객체 : 개발자의 관점에서 객체는, 우리 주변에 있는 모든 것으로, 프로그래밍의 대상이 될 수 있는 모든 것을 객체로 정의한다. 이는 사물, 개념, 논리가 될 수도 있다.&lt;/p&gt;

&lt;p&gt;객체지향 프로그래밍은 다음을 의미한다. 주변의 많은 객체화 할 수 있는 대상을 객체화 시켜 프로그래밍 하는 것이다. 프로그램 밖에 있는 것들을 프로그램 안으로 끌어들이는 것이라고 생각한다.&lt;/p&gt;

&lt;p&gt;###클래스와 인스턴스&lt;/p&gt;

&lt;p&gt;클래스 : 클래스는 객체를 정의해 놓은 것이다. 즉 객체를 생성하기 위한 설계도이다. 흔히들 붕어빵 틀에 비유하곤 한다. 붕어빵 틀은 붕어빵을 찍어내기 위한 틀이고, 틀을 이용해서 붕어빵을 만들 수 있다. 여기서 틀에 해당하는 것이 클래스, 붕어빵에 해당하는 것이 인스턴스이다.&lt;/p&gt;

&lt;p&gt;인스턴스 : 위에서 말했듯, 클래스를 통해 데이터 타입으로 생성되어 메모리에 적재된 것을 인스턴스라고 한다. 교재에서 새롭게 알게 된 사실로, 오브젝트가 인스턴스를 포함하는 개념이기 때문에, 같은 의미로 혼용하기도 한다고 한다.&lt;/p&gt;

&lt;p&gt;추가적으로 멤버변수와 지역변수의 차이까지만 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;변수&quot;&gt;변수&lt;/h2&gt;

&lt;p&gt;멤버변수 : 클래스 내부에서 선언되는 변수이다. 해당 클래스에 있는 생성자, 메서드에서 사용가능하다. 멤버변수는 또 2가지로 나눌 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;static 변수 : Class 변수이다. class가 로딩 시에 자동으로 메모리에 적재된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;non-static 변수 : Instance 변수, 필요시에 new 클래스이름()으로 인스턴스를 생성할 때 같이 메모리에 적재된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞서 클래스와 인스턴스를 구분해서 설명한 것과 이어서 생각해보자. static과 non-static의 차이에 대해 느낌이 좀 올 것이다.&lt;/p&gt;

&lt;p&gt;이 이외에도 추상화, 상속, 다형성, 캡슐화 등 설명하지 못한 많은 내용이 남아있지만 유니티로 넘어가기 위해 일단 여기까지만 설명하고 넘어가도록 하겠다.&lt;/p&gt;

&lt;h2 id=&quot;c-클래스&quot;&gt;C# 클래스&lt;/h2&gt;

&lt;p&gt;이제 유니티에서 클래스와 오브젝트에 대한 예제를 풀어 실습해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 프로젝트를 하나 생성했다. 프로젝트 이름은 Hello Class로 지었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티의 project window에 오른쪽 클릭을 하고 Create -&amp;gt; C# Script를 하나 생성했다. 이름은 Animal로 지었다. 이제 이 스크립트를 수정해보겠다. 교재에서 주어진 요구사항은 Animal 클래스는 멤버변수로 이름과 울음소리를 가지며, 울음소리를 재생하는 메서드 PlaySound를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요구사항대로 수정한 Animal 클래스이다. 변수와 메서드의 접근제한자는 public으로 두었다. 앞서 설명했듯 이것은 객체를 생성하기 위한 틀이기 때문에 이 자체로는 아무런 일도 일어나지 않는다. 기왕 실습하는 거 생성자까지 만들어보았다. 생성자는 객체가 생성될 때 초기화 해야할 변수, 또는 수행해야되는 로직이 있다면 객체가 생성되면서 수행할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 Zoo C# 스크립트 파일을 새로 하나 더 생성하겠다. 해당 스크립트에서 Animal 클래스를 이용해 동물 인스턴스를 생성해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로생성한 Zoo 스크립트 파일을 수정해서 gaji라는 동물을 하나 생성해보겠다. 가지는 친구집 고양이 이름이다 ^^&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성자 규칙대로 객체를 하나 생성했다. 잘 동작하는지 테스트해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트에 빈 오브젝트를 하나 생성해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_08.jpg&quot; alt=&quot;Unity_08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 후, Zoo 스크립트를 컴포넌트로 빈 오브젝트에 추가해주었다. 이제 실행 버튼을 눌러 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_09.jpg&quot; alt=&quot;Unity_09&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zoo에서 Animal 클래스를 이용해 Animal타입 gaji 라는 변수명의 객체를 생성하였고, 설정한 변수명이 제대로 입력되어있는 것과, PlaySound 기능이 잘 동작하는 것을 확인 할 수있다.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 클래스를 만들어 테스트해보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_초급학습_05</title>
      <link href="https://hjs101.github.io/Unity-05" rel="alternate" type="text/html" title="Unity_초급학습_05" />
      <published>2022-03-03T09:00:00+09:00</published>
      <updated>2022-03-03T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-05</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-05">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번에는 C#에 대해 알아보겠다. C#은 이전에 다뤄본적도 있고, 비슷한 객체지향 언어인 자바를 공부했기 때문에, 언어 자체보다는 유니티와 연동하는 부분에 초점을 맞추도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티의 project window에 오른쪽 클릭을 하고 Create -&amp;gt; C# Script를 하나 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파일이 한 개 생성되었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티에서 기본적으로 C# 스크립트 파일을 생성하면 화면과 같은 기본 코드가 제공된다. 네임스페이스로 UnityEngine이 추가되어있고, 클래스는 MonoBehaviour를 상속받고있다.&lt;/p&gt;

&lt;p&gt;start 메서드는 코드 실행이 시작되는 시작점을 제공한다. 앞 번에 설명했던 유니티 이벤트 메서드에 해당하는 메서드이다. 게임이 시작될 때 자동으로 한 번 수행되는 메서드이다. 게임 시작과 동시에 수행해야할 코드가 들어가면 된다.&lt;/p&gt;

&lt;p&gt;update메서드는 1프레임 마다 한 번씩 수행되는 메서드이다. 실시간으로 계속해서 수행되어야할 코드가 있을 때 사용한다. 프레임 단위로 작동하기 때문에 프레임 상태에 따라서 호출이 불규칙하다.&lt;/p&gt;

&lt;p&gt;※ FixedUpdate 와 update 의 차이 : update는 프레임을 기반으로 호출되는 메서드이고, FixedUpdate는 자체적인 Timestep에 설정된 값에 따라서 일정한 간격으로 호출된다. update의 주 사용처는 물리효과(RigidBody)가 적용되지 않는 오브젝트의 움직임, 키 입력 등에 사용된다. FixedUpdate는 물리효과가 적용된 오브젝트를 조정할 때 사용된다. 물리효과 적용된 오브젝트를 update로 조정할 경우에는 물리엔진 충돌검사 등이 제대로 이루어지지 않을 수 있다.&lt;/p&gt;

&lt;p&gt;Debug 기능에 대해서 조금 실습해보자. 복잡한 코드가 아니기 때문에 소스코드는 첨부하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 변수, 정수형 변수를 선언하고 각각 Debug.log 메서드로 출력하는 코드를 작성했다.&lt;/p&gt;

&lt;p&gt;유니티에서 스크립트는 독립적으로 수행될 수 없다. 스크립트를 동작시키고 싶다면, 게임에 존재하는 오브젝트로 만들어야 한다. 그 방법은 컴포넌트로 빈 껍데기인 게임 오브젝트에 추가하는 것. 기존 예제의 큐브에 작성한 스크립트를 컴포넌트로 추가해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;큐브 오브젝트를 Hierarchy Window에서 선택한다. Inspector Window의 Add Component를 누르고 검색 창에 Hello를 치니 작성한 스크립트명 HelloUnity가 보인다. 컴포넌트를 추가해주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;재생버튼을 누르자 Console Window에 위와 같이 3개의 메시지가 나타난다. Debug를 통해 콘솔창에 정보를 출력할 수 있다는 점, 변수를 찍어볼 수 있다는 점은, 개발할 때 문제 파악에 많은 도움이 될 것이다.&lt;/p&gt;

&lt;p&gt;다음은 메서드 사용법인데, 교재의 예제를 구현하도록 하겠다. 두 점 사이의 거리를 구하는 메서드이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CSharp&quot;&gt;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class getDistanceTest : MonoBehaviour
{
    void Start()
    {
        Debug.Log(GetDistance(0, 3, 0, 4));
    }

    // 피타고라스 정리 이용 두 점 사이의 거리 구하기
    float GetDistance(float x1, float x2, float y1, float y2)
    {
        float width = x2 - x1;
        float height = y2 - y1;

        return Mathf.Sqrt(width * width + height * height);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;스크립트 전체 코드이다. 자바와 다른점은 메서드의 첫 글자를 대문자로 쓰는 것 정도? 세세한 부분이 약간씩 다르기는 하지만 C와 비슷한 면도 있어서 어느정도 익숙하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(0,0)과 (3,4)의 거리를 구하니 5가 출력된 모습이다. 역시 게임오브젝트에 컴포넌트로 추가하여 실행시켰다. 게임을 실행시켜 테스트를 마친 후에는 꼭! 다시 플레이 버튼을 눌러 모드를 해제시켜주자. 플레이 모드에서 오브젝트가 변경된 사항은 플레이 모드를 해제하면 원래대로 돌아간다. 플레이 모드로 작업하다가 취소하고 작업물을 전부 날려먹는 안타까운 일이 없길 바란다.&lt;/p&gt;

&lt;p&gt;if문, for, while문, 배열 등은 자바와 거의 같은 내용이기 때문에 넘어가겠다.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 C# 스크립트를 사용하는 방법에 대해서 알아보았고, 기본적인 C# 예제를 테스트해보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_초급학습_04</title>
      <link href="https://hjs101.github.io/Unity-04" rel="alternate" type="text/html" title="Unity_초급학습_04" />
      <published>2022-03-02T09:00:00+09:00</published>
      <updated>2022-03-02T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-04</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-04">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번에는 유니티 엔진에서 상당히 중요한 개념으로 생각되는 컴포넌트에 대해서 알아볼 것이다.&lt;/p&gt;

&lt;p&gt;SSAFY 과정에서 자바를 배우고 객체지향에 대한 이해도가 생겨, 상속의 의미와 장점에 대해서는 어느 정도 체득하였다고 생각한다. 하지만 유니티에서는 상속 관계도 물론 사용하지만 컴포넌트 패턴이라는 것을 사용하여 게임 오브젝트를 만들어낸다.&lt;/p&gt;

&lt;p&gt;컴포넌트 패턴이란, 미리 만들어져있는 부품을 조립하여 완성된 오브젝트를 만드는 방식이다. 이 패턴에서 미리 만들어진, 조립에 이용되는 부품을 컴포넌트라고 부른다. 며칠 전 실습했던 큐브에 RigidBody 컴포넌트를 추가했다. 이것은 큐브라는 GameObject에 RigidBody라는 부품을 부착시켜 해당 오브젝트에 물리 개념을 부여했다.&lt;/p&gt;

&lt;p&gt;이렇듯 유니티에서는 게임 오브젝트를 생성할 때 많은 양의 준비된 컴포넌트들 중에서 내게 필요한 기능을 찾아 해당 오브젝트에 추가하는 방식으로 원하는 오브젝트를 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;컴포넌트를 이용하는 것에는 이러한 장점이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;유연한 재상용이 가능하다. : 상속만을 사용했을 때는 부모 클래스의 불필요한 기능까지 모두 상속받기 때문에 코드의 재사용이 힘들 수 있다. 컴포넌트 패턴을 이용하면 원하는 기능을 가진 컴포넌트만 선택적으로 골라서 사용할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기획자의 프로그래머 의존도가 낮아진다. : 기획자는 미리 만들어진 컴포넌트를 조립하여 게임 오브젝트를 만들 수 있다. 코드를 짜지 않고 객체를 생성할 수 있는 것이다. 이러한 기능들은 기획자의 프로그래머 의존도를 많이 낮춰주는 효과를 가진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴포넌트의 특징인 독립성 덕분의 기능의 추가와 삭제가 용이하다. : 우리가 코드를 짜고, 또 수정할 때 일부의 코드만 변경해도 전체를 수정해야하는 상황이 생길때가 꽤 있다. 하지만 컴포넌트 패턴에서는 어떤 기능을 부착하고 제거할 때 다른 기능을 건드리지 않기 때문에 일부를 수정한다고 전체를 갈아엎어야 하는 일이 많이 줄어든다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음은 컴포넌트가 가진 독립성에 대한 이야기이다.&lt;/p&gt;

&lt;p&gt;컴포넌트 패턴의 장점은 이 2가지 특징에서부터 나온다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;게임 오브젝트는 단순한 껍데기이다. 게임 오브젝트는 그 자체로는 특별한 기능이 없는 껍데기라는 것이다. 이러한 껍데기에 컴포넌트들이 부착되면서 하나의 객체가 완성되는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴포넌트는 각자의 기능이 자신 내부에 완성되어있기 때문에, 다른 컴포넌트에 영향을 주지 않고 독립적으로 작용한다. 따라서 게임 오브젝트에 어떤 컴포넌트를 추가하거나 제거한다고 해도 다른 컴포넌트에는 피해가 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그렇다면 앞선 포스팅에서 만들었던, HelloUnity 프로젝트의 큐브를 다시 한 번 살펴보도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_03_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HelloUnity 프로젝트의 큐브의 인스펙터 창이다. 큐브를 생성하기만 했는 데도, 새로 추가한 RigidBody를 제외해도 많은 컴포넌트들이 기본적으로 추가되어있다. 각 컴포넌트들의 기능은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Transform : 게임 오브젝트의 위치, 크기, 회전상태를 지정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mesh Filter : 오브젝트의 외곽선을 지정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mesh Renderer : Mesh를 따라 색을 채워넣어 그래픽 외형을 그린다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Box Collider : 충돌판정과 관련된 컴포넌트로, 물리적인 표면을 만들어 다른 물체와 부딛힐 수 있게 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RigidBody : 게임 오브젝트가 물리엔진의 제어를 받게 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;큐브라는 게임오브젝트 자체는 아무것도 가지고있는게 아니고, 컴포넌트들이 해당 오브젝트에 계속해서 추가되어 현재의 큐브의 기능을 수행하고 있다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;만약 여기서 Box Collider 컴포넌트를 제거한다면 어떻게 될까? 한 번 제거해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_03_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컴포넌트의 점 세 개가 세로로 나열된 버튼을 클릭하고 remove Component를 클릭한다.&lt;/p&gt;

&lt;p&gt;Box Collider이 사라져서 큐브는 물리적으로 충돌을 판정할 수 있는 표면이 사라졌다. 따라서 어떤 물체와도 충돌하지 않게 된다. 하지만, 그렇다고 RigidBody에서 설정한 중력이 사라지는 것은 아니기 때문에, 큐브는 바닥을 통과해 아래쪽으로 계속해서 떨어지게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_03_03.gif&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;충돌판정은 사라지고, RigidBody는 그대로 남아 저 아래로 떨어지는 큐브의 모습이다.&lt;/p&gt;

&lt;p&gt;다음은 유니티의 모든 컴포넌트가 상속받는 MonoBehaviour 클래스에 대해서 이야기하겠다.&lt;/p&gt;

&lt;p&gt;MonoBehaviour 클래스는 유니티에서 미리 만들어 제공하는 클래스이며, 컴포넌트에 필요한 기본 기능을 제공한다. 따라서, 유니티에서 게임 오브젝트에 컴포넌트로서 추가되기 위해서는 MonoBehaviour를 상속받아야만 한다.&lt;/p&gt;

&lt;p&gt;앞서 컴포넌트 패턴을 설명할 때 컴포넌트들은 각각 독립적으로 작용한다라고 설명했다. 같은 게임 오브젝트에 속한다고 해서 컴포넌트 끼리 정보를 공유하거나 서로의 정보를 가지고 있지 않다는 말이다. 마찬가지로, 유니티 엔진에서도 모든 게임오브젝트에 대한 컴포넌트 목록을 가지고 있지 않다.&lt;/p&gt;

&lt;p&gt;따라서, 유니티는 특정 컴포넌트의 특정 기능을 실행시키고 싶을 때, 해당 컴포넌트로 접근하는 것이 아닌 메시지를 브로드캐스팅 방식으로 날려보내는 방식을 사용한다.&lt;/p&gt;

&lt;p&gt;네트워크를 접해본 사람이 있다면 익숙한 용어일 것이다. 의미는 비슷하다. 브로드캐스트는 보내는 쪽에서는 연결되어있는 모든 단말에 메시지를 보내고, 받는 쪽에서는 송신자 확인을 하지 않는다. 만약 해당하는 메시지가 단말에 맞는 메시지라면, 해당 단말은 메시지를 읽어들여 해당하는 기능을 수행한다.&lt;/p&gt;

&lt;p&gt;예를 들면, 유니티의 게임 오브젝트에 Start() 메서드라는 게 있다. 해당 메서드의 코드는 해당하는 게임 오브젝트가 최초로 활성화 되는 때에 자동으로 한 번 실행된다. 개인적으로는 생성자와 비슷한 느낌이라고 생각한다. 그렇다면 어떻게 게임 오브젝트가 활성화될 때 start라는 메서드가 자동으로 실행되는 것일까.&lt;/p&gt;

&lt;p&gt;유니티에서는 게임 오브젝트가 활성화 되면 그 게임 오브젝트에 start라는 메시지를 보낸다. 그러면 게임오브젝트의 컴포넌트에서 start 메서드가 있는 경우에는 수행, 그게 아니라면 무시하는 방식으로 start 메서드를 자동으로 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;유니티에는 위와 같이 이름과 철자만 똑같이 만들어두면 브로드캐스팅되는 메시지에 의해서 자동으로 실행되는 메서드들이 있다. 이러한 메서드를 유니티 이벤트 메서드라고한다.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 사용하는 컴포넌트에 대한 개념과 메시지 - 브로드캐스팅으로 이루어지는 컴포넌트의 기능 실행에 대해 알아보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
</feed>
