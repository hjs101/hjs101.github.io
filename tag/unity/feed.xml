<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hjs101.github.io/tag/unity/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hjs101.github.io/" rel="alternate" type="text/html" />
  <updated>2022-03-06T04:01:39+09:00</updated>
  <id>https://hjs101.github.io/tag/unity/feed.xml</id>

  
  
  

  
    <title type="html">hjs’s Blog | </title>
  

  
    <subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">유니티_초급학습_07</title>
      <link href="https://hjs101.github.io/Unity-07" rel="alternate" type="text/html" title="유니티_초급학습_07" />
      <published>2022-03-05T09:00:00+09:00</published>
      <updated>2022-03-05T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-07</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-07">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘은 이전 챕터에 이어서 클래스를 조금 더 만져보겠다.&lt;/p&gt;

&lt;h3 id=&quot;기본형과-참조형&quot;&gt;기본형과 참조형&lt;/h3&gt;

&lt;p&gt;변수의 타입은 기본형과 참조형으로 구분할 수 있다. 자바에서는 이를 Primitive Type과 References Type으로 나누는데, C#에서 명칭이 조금 다른 듯 하다. C#에서는 기본형을 Primitive Type이 아닌 Value 타입이라 부른다.&lt;/p&gt;

&lt;p&gt;기본형 : 변수에 주소가 아닌 값을 할당하는 타입, int, bool, float … 등의 기본형이 있다.&lt;/p&gt;

&lt;p&gt;※ 자바와 C#의 차이점&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;자바는 String 타입 변수가 참조형이지만 C#은 string 타입으로 기본형이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C#에서는 C에서 사용하던 struct, 구조체라는 것이 있는데, 이 구조체 타입의 변수는 기본형에 해당한다.
  ex) Vector3, Vector2, Color …&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;참조형 : 변수에 할당하는 것이 주소값으로, 해당 주소를 통해서 메모리의 객체에 접근하는 변수. 자바와 의미가 같으며, 유니티에서 사용하는 모든 컴포넌트, 스크립트는 참조형에 해당한다.&lt;/p&gt;

&lt;p&gt;자 그럼, 이제 이 참조형 변수를 통해 오브젝트를 제어해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 오브젝트 큐브를 하나 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 후, RigidBody 컴포넌트를 큐브에 추가한다. 예전에, RigidBody는 오브젝트를 물리제어로 동작하게 하는 컴포넌트라고 설명했었다. 이 RigidBody 컴포넌트를 변수로 읽어와 코드를 통해 작동하게 해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 C# 스크립트를 하나 생성했다. 스크립트의 이름은 Jumper로 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Csharp&quot;&gt;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Jumper : MonoBehaviour
{
    // RigidBody 타입의 변수 선언
    public Rigidbody myRigidbody;

    void Start()
    {
      // RigidBody 타입의 메서드 AddForce 지정한 방향(x,y,z)으로 입력한 값만큼 힘을 부여한다.
        myRigidbody.AddForce(0, 500, 0);
    }

    // Update is called once per frame
    void Update()
    {

    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jumper 스크립트에는 다음과 같이 적는다. 코드의 내용은 주석을 참고하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제, 큐브 오브젝트에 Jumper 스크립트를 컴포넌트로 추가한다. 위 사진처럼 검색해서 추가해도 되고, 그냥 스크립트 파일을 드래그해서 놓아도 된다.&lt;/p&gt;

&lt;p&gt;이제 Zoo C# 스크립트 파일을 새로 하나 더 생성하겠다. 해당 스크립트에서 Animal 클래스를 이용해 동물 인스턴스를 생성해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;현재 컴포넌트의 상태이다. Public으로 변수를 선언해두었기 때문에 Inspector Window에 할당 할 수 있게 칸이 생겼다. 현재 상태는 내용물 없이 그릇만 준비되어있는 상태라고 생각하면 된다. 이제 아무것도 가리키고 있지 않은 이 참조형 변수 myRigidbody에 Rigidbody를 할당해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Inspector Window에서, RigidBody 컴포넌트를 드래그해서 사진의 위치에 드롭한다. 이 상태가 변수에 컴포넌트의 주소가 할당되어 실제 cube Object의 RigidBody 컴포넌트와 연결된 상태이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_06_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행시켜보면 다음과 같이 큐브가 위로 한 번 튀어오르는 것을 볼 수 있다. 위 과정을 글로 써보면 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Jumper 스크립트의 Start() 메서드 실행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;myRigidbody.AddForce(0,500,0)이 실행.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 과정에서, 2번은 myRigidbody 변수에 연결된 컴포넌트에 있는 메서드를 실행하는 것이다. Jumper 스크립트에서 해당 메서드를 수행하는 것이 아닌, myRigidbody에 연결된 컴포넌트에서 수행한다는 점을 기억하자.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 클래스를 조금 더 다루어보았다. 기본형과 참조형의 차이, 참조형 변수는 주소를 가지고 있다는 것을 기억해두자.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">유니티_초급학습_06</title>
      <link href="https://hjs101.github.io/Unity-06" rel="alternate" type="text/html" title="유니티_초급학습_06" />
      <published>2022-03-04T09:00:00+09:00</published>
      <updated>2022-03-04T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-06</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-06">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번에는 매우 중요한 개념인 객체지향에 대해서 간단하게 알아보겠다. 언어만 다를 뿐, 자바에서의 객체지향과 의미는 같아보인다. (개념에 대한 설명은 교재에 나와있지 않은 내용이니 참고해주세요.)&lt;/p&gt;

&lt;h3 id=&quot;객체&quot;&gt;객체&lt;/h3&gt;

&lt;p&gt;객체 : 개발자의 관점에서 객체는, 우리 주변에 있는 모든 것으로, 프로그래밍의 대상이 될 수 있는 모든 것을 객체로 정의한다. 이는 사물, 개념, 논리가 될 수도 있다.&lt;/p&gt;

&lt;p&gt;객체지향 프로그래밍은 다음을 의미한다. 주변의 많은 객체화 할 수 있는 대상을 객체화 시켜 프로그래밍 하는 것이다. 프로그램 밖에 있는 것들을 프로그램 안으로 끌어들이는 것이라고 생각한다.&lt;/p&gt;

&lt;p&gt;###클래스와 인스턴스&lt;/p&gt;

&lt;p&gt;클래스 : 클래스는 객체를 정의해 놓은 것이다. 즉 객체를 생성하기 위한 설계도이다. 흔히들 붕어빵 틀에 비유하곤 한다. 붕어빵 틀은 붕어빵을 찍어내기 위한 틀이고, 틀을 이용해서 붕어빵을 만들 수 있다. 여기서 틀에 해당하는 것이 클래스, 붕어빵에 해당하는 것이 인스턴스이다.&lt;/p&gt;

&lt;p&gt;인스턴스 : 위에서 말했듯, 클래스를 통해 데이터 타입으로 생성되어 메모리에 적재된 것을 인스턴스라고 한다. 교재에서 새롭게 알게 된 사실로, 오브젝트가 인스턴스를 포함하는 개념이기 때문에, 같은 의미로 혼용하기도 한다고 한다.&lt;/p&gt;

&lt;p&gt;추가적으로 멤버변수와 지역변수의 차이까지만 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;변수&quot;&gt;변수&lt;/h2&gt;

&lt;p&gt;멤버변수 : 클래스 내부에서 선언되는 변수이다. 해당 클래스에 있는 생성자, 메서드에서 사용가능하다. 멤버변수는 또 2가지로 나눌 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;static 변수 : Class 변수이다. class가 로딩 시에 자동으로 메모리에 적재된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;non-static 변수 : Instance 변수, 필요시에 new 클래스이름()으로 인스턴스를 생성할 때 같이 메모리에 적재된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞서 클래스와 인스턴스를 구분해서 설명한 것과 이어서 생각해보자. static과 non-static의 차이에 대해 느낌이 좀 올 것이다.&lt;/p&gt;

&lt;p&gt;이 이외에도 추상화, 상속, 다형성, 캡슐화 등 설명하지 못한 많은 내용이 남아있지만 유니티로 넘어가기 위해 일단 여기까지만 설명하고 넘어가도록 하겠다.&lt;/p&gt;

&lt;h2 id=&quot;c-클래스&quot;&gt;C# 클래스&lt;/h2&gt;

&lt;p&gt;이제 유니티에서 클래스와 오브젝트에 대한 예제를 풀어 실습해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 프로젝트를 하나 생성했다. 프로젝트 이름은 Hello Class로 지었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티의 project window에 오른쪽 클릭을 하고 Create -&amp;gt; C# Script를 하나 생성했다. 이름은 Animal로 지었다. 이제 이 스크립트를 수정해보겠다. 교재에서 주어진 요구사항은 Animal 클래스는 멤버변수로 이름과 울음소리를 가지며, 울음소리를 재생하는 메서드 PlaySound를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;요구사항대로 수정한 Animal 클래스이다. 변수와 메서드의 접근제한자는 public으로 두었다. 앞서 설명했듯 이것은 객체를 생성하기 위한 틀이기 때문에 이 자체로는 아무런 일도 일어나지 않는다. 기왕 실습하는 거 생성자까지 만들어보았다. 생성자는 객체가 생성될 때 초기화 해야할 변수, 또는 수행해야되는 로직이 있다면 객체가 생성되면서 수행할 수 있게 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 Zoo C# 스크립트 파일을 새로 하나 더 생성하겠다. 해당 스크립트에서 Animal 클래스를 이용해 동물 인스턴스를 생성해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로생성한 Zoo 스크립트 파일을 수정해서 gaji라는 동물을 하나 생성해보겠다. 가지는 친구집 고양이 이름이다 ^^&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;생성자 규칙대로 객체를 하나 생성했다. 잘 동작하는지 테스트해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로젝트에 빈 오브젝트를 하나 생성해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_08.jpg&quot; alt=&quot;Unity_08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 후, Zoo 스크립트를 컴포넌트로 빈 오브젝트에 추가해주었다. 이제 실행 버튼을 눌러 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_05_09.jpg&quot; alt=&quot;Unity_09&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zoo에서 Animal 클래스를 이용해 Animal타입 gaji 라는 변수명의 객체를 생성하였고, 설정한 변수명이 제대로 입력되어있는 것과, PlaySound 기능이 잘 동작하는 것을 확인 할 수있다.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 클래스를 만들어 테스트해보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_초급학습_05</title>
      <link href="https://hjs101.github.io/Unity-05" rel="alternate" type="text/html" title="Unity_초급학습_05" />
      <published>2022-03-03T09:00:00+09:00</published>
      <updated>2022-03-03T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-05</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-05">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번에는 C#에 대해 알아보겠다. C#은 이전에 다뤄본적도 있고, 비슷한 객체지향 언어인 자바를 공부했기 때문에, 언어 자체보다는 유니티와 연동하는 부분에 초점을 맞추도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티의 project window에 오른쪽 클릭을 하고 Create -&amp;gt; C# Script를 하나 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파일이 한 개 생성되었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티에서 기본적으로 C# 스크립트 파일을 생성하면 화면과 같은 기본 코드가 제공된다. 네임스페이스로 UnityEngine이 추가되어있고, 클래스는 MonoBehaviour를 상속받고있다.&lt;/p&gt;

&lt;p&gt;start 메서드는 코드 실행이 시작되는 시작점을 제공한다. 앞 번에 설명했던 유니티 이벤트 메서드에 해당하는 메서드이다. 게임이 시작될 때 자동으로 한 번 수행되는 메서드이다. 게임 시작과 동시에 수행해야할 코드가 들어가면 된다.&lt;/p&gt;

&lt;p&gt;update메서드는 1프레임 마다 한 번씩 수행되는 메서드이다. 실시간으로 계속해서 수행되어야할 코드가 있을 때 사용한다. 프레임 단위로 작동하기 때문에 프레임 상태에 따라서 호출이 불규칙하다.&lt;/p&gt;

&lt;p&gt;※ FixedUpdate 와 update 의 차이 : update는 프레임을 기반으로 호출되는 메서드이고, FixedUpdate는 자체적인 Timestep에 설정된 값에 따라서 일정한 간격으로 호출된다. update의 주 사용처는 물리효과(RigidBody)가 적용되지 않는 오브젝트의 움직임, 키 입력 등에 사용된다. FixedUpdate는 물리효과가 적용된 오브젝트를 조정할 때 사용된다. 물리효과 적용된 오브젝트를 update로 조정할 경우에는 물리엔진 충돌검사 등이 제대로 이루어지지 않을 수 있다.&lt;/p&gt;

&lt;p&gt;Debug 기능에 대해서 조금 실습해보자. 복잡한 코드가 아니기 때문에 소스코드는 첨부하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;문자열 변수, 정수형 변수를 선언하고 각각 Debug.log 메서드로 출력하는 코드를 작성했다.&lt;/p&gt;

&lt;p&gt;유니티에서 스크립트는 독립적으로 수행될 수 없다. 스크립트를 동작시키고 싶다면, 게임에 존재하는 오브젝트로 만들어야 한다. 그 방법은 컴포넌트로 빈 껍데기인 게임 오브젝트에 추가하는 것. 기존 예제의 큐브에 작성한 스크립트를 컴포넌트로 추가해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;큐브 오브젝트를 Hierarchy Window에서 선택한다. Inspector Window의 Add Component를 누르고 검색 창에 Hello를 치니 작성한 스크립트명 HelloUnity가 보인다. 컴포넌트를 추가해주었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;재생버튼을 누르자 Console Window에 위와 같이 3개의 메시지가 나타난다. Debug를 통해 콘솔창에 정보를 출력할 수 있다는 점, 변수를 찍어볼 수 있다는 점은, 개발할 때 문제 파악에 많은 도움이 될 것이다.&lt;/p&gt;

&lt;p&gt;다음은 메서드 사용법인데, 교재의 예제를 구현하도록 하겠다. 두 점 사이의 거리를 구하는 메서드이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CSharp&quot;&gt;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class getDistanceTest : MonoBehaviour
{
    void Start()
    {
        Debug.Log(GetDistance(0, 3, 0, 4));
    }

    // 피타고라스 정리 이용 두 점 사이의 거리 구하기
    float GetDistance(float x1, float x2, float y1, float y2)
    {
        float width = x2 - x1;
        float height = y2 - y1;

        return Mathf.Sqrt(width * width + height * height);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;스크립트 전체 코드이다. 자바와 다른점은 메서드의 첫 글자를 대문자로 쓰는 것 정도? 세세한 부분이 약간씩 다르기는 하지만 C와 비슷한 면도 있어서 어느정도 익숙하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_04_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(0,0)과 (3,4)의 거리를 구하니 5가 출력된 모습이다. 역시 게임오브젝트에 컴포넌트로 추가하여 실행시켰다. 게임을 실행시켜 테스트를 마친 후에는 꼭! 다시 플레이 버튼을 눌러 모드를 해제시켜주자. 플레이 모드에서 오브젝트가 변경된 사항은 플레이 모드를 해제하면 원래대로 돌아간다. 플레이 모드로 작업하다가 취소하고 작업물을 전부 날려먹는 안타까운 일이 없길 바란다.&lt;/p&gt;

&lt;p&gt;if문, for, while문, 배열 등은 자바와 거의 같은 내용이기 때문에 넘어가겠다.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 C# 스크립트를 사용하는 방법에 대해서 알아보았고, 기본적인 C# 예제를 테스트해보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_초급학습_04</title>
      <link href="https://hjs101.github.io/Unity-04" rel="alternate" type="text/html" title="Unity_초급학습_04" />
      <published>2022-03-02T09:00:00+09:00</published>
      <updated>2022-03-02T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-04</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-04">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이번에는 유니티 엔진에서 상당히 중요한 개념으로 생각되는 컴포넌트에 대해서 알아볼 것이다.&lt;/p&gt;

&lt;p&gt;SSAFY 과정에서 자바를 배우고 객체지향에 대한 이해도가 생겨, 상속의 의미와 장점에 대해서는 어느 정도 체득하였다고 생각한다. 하지만 유니티에서는 상속 관계도 물론 사용하지만 컴포넌트 패턴이라는 것을 사용하여 게임 오브젝트를 만들어낸다.&lt;/p&gt;

&lt;p&gt;컴포넌트 패턴이란, 미리 만들어져있는 부품을 조립하여 완성된 오브젝트를 만드는 방식이다. 이 패턴에서 미리 만들어진, 조립에 이용되는 부품을 컴포넌트라고 부른다. 며칠 전 실습했던 큐브에 RigidBody 컴포넌트를 추가했다. 이것은 큐브라는 GameObject에 RigidBody라는 부품을 부착시켜 해당 오브젝트에 물리 개념을 부여했다.&lt;/p&gt;

&lt;p&gt;이렇듯 유니티에서는 게임 오브젝트를 생성할 때 많은 양의 준비된 컴포넌트들 중에서 내게 필요한 기능을 찾아 해당 오브젝트에 추가하는 방식으로 원하는 오브젝트를 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;컴포넌트를 이용하는 것에는 이러한 장점이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;유연한 재상용이 가능하다. : 상속만을 사용했을 때는 부모 클래스의 불필요한 기능까지 모두 상속받기 때문에 코드의 재사용이 힘들 수 있다. 컴포넌트 패턴을 이용하면 원하는 기능을 가진 컴포넌트만 선택적으로 골라서 사용할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기획자의 프로그래머 의존도가 낮아진다. : 기획자는 미리 만들어진 컴포넌트를 조립하여 게임 오브젝트를 만들 수 있다. 코드를 짜지 않고 객체를 생성할 수 있는 것이다. 이러한 기능들은 기획자의 프로그래머 의존도를 많이 낮춰주는 효과를 가진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴포넌트의 특징인 독립성 덕분의 기능의 추가와 삭제가 용이하다. : 우리가 코드를 짜고, 또 수정할 때 일부의 코드만 변경해도 전체를 수정해야하는 상황이 생길때가 꽤 있다. 하지만 컴포넌트 패턴에서는 어떤 기능을 부착하고 제거할 때 다른 기능을 건드리지 않기 때문에 일부를 수정한다고 전체를 갈아엎어야 하는 일이 많이 줄어든다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;다음은 컴포넌트가 가진 독립성에 대한 이야기이다.&lt;/p&gt;

&lt;p&gt;컴포넌트 패턴의 장점은 이 2가지 특징에서부터 나온다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;게임 오브젝트는 단순한 껍데기이다. 게임 오브젝트는 그 자체로는 특별한 기능이 없는 껍데기라는 것이다. 이러한 껍데기에 컴포넌트들이 부착되면서 하나의 객체가 완성되는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴포넌트는 각자의 기능이 자신 내부에 완성되어있기 때문에, 다른 컴포넌트에 영향을 주지 않고 독립적으로 작용한다. 따라서 게임 오브젝트에 어떤 컴포넌트를 추가하거나 제거한다고 해도 다른 컴포넌트에는 피해가 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그렇다면 앞선 포스팅에서 만들었던, HelloUnity 프로젝트의 큐브를 다시 한 번 살펴보도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_03_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HelloUnity 프로젝트의 큐브의 인스펙터 창이다. 큐브를 생성하기만 했는 데도, 새로 추가한 RigidBody를 제외해도 많은 컴포넌트들이 기본적으로 추가되어있다. 각 컴포넌트들의 기능은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Transform : 게임 오브젝트의 위치, 크기, 회전상태를 지정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mesh Filter : 오브젝트의 외곽선을 지정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mesh Renderer : Mesh를 따라 색을 채워넣어 그래픽 외형을 그린다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Box Collider : 충돌판정과 관련된 컴포넌트로, 물리적인 표면을 만들어 다른 물체와 부딛힐 수 있게 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RigidBody : 게임 오브젝트가 물리엔진의 제어를 받게 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;큐브라는 게임오브젝트 자체는 아무것도 가지고있는게 아니고, 컴포넌트들이 해당 오브젝트에 계속해서 추가되어 현재의 큐브의 기능을 수행하고 있다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;만약 여기서 Box Collider 컴포넌트를 제거한다면 어떻게 될까? 한 번 제거해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_03_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컴포넌트의 점 세 개가 세로로 나열된 버튼을 클릭하고 remove Component를 클릭한다.&lt;/p&gt;

&lt;p&gt;Box Collider이 사라져서 큐브는 물리적으로 충돌을 판정할 수 있는 표면이 사라졌다. 따라서 어떤 물체와도 충돌하지 않게 된다. 하지만, 그렇다고 RigidBody에서 설정한 중력이 사라지는 것은 아니기 때문에, 큐브는 바닥을 통과해 아래쪽으로 계속해서 떨어지게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_03_03.gif&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;충돌판정은 사라지고, RigidBody는 그대로 남아 저 아래로 떨어지는 큐브의 모습이다.&lt;/p&gt;

&lt;p&gt;다음은 유니티의 모든 컴포넌트가 상속받는 MonoBehaviour 클래스에 대해서 이야기하겠다.&lt;/p&gt;

&lt;p&gt;MonoBehaviour 클래스는 유니티에서 미리 만들어 제공하는 클래스이며, 컴포넌트에 필요한 기본 기능을 제공한다. 따라서, 유니티에서 게임 오브젝트에 컴포넌트로서 추가되기 위해서는 MonoBehaviour를 상속받아야만 한다.&lt;/p&gt;

&lt;p&gt;앞서 컴포넌트 패턴을 설명할 때 컴포넌트들은 각각 독립적으로 작용한다라고 설명했다. 같은 게임 오브젝트에 속한다고 해서 컴포넌트 끼리 정보를 공유하거나 서로의 정보를 가지고 있지 않다는 말이다. 마찬가지로, 유니티 엔진에서도 모든 게임오브젝트에 대한 컴포넌트 목록을 가지고 있지 않다.&lt;/p&gt;

&lt;p&gt;따라서, 유니티는 특정 컴포넌트의 특정 기능을 실행시키고 싶을 때, 해당 컴포넌트로 접근하는 것이 아닌 메시지를 브로드캐스팅 방식으로 날려보내는 방식을 사용한다.&lt;/p&gt;

&lt;p&gt;네트워크를 접해본 사람이 있다면 익숙한 용어일 것이다. 의미는 비슷하다. 브로드캐스트는 보내는 쪽에서는 연결되어있는 모든 단말에 메시지를 보내고, 받는 쪽에서는 송신자 확인을 하지 않는다. 만약 해당하는 메시지가 단말에 맞는 메시지라면, 해당 단말은 메시지를 읽어들여 해당하는 기능을 수행한다.&lt;/p&gt;

&lt;p&gt;예를 들면, 유니티의 게임 오브젝트에 Start() 메서드라는 게 있다. 해당 메서드의 코드는 해당하는 게임 오브젝트가 최초로 활성화 되는 때에 자동으로 한 번 실행된다. 개인적으로는 생성자와 비슷한 느낌이라고 생각한다. 그렇다면 어떻게 게임 오브젝트가 활성화될 때 start라는 메서드가 자동으로 실행되는 것일까.&lt;/p&gt;

&lt;p&gt;유니티에서는 게임 오브젝트가 활성화 되면 그 게임 오브젝트에 start라는 메시지를 보낸다. 그러면 게임오브젝트의 컴포넌트에서 start 메서드가 있는 경우에는 수행, 그게 아니라면 무시하는 방식으로 start 메서드를 자동으로 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;유니티에는 위와 같이 이름과 철자만 똑같이 만들어두면 브로드캐스팅되는 메시지에 의해서 자동으로 실행되는 메서드들이 있다. 이러한 메서드를 유니티 이벤트 메서드라고한다.&lt;/p&gt;

&lt;p&gt;오늘은 유니티에서 사용하는 컴포넌트에 대한 개념과 메시지 - 브로드캐스팅으로 이루어지는 컴포넌트의 기능 실행에 대해 알아보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_초급학습_03</title>
      <link href="https://hjs101.github.io/Unity-03" rel="alternate" type="text/html" title="Unity_초급학습_03" />
      <published>2022-03-01T09:00:00+09:00</published>
      <updated>2022-03-01T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-03</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-03">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 Retr0 교재에서 제공하는 예제 파일을 다운받아서 오픈했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행을 하려고 하면 해당하는 버전이 없다는 메시지가 뜬다. 아래 톱니모양의 다른 버전의 데이터를 선택한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실습용으로 설치한 2021.2.13버전을 선택했다. 그 후 몇 가지 메시지가 뜨면 진행 하는 방향으로 클릭해주면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;에디터가 실행되면, 빨간색으로 동그라미친 파일, SampleScene 파일을 더블클릭한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 위와 같은 화면으로 바뀐다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저번 글에서 설명했던 툴바의 레이아웃을 변경하려고 한다. default로 되어있는 버튼을 눌러 2 by 3을 클릭한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 에디터를 구성하는 화면이 바뀔 것이다. 바뀐 에디터를 조정하여 위와 같은 구조로 만들었다.&lt;/p&gt;

&lt;p&gt;각 창에 대한 설명은 앞선 글에서 짤막하게 했기 때문에 추가적인 내용만 조금 적어 보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_08.jpg&quot; alt=&quot;Unity_08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hierarchy Window에서 오브젝트를 검색할 수 있다. 위 사진의 빨간색으로 칠해져있는 버튼을 누르면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_09.jpg&quot; alt=&quot;Unity_09&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이와 같이 상세검색을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_10.jpg&quot; alt=&quot;Unity_10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Project Window에서 빨간색을 칠해진 부분을 왼쪽으로 당기면, 아이콘으로 보이던 화면이 리스트로 바뀐다. 기본 윈도우에서 폴더 내 파일의 표기 방식을 바꾸는 것이라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_11.jpg&quot; alt=&quot;Unity_11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Console Window는, 시스템 메시지가 출력되는 Window로, 로깅이나 시스템 출력이 나타나는 Window이다. 해당 위치에는 3가지의 로그가 나타날 수 있다. 일반 로그, 경고 로그, 에러 로그이다.
경고 로그는 게임을 진행하는 데에는 문제가 없지만 수정을 권장할만한 상황에 표시된다.
에러 로그는 게임을 진행하는 데 치명적인 문제가 있을 때 표시된다. (실행이 불가할 때)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_12.jpg&quot; alt=&quot;Unity_12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진은 씬에 존재하는 게임 오브젝트를 편집할 때 사용할 툴을 모아놓은 툴 박스의 모습이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_13.jpg&quot; alt=&quot;Unity_13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;드래그 앤 드롭으로 씬 Window 상단에 배치시켰다. 각 툴들은 다음과 같은 기능을 가지고 있다. 왼쪽부터 설명하겠다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Hand : 그림관련 프로그램을 사용해봤다면 많이 익숙할 것이다. 화면을 움직인다. 단축키 Q, 마우스 휠 버튼으로 조작 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Translate : 오브젝트를 이동할 수 있다. 단축키 W&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Rocate : 오브젝트를 회전시킬 수 있다. 단축키 E&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scale : 오브젝트의 크기를 바꿀 수 있다. 단축키 R&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Rect : UI와 2D 오브젝트의 크기를 조정한다. 단축키 T&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Transform : Translate, Rocate, Scale을 하나로 합친 기능이다. 단축키 Y&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;씬 화면을 움직이는 방법 중 마우스를 함께 이용하는 방법은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;마우스 오른쪽 키를 누른 채로 WASD를 통해 움직이기. - 평행이동&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;alt + 마우스 왼쪽 키를 누른 채로 마우스 움직이기 - 회전&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;alt + 마우스 오른쪽 키를 누른 채로 마우스 움직이기 - 줌인, 줌아웃&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_14.jpg&quot; alt=&quot;Unity_14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진에 나와있는 화살표는, 오브젝트를 이동시킬 때 사용할 수 있다. 빨간색은 X축, 초록색은 Y축, 파란색은 Z축을 의미한다.&lt;/p&gt;

&lt;p&gt;내부에 있는 사각형을 이용해 각각의 2개의 축이 만들어내는 평면에 평행하게끔 평행이동을 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_02_15.jpg&quot; alt=&quot;Unity_15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진은 Scene Gizmo이다. 현재 씬이 바라보고 있는 방향을 표시하고, 카메라를 지정한 방향으로 빠르게 전환시킬 수 있다.&lt;/p&gt;

&lt;p&gt;오늘은 이전 포스팅에 이어서 창의 세부적인 기능들을 조금 더 살펴보았다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_초급학습_02</title>
      <link href="https://hjs101.github.io/Unity-02" rel="alternate" type="text/html" title="Unity_초급학습_02" />
      <published>2022-02-28T09:00:00+09:00</published>
      <updated>2022-02-28T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-02</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-02">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;오늘은 프로젝트를 생성하고 간단한 컴포넌트 추가를 해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_07.jpg&quot; alt=&quot;Unity_07&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 프로젝트 생성 부분이다. 위 사진에서 오른쪽 위의 New project버튼을 누른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_09.jpg&quot; alt=&quot;Unity_09&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3D를 선택하고, Project 이름은 HelloUnity로 한다. 프로젝트 폴더를 저장할 위치는 임의로 정했다. 이후 Create project 버튼을 누른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_10.jpg&quot; alt=&quot;Unity_10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 프로젝트가 생성되어 오픈된 사진이다. 간단하게만 목록만 설명하겠다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;아래에는 프로젝트 Window가 있고 이곳에서는 프로젝트에서 사용할 수 있는 에셋 라이브러리가 표시된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;중앙에 있는 공간같은 화면은 씬(Scene)뷰이다. 이 화면에서는 씬을 시작적으로 탐색하며 편집할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;왼쪽에는 Hierachy(계층구조) Window 가 있다. 계층구조 Window 에서는 씬에 있는 모든 오브젝트를 계층구조로 표시한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;오른쪽에는 인스펙터(Inspector) Window가 있다. 인스펙터 Window 에서는 현재 선택한 오브젝트의 모든 프로퍼티를 보고 편집할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마지막으로, 재생, 일시정지 등의 버튼이 보이는 상단은 Tool Bar이다. 이를 통해서 가장 필수적인 작업기능에 접근할 수 있다. 왼쪽에는 씬 뷰와 그 안에 있는 오브젝트를 조작할 수 있는 기본 툴, 중앙에는 재생, 일시정지, 스텝 컨트롤이, 오른쪽에 있는 버튼을 통해 Unity 클라우드 서비스 및 Unity 계정에 접근할 수 있다. 오른쪽에 이어서 레이어 메뉴와, 레이아웃을 저장할 수 있는 에디터 레이아웃 메뉴가 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;유니티 작업 Window 구조를 간단하게 알아봤으니, 이제 오브젝트 하나를 생성해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_11.jpg&quot; alt=&quot;Unity_11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hierachy Window에 커서를 대고 오른쪽 클릭을 한다. 3D Object -&amp;gt; Cube를 선택하여 Cube를 하나 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_12.jpg&quot; alt=&quot;Unity_12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;큐브 하나만 달랑 있으면 아쉬우니 바닥도 생성해준다. 위와 동일한 방법으로 이번에는 Plane를 생성한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_13.jpg&quot; alt=&quot;Unity_13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;큐브와 바닥을 생성하고 나면 두 개의 오브젝트는 겹쳐있을 것이다. 위 사진은 큐브를 선택한 후 Y축으로 끌어올려 바닥 위 공중에 큐브를 띄워놓은 상태이다. 이제 큐브에 중력을 적용하여 큐브가 바닥 위로 떨어지게 해볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_14.jpg&quot; alt=&quot;Unity_14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;큐브를 선택하고, 오른쪽 인스펙터 Window를 살펴본다. 아래에 Add Component를 찾아 검색창에 Rigid를 검색하면, 다음과 같은 컴포넌트가 나타난다. 해당 컴포넌트를 추가해준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_15.jpg&quot; alt=&quot;Unity_15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컴포넌트를 추가하고 나면 위와 같이 RigidBody가 생성되었을 것이다. RigidBody는 선택한 게임 오브젝트가 물리제어로 동작할 수 있게 하는 컴포넌트이다. 자세한 설명은 아래 링크를 참고하면 좋겠다. 그 위에 있는 Collider은 충돌판정에 대한 컴포넌트로, 큐브는 Box형으로 충돌판정을 하는 것이 디폴트로 되어있다.&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://docs.unity3d.com/kr/2018.4/Manual/class-Rigidbody.html&quot;&gt;Unity RigidBody&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이제 Tool Bar의 재생 버튼을 눌러 실행해보겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_16.gif&quot; alt=&quot;Unity_16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;바닥으로 떨어지는 큐브가 보인다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_초급학습_01</title>
      <link href="https://hjs101.github.io/Unity-01" rel="alternate" type="text/html" title="Unity_초급학습_01" />
      <published>2022-02-27T09:00:00+09:00</published>
      <updated>2022-02-27T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-01</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-01">&lt;p&gt;이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/unity.png&quot; alt=&quot;Unity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.hanbit.co.kr/store/books/look.php?p_code=B9351446616&quot;&gt;레트로의 유니티 게임 프로그래밍 에센스(개정판)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;실습하기에 앞서서 교재에서 사용하는 버전에 맞는 유니티를 설치하여 준비를 끝마치려고 한다.&lt;/p&gt;

&lt;p&gt;설치하는 방법은 유니티 허브에서 install 하는 것과 아카이브 페이지에서 다운로드 받는 것 2가지가 있는데, 나는 유니티 허브에서 설치하던 중 오류가 발생하여 아카이브 페이지에서 설치 파일을 다운받아 설치했다.&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://unity3d.com/kr/get-unity/download/archive&quot;&gt;Unity Download Archive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_00.jpg&quot; alt=&quot;Unity_00&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 링크를 타고 들어가면 Unity 에디터 설치 파일을 다운로드 받을 수 있다. 나는 현 시점에서 최신 버전인 2021.2.13 버전을 다운받았다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_01.jpg&quot; alt=&quot;Unity_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_02.jpg&quot; alt=&quot;Unity_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;나는 자동으로 정해지는 대로 쭉 다음 버튼을 눌러 설치했다.&lt;/p&gt;

&lt;p&gt;다만, 이렇게 아카이브를 통해 설치하면 부가적인 모듈을 설치해야 하는데 어디서 설치해야 할 지 몰랐다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_03.jpg&quot; alt=&quot;Unity_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아카이브 페이지를 다시 찾아보니, 유니티 에디터 설치 파일이 아니라 설치마법사가 있는 파일이 따로 있었다. 위 사진에 있는 Unity 설치 프로그램 항목을 눌러 설치를 다시 진행하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_04.jpg&quot; alt=&quot;Unity_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;새로 받은 파일로 설치하면 위와 같이 체크박스로 설치할 컴포넌트를 선택할 수 있다. 처음부터 위 파일로 설치한다면 위 사진과 같이 4개를 체크하면 된다. 나는 에디터를 먼저 설치했었기 때문에, 가장 위에 있는 체크박스는 해제하고 설치했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_05.jpg&quot; alt=&quot;Unity_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;모두 설치된 후 재부팅해준다.&lt;/p&gt;

&lt;p&gt;이후 유니티 허브에 들어가 보면 다음과 같이 2021.2.13버전이 설치되어 있는 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://hjs101.github.io/assets/images/Unity_01_06.jpg&quot; alt=&quot;Unity_06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;유니티 허브 설치와 사용에 대한 부분은 다른 블로그의 포스팅을 참고해주시면 감사하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">이 포스팅의 내용은 한빛미디어의 ‘레트로의 유니티 게임 프로그래밍 에센스(개정판)’을 요약 정리하였습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Unity_목차</title>
      <link href="https://hjs101.github.io/Unity-menu" rel="alternate" type="text/html" title="Unity_목차" />
      <published>2022-02-26T09:00:00+09:00</published>
      <updated>2022-02-26T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/Unity-menu</id>
      <content type="html" xml:base="https://hjs101.github.io/Unity-menu">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;유니티_목차&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
  2022-02-28
  &lt;li&gt;&lt;a href=&quot;./Unity-01&quot;&gt;유니티 초급 학습_01&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;./Unity-02&quot;&gt;유니티 초급 학습_02&lt;/a&gt;&lt;/li&gt;
  &lt;br /&gt;
  2022-03-01
  &lt;li&gt;&lt;a href=&quot;./Unity-03&quot;&gt;유니티 초급 학습_03&lt;/a&gt;&lt;/li&gt;
  &lt;br /&gt;
  2022-03-02
  &lt;li&gt;&lt;a href=&quot;./Unity-04&quot;&gt;유니티 초급 학습_04&lt;/a&gt;&lt;/li&gt;
  &lt;br /&gt;
  2022-03-03
  &lt;li&gt;&lt;a href=&quot;./Unity-05&quot;&gt;유니티 초급 학습_05&lt;/a&gt;&lt;/li&gt;
  &lt;br /&gt;
  2022-03-04
  &lt;li&gt;&lt;a href=&quot;./Unity-06&quot;&gt;유니티_초급 학습_06&lt;/a&gt;&lt;/li&gt;
  &lt;br /&gt;
  2022-03-05
  &lt;li&gt;&lt;a href=&quot;./Unity-07&quot;&gt;유니티_초급 학습_07&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="Unity" />
      

      
        <summary type="html">유니티_목차 2022-02-28 유니티 초급 학습_01 유니티 초급 학습_02 2022-03-01 유니티 초급 학습_03 2022-03-02 유니티 초급 학습_04 2022-03-03 유니티 초급 학습_05 2022-03-04 유니티_초급 학습_06 2022-03-05 유니티_초급 학습_07</summary>
      

      
      
    </entry>
  
</feed>
