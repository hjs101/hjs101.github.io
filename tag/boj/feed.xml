<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hjs101.github.io/tag/boj/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hjs101.github.io/" rel="alternate" type="text/html" />
  <updated>2022-02-24T01:02:51+09:00</updated>
  <id>https://hjs101.github.io/tag/boj/feed.xml</id>

  
  
  

  
    <title type="html">hjs’s Blog | </title>
  

  
    <subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">BOJ_16236_아기 상어_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-16236" rel="alternate" type="text/html" title="BOJ_16236_아기 상어_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-16236</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-16236">&lt;h2 id=&quot;문제--아기-상어&quot;&gt;문제 : 아기 상어&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/16236&quot;&gt;BOJ_16236_아기상어&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;혼자 풀었던 방식의 개요는 아래와 같다.&lt;/p&gt;

&lt;p&gt;한 번 이동시마다 1초씩 증가&lt;/p&gt;

&lt;p&gt;배열을 탐색하며 상어의 크기보다 작은 물고기들을(먹을 수 있는 물고기) 리스트에 넣는다 집어넣는 값은 좌표.&lt;/p&gt;

&lt;p&gt;거리가 같다면 높이가 높은 쪽, 높이도 같다면 가장 왼쪽부터 먹는다.&lt;/p&gt;

&lt;p&gt;상어는 몸 크기가 2로 시작하며, 자신보다 크기가 큰 물고기는 지나가지 못한다 (벽 취급)&lt;/p&gt;

&lt;p&gt;리스트에서 하나씩 꺼내며 거리가 가장 짧은 좌표를 구한다. ( 이 때 먹을 수 있는지 없는지도 판단해야겠다. 만약 작은물고기가 있을 지라도 경로상 도달하지 못하면 못먹는 물고기이다.)&lt;/p&gt;

&lt;p&gt;해당 위치로 이동하고 거리만큼 시간을 더해준다.&lt;/p&gt;

&lt;p&gt;BFS 탐색을 통하면 현재 상어의 위치부터 물고기까지의 최단거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;한 번 물고기를 먹은 후 리스트를 초기화하고, 다시 배열을 탐색하며 물고기의 좌표를 리스트에 저장한다.&lt;/p&gt;

&lt;p&gt;위의 방식으로 정답을 맞추긴 했으나, 다른 풀이에 비해서 시간은 4~5배, 메모리는 8~9배 정도로 자원사용량이 너무 컸다. 한 번 이동할 때마다 리스트 새로 생성하고, 배열을 다시 탐색하면서 리스트에 값 집어넣고 하는 과정들이 시간과 메모리 소모가 너무 컸던 것으로 예상된다.&lt;/p&gt;

&lt;p&gt;이러한 문제의 해결 방법으로 우선순위 큐라는 것을 알게 되었다. 또한 로직도 배열 기준이 아닌 상어를 중심으로 움직이도록 일부 수정했다.&lt;/p&gt;

&lt;p&gt;이전처럼 배열을 탐색하며 물고기 위치를 저장해두는 것이 아니라, 상어의 위치만 기억해두고 BFS를 수행한다. BFS에서, 상어는 1번 움직일때마다 자신이 가지고 있는 dist값을 1씩 증가시키면서 이동한다.&lt;/p&gt;

&lt;p&gt;BFS 탐색 도중 만나는 물고기에 대해 먹을 수 있는 물고기인지 확인 후, 먹을 수 있는 물고이라면 상어의 dist값을 부여하고 생성하여 우선순위 큐에 추가한다.&lt;/p&gt;

&lt;p&gt;우선순위큐(오름차순)는 큐에 들어있는 값을 자동으로 오름차순으로 꺼내준다. 큐의 우선순위를 정하는 부분을 아래 문구에 맞게 CompareTo 메서드를 재정의 한다.&lt;/p&gt;

&lt;p&gt;“거리가 같다면 높이가 높은 쪽, 높이도 같다면 가장 왼쪽부터 먹는다.”&lt;/p&gt;

&lt;p&gt;이렇게 우선순위 큐에 먹을 수 있는 생선을 집어넣고, 가장 먼저 poll한 값이 현재 상어의 위치에서 가장 가까운 물고이의 위치이다.&lt;/p&gt;

&lt;p&gt;이후 재귀호출을 하여 다음 먹이를 계속해서 찾아주고, BFS 탐색을 한 뒤에 우선순위큐에 어떠한 값도 들어가 있지 않다면(기저조건) 더이상 먹을 수 있는 물고기가 없다는 뜻이므로 return한다.&lt;/p&gt;

&lt;p&gt;우선순위큐를 사용하자 코드가 훨씬 간결해졌고, 로직변경과 더해져 수행속도, 메모리 사용량이 대폭 감소했다.&lt;/p&gt;

&lt;h2 id=&quot;소스-코드--리스트-사용&quot;&gt;소스 코드 : 리스트 사용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

/*
 	거리
	|x-x1| + |y-y2|

	거리가 같다면 가장 왼쪽

	한 번 이동시마다 1초씩 증가
	배열을 탐색하며 상어의 크기보다 작은 물고기들을 리스트에 넣는다 집어넣는 값은 좌표

	리스트에서 하나씩 꺼내며 거리가 가장 짧은 좌표를 구한다. ( 이 때 먹을 수 있는지 없는지도 판단해야겠다)

	해당 위치로 이동하고 거리만큼 시간을 더해준다.

	위 내용을 반복하려고 했지만 안되네 자기보다 큰 물고기는 못지나가기 때문에 거리를 계산하지 말고 움직여야할듯.... 이거 어케하지? -&amp;gt; 찾아보니까 BFS 탐색을 통하면 최단거리를 구할 수 있다. 벽부수고이동하기 참고.
*/

class Distance implements Comparable&amp;lt;Distance&amp;gt; {
	int x;
	int y;
	int body;
	int dist;
	public Distance(int x, int y, int body) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
	}
	public Distance(int x, int y, int body, int dist) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
		this.dist = dist;
	}
	@Override
	public int compareTo(Distance o) {
		// TODO Auto-generated method stub
		return 0;
	}

}

public class BOJ_16236_아기상어 {

	static int N;
	static int[][] arr;
	static List&amp;lt;Distance&amp;gt; list;
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static int min;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		N = Integer.parseInt(in.readLine());

		arr = new int[N + 1][N + 1];

		list = new ArrayList&amp;lt;&amp;gt;();
		StringTokenizer st;

		Distance shark = null;
		// 배열에 값 할당, 초기에 상어가 먹을 수 있는 값의 위치 저장하기.
		for (int i = 1; i &amp;lt;= N; i++) {
			st = new StringTokenizer(in.readLine(), &quot; &quot;);
			for (int j = 1; j &amp;lt;= N; j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if (arr[i][j] == 1) {
					list.add(new Distance(i, j, arr[i][j]));
				}
				if (arr[i][j] == 9) {
					shark = new Distance(i, j, 2);
				}
			}
		}

		// 먹을 수 있는 먹이가 없을 때
		if (list.size() == 0) {
			System.out.println(0);
			return;
		}
		int answer =0;
		int cnt = 0;
		while (true) {
			Distance minfish = null;

			min = Integer.MAX_VALUE;
			for (int i = 0, n = list.size(); i &amp;lt; n; i++) {
				Distance temp = bfs(shark, list.get(i), new boolean[N+1][N+1]);

				if(temp.dist == 0) {
					continue;
				}

				if(temp.dist &amp;lt; min) {
					min = temp.dist;
					minfish = temp;
				}else if(temp.dist == min) {
					if(temp.x &amp;lt; minfish.x) {
						min = temp.dist;
						minfish = temp;
					}else if(temp.x == minfish.x) {
						if(temp.y &amp;lt; minfish.y) {
							min = temp.dist;
							minfish = temp;
						}
					}
				}
			}

			if(minfish == null) {
				System.out.println(answer);
				return;
			}

			cnt++;

			answer += minfish.dist;
//			System.out.println(answer);
//			for(int i=0;i&amp;lt;N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
//			}
			arr[shark.x][shark.y] = 0;
			arr[minfish.x][minfish.y] = 9;
			shark.x = minfish.x;
			shark.y = minfish.y;
			for(int i=1;i&amp;lt;=N;i++) {
				for(int j=1;j&amp;lt;=N;j++) {
					System.out.print(arr[i][j]+&quot; &quot;);
				}
				System.out.println();
			}
			System.out.println(&quot;dist:&quot;+minfish.dist);
			System.out.println(&quot;answer: &quot;+answer);
			System.out.println(&quot;====================&quot;);
			System.out.println();
			if(cnt == shark.body) {
				shark.body++;
				cnt = 0;
			}

			list = new ArrayList&amp;lt;&amp;gt;();

			for(int i =1 ;i&amp;lt;=N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
				for(int j=1;j&amp;lt;=N;j++) {
					if(arr[i][j] != 0 &amp;amp;&amp;amp; arr[i][j] &amp;lt; shark.body) {
						list.add(new Distance(i,j,arr[i][j]));
					}
				}
			}
		}

	}

	static Distance bfs(Distance shark, Distance fish, boolean[][] visited) {

		Queue&amp;lt;Distance&amp;gt; queue = new LinkedList&amp;lt;Distance&amp;gt;();

		int x;
		int y;

		queue.add(new Distance(shark.x,shark.y, shark.body));

		visited[shark.x][shark.y] = true;

		int sharkBody = shark.body;

		while(!queue.isEmpty()) {

			Distance point = queue.poll();
			x = point.x;
			y = point.y;

			if(x == fish.x &amp;amp;&amp;amp; y == fish.y) {
				return point;
			}

			for(int d=0;d&amp;lt;4;d++) {
				int dx = x + dir[d][0];
				int dy = y + dir[d][1];
				if(dx &amp;gt; 0&amp;amp;&amp;amp; dx&amp;lt;= N &amp;amp;&amp;amp; dy &amp;gt; 0 &amp;amp;&amp;amp; dy &amp;lt;= N) {
					if(sharkBody &amp;gt;= arr[dx][dy] &amp;amp;&amp;amp; !visited[dx][dy]) {
						visited[dx][dy] = true;
						queue.offer(new Distance(dx, dy, sharkBody,point.dist+1));
					}
				}
			}
		}
		// 경로가 없는 경우
		return new Distance(0,0,0);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;소스-코드--우선순위-큐-사용&quot;&gt;소스 코드 : 우선순위 큐 사용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

/*
 	거리
	|x-x1| + |y-y2|

	거리가 같다면 가장 왼쪽

	한 번 이동시마다 1초씩 증가
	배열을 탐색하며 상어의 크기보다 작은 물고기들을 리스트에 넣는다 집어넣는 값은 좌표

	리스트에서 하나씩 꺼내며 거리가 가장 짧은 좌표를 구한다. ( 이 때 먹을 수 있는지 없는지도 판단해야겠다)

	해당 위치로 이동하고 거리만큼 시간을 더해준다.

	위 내용을 반복하려고 했지만 안되네 자기보다 큰 물고기는 못지나가기 때문에 거리를 계산하지 말고 움직여야할듯.... 이거 어케하지? -&amp;gt; 찾아보니까 BFS 탐색을 통하면 최단거리를 구할 수 있다. 벽부수고이동하기 참고.
*/

class Distance implements Comparable&amp;lt;Distance&amp;gt; {
	int x;
	int y;
	int body;
	int dist;
	public Distance(int x, int y, int body) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
	}
	public Distance(int x, int y, int body, int dist) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
		this.dist = dist;
	}
	@Override
	public int compareTo(Distance o) {
		// TODO Auto-generated method stub
		return 0;
	}

}

public class BOJ_16236_아기상어 {

	static int N;
	static int[][] arr;
	static List&amp;lt;Distance&amp;gt; list;
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static int min;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		N = Integer.parseInt(in.readLine());

		arr = new int[N + 1][N + 1];

		list = new ArrayList&amp;lt;&amp;gt;();
		StringTokenizer st;

		Distance shark = null;
		// 배열에 값 할당, 초기에 상어가 먹을 수 있는 값의 위치 저장하기.
		for (int i = 1; i &amp;lt;= N; i++) {
			st = new StringTokenizer(in.readLine(), &quot; &quot;);
			for (int j = 1; j &amp;lt;= N; j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if (arr[i][j] == 1) {
					list.add(new Distance(i, j, arr[i][j]));
				}
				if (arr[i][j] == 9) {
					shark = new Distance(i, j, 2);
				}
			}
		}

		// 먹을 수 있는 먹이가 없을 때
		if (list.size() == 0) {
			System.out.println(0);
			return;
		}
		int answer =0;
		int cnt = 0;
		while (true) {
			Distance minfish = null;

			min = Integer.MAX_VALUE;
			for (int i = 0, n = list.size(); i &amp;lt; n; i++) {
				Distance temp = bfs(shark, list.get(i), new boolean[N+1][N+1]);

				if(temp.dist == 0) {
					continue;
				}

				if(temp.dist &amp;lt; min) {
					min = temp.dist;
					minfish = temp;
				}else if(temp.dist == min) {
					if(temp.x &amp;lt; minfish.x) {
						min = temp.dist;
						minfish = temp;
					}else if(temp.x == minfish.x) {
						if(temp.y &amp;lt; minfish.y) {
							min = temp.dist;
							minfish = temp;
						}
					}
				}
			}

			if(minfish == null) {
				System.out.println(answer);
				return;
			}

			cnt++;

			answer += minfish.dist;
//			System.out.println(answer);
//			for(int i=0;i&amp;lt;N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
//			}
			arr[shark.x][shark.y] = 0;
			arr[minfish.x][minfish.y] = 9;
			shark.x = minfish.x;
			shark.y = minfish.y;
			for(int i=1;i&amp;lt;=N;i++) {
				for(int j=1;j&amp;lt;=N;j++) {
					System.out.print(arr[i][j]+&quot; &quot;);
				}
				System.out.println();
			}
			System.out.println(&quot;dist:&quot;+minfish.dist);
			System.out.println(&quot;answer: &quot;+answer);
			System.out.println(&quot;====================&quot;);
			System.out.println();
			if(cnt == shark.body) {
				shark.body++;
				cnt = 0;
			}

			list = new ArrayList&amp;lt;&amp;gt;();

			for(int i =1 ;i&amp;lt;=N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
				for(int j=1;j&amp;lt;=N;j++) {
					if(arr[i][j] != 0 &amp;amp;&amp;amp; arr[i][j] &amp;lt; shark.body) {
						list.add(new Distance(i,j,arr[i][j]));
					}
				}
			}
		}

	}

	static Distance bfs(Distance shark, Distance fish, boolean[][] visited) {

		Queue&amp;lt;Distance&amp;gt; queue = new LinkedList&amp;lt;Distance&amp;gt;();

		int x;
		int y;

		queue.add(new Distance(shark.x,shark.y, shark.body));

		visited[shark.x][shark.y] = true;

		int sharkBody = shark.body;

		while(!queue.isEmpty()) {

			Distance point = queue.poll();
			x = point.x;
			y = point.y;

			if(x == fish.x &amp;amp;&amp;amp; y == fish.y) {
				return point;
			}

			for(int d=0;d&amp;lt;4;d++) {
				int dx = x + dir[d][0];
				int dy = y + dir[d][1];
				if(dx &amp;gt; 0&amp;amp;&amp;amp; dx&amp;lt;= N &amp;amp;&amp;amp; dy &amp;gt; 0 &amp;amp;&amp;amp; dy &amp;lt;= N) {
					if(sharkBody &amp;gt;= arr[dx][dy] &amp;amp;&amp;amp; !visited[dx][dy]) {
						visited[dx][dy] = true;
						queue.offer(new Distance(dx, dy, sharkBody,point.dist+1));
					}
				}
			}
		}
		// 경로가 없는 경우
		return new Distance(0,0,0);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 아기 상어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_15686_치킨 배달_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-15686" rel="alternate" type="text/html" title="BOJ_15686_치킨 배달_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-15686</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-15686">&lt;h2 id=&quot;문제--치킨-배달&quot;&gt;문제 : 치킨 배달&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/15686&quot;&gt;BOJ_15686_치킨배달&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;N*N크기의 배열에 들어있는 값을 탐색하며 치킨집의 위치, 집의 위치를 각각 나누어 리스트에 저장한다.&lt;/p&gt;

&lt;p&gt;그 후, 치킨집의 개수에서 M개의 치킨집을 고르는 조합을 통해 가능한 치킨집의 경우의 수를 구한다.&lt;/p&gt;

&lt;p&gt;구해진 M개의 치킨집과 각각의 집의 최단 거리를 구해서 더한다.&lt;/p&gt;

&lt;p&gt;최단거리를 구해서 더한 값을 생성된 조합별로 비교해 그 중에서 가장 작은 값을 구하여 출력하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;좌표정보를 저장할 클래스 Vector을 생성한다. 해당 클래스는 x좌표, y좌표를 멤버 변수로써 가진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N*N 크기의 배열을 생성한다, 집의 정보를 저장할 리스트와, 치킨집의 정보를 저장할 리스트를 각각 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열에 주어진 값을 추가하는데, 해당하는 값이 1(집)이면 집 리스트에, 2(치킨집)이면 치킨집 리스트에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조합 메서드를 구현하여 적용한다. M개 이상의 치킨집에서 M개만큼 뽑는 조합을 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조합의 기저조건에서, 집 List 길이 * 구해진 치킨집의 개수만큼 이중반복문을 돌린다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;내부반복문에서 dist의 최소값을 먼저 구하고, 그것을 내부 통합 거리에 더해준다. 그리고, 그 바깥에서 내부통합거리의 최솟값을 구하는 로직을 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 조합에 대해 최소 거리를 구하는 작업이 끝난 후, 구해진 최소 통합 거리를 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;


class Vector{

	int x;
	int y;
	public Vector(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}


}

public class BOJ_15686_치킨배달 {


	static int N, M, arr[][];

	static ArrayList&amp;lt;Vector&amp;gt; chList;
	static ArrayList&amp;lt;Vector&amp;gt; hoList;
	static Vector[] chickens;
	static int totalDist = Integer.MAX_VALUE;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		N = Integer.parseInt(st.nextToken());


		M = Integer.parseInt(st.nextToken());



		arr = new int[N][N];
		chList = new ArrayList&amp;lt;&amp;gt;();
		hoList = new ArrayList&amp;lt;&amp;gt;();
		chickens = new Vector[M];

		for(int i=0;i&amp;lt;N;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);
			for(int j=0;j&amp;lt;N;j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if(arr[i][j] == 2) {
					chList.add(new Vector(i,j));
				}
				if(arr[i][j] == 1) {
					hoList.add(new Vector(i,j));
				}
			}
		}		

		comb(0,0);

		System.out.println(totalDist);
	}

	static void comb(int start, int cnt) {

		if(cnt == M) {
			int inTotalDist = 0;
			for(int i=0,n=hoList.size();i&amp;lt;n;i++) {
				int inMin = Integer.MAX_VALUE;
				for(int j=0;j&amp;lt;chickens.length;j++) {
					int row =  Math.abs(hoList.get(i).x - chickens[j].x);
					int col =  Math.abs(hoList.get(i).y - chickens[j].y);
					int dist = row + col;
					inMin = Math.min(inMin,dist);
				}
				inTotalDist += inMin;
			}
			totalDist = Math.min(totalDist, inTotalDist);
			return;
		}

		for(int i=start, n = chList.size();i&amp;lt;n;i++) {

			chickens[cnt] = new Vector(chList.get(i).x, chList.get(i).y);

			comb(i+1,cnt+1);
		}


	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 치킨 배달</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_11399_ATM_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-11399" rel="alternate" type="text/html" title="BOJ_11399_ATM_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-11399</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-11399">&lt;h2 id=&quot;문제--atm&quot;&gt;문제 : ATM&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/11399&quot;&gt;BOJ_11399_ATM&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;오름차순 정렬한 뒤 모든 사람의 누적 시간의 합을 더해서 총 누적 시간을 출력하면 되는 간단한 문제이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;사람 수를 읽어올 변수, 사람별 대기 시간을 저장할 배열을 생성하고 값을 할당한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2중 반복하는데, 뒤에 사람이 늘어날 때마다 앞의 사람의 대기 시간을 누적하여 구할 수 있도록 내부 반복문은 1부터 점차적으로 증가하게끔 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 총 누적 대기 시간을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_11399_ATM {

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		int[] arr = new int[N];

		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}

		Arrays.sort(arr);

		/*
		    1
			12
			123
			1234
			12345
		*/
		int sum = 0;
		for(int i=0;i&amp;lt;N;i++) {
			for(int j=0;j&amp;lt;=i;j++) {
				sum = sum + arr[j];
			}
		}

		System.out.println(sum);

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : ATM</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2178_미로탐색_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2178" rel="alternate" type="text/html" title="BOJ_2178_미로탐색_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2178</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2178">&lt;h2 id=&quot;문제--미로탐색&quot;&gt;문제 : 미로탐색&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2178&quot;&gt;BOJ_2178_미로탐색&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;오늘 앞서 풀었던 아기 상어 문제에 있는 최단 거리를 구하는 BFS의 알고리즘을 그대로 사용해서 풀 수 있었다. 배열의 시작점부터 끝까지 BFS으로 탐색하면서 가장 먼저 목적지까지 도달하는 순간 그때의 거리를 출력하면 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;값을 읽어와 N*M 크기의 배열을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;방문정보를 저장할 동일한 크기의 boolean 배열도 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열에 값을 읽어와 저장하고, BFS를 호출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS에서 사방탐색을 통해 이동할 수 있는 경우를 확인하고, 방문하지 않은 곳이면서 이동이 가능할 경우 이동한다. 배열에서 벽이 0이므로, 0이 아닐경우 또는 1일경우 이동가능한 것으로 본다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탐색 도중 목적지에 도달한 최초 거리를 출력하고 return 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_2178_미로탐색 {


	static char[][] arr;
	static boolean[][] isVisited;
	static int N,M;
	static int[][] dir = { {1,0},{-1,0},{0,1},{0,-1} };
	static int cnt;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		M = Integer.parseInt(st.nextToken());
		arr = new char[N][M];
		isVisited = new boolean[N][M];
		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = in.readLine().toCharArray();
		}

		bfs(0,0);		


	}

	static void bfs(int x, int y) {

		Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();

		queue.offer(new int[]{x,y,0});

		isVisited[x][y] = true;

		while(!queue.isEmpty()) {


			int[] pos = queue.poll();
			if(pos[0] == N-1 &amp;amp;&amp;amp; pos[1] == M-1) {
				System.out.println(++pos[2]);
				break;
			}
			for(int d=0;d&amp;lt;4;d++) {
				int dx = pos[0] + dir[d][0];
				int dy = pos[1] + dir[d][1];
				if(dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; N &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; M) {
					if(arr[dx][dy] == '1' &amp;amp;&amp;amp; isVisited[dx][dy] == false) {
						isVisited[dx][dy] = true;
						queue.offer(new int[] {dx,dy,pos[2]+1});
					}
				}
			}

		}



	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 미로탐색</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2667_단지번호붙이기_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2667" rel="alternate" type="text/html" title="BOJ_2667_단지번호붙이기_JAVA" />
      <published>2022-02-22T21:00:00+09:00</published>
      <updated>2022-02-22T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2667</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2667">&lt;h2 id=&quot;문제--단지번호붙이기&quot;&gt;문제 : 단지번호붙이기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2667&quot;&gt;BOJ_2667_단지번호붙이기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;DFS 또는 BFS를 이용하여 2차원 배열의 서로 인접한 노드의 개수를 탐색한다. 인접한 노드의 집합을 묶어서 카운트하고, 각 집합의 개수도 추가로 카운트한다. 최종적으로 2차원 배열의 인접한 노드의 집합의 개수와 각 집합의 노드 개수를 구하여 출력하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 배열의 크기를 읽어들여 char타입 2차원 배열을 생성한다. 같은 크기로 boolean 배열도 함께 선언한다.(false 기본초기화)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성한 2차원 배열에 입력값을 할당한다. 노드의 집합을 저장할 list를 하나 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열을 탐색하여 값이 ‘1’이면서 아직 방문하지 않은 노드일 경우 카운트를 1로 두고 DFS 메서드를 호출한다. 방문처리는 앞서 선언했던 boolean 배열을 이용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS를 이용하여 인접 노드를 순회한다. DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리한다. 배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다. 그리고 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS 순회가 끝난 후 cnt값을 list에 추가하고 이어서 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열 탐색이 모두 끝나면 리스트를 정렬하여 리스트의 길이와 리스트에 들어있는 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BOJ_2667_단지번호붙이기 {
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static boolean[][] isVisited;
	static int N;
	static char arr[][];
	static int cnt;

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

		N = Integer.parseInt(in.readLine());

		// 값 저장할 배열
		arr = new char[N][N];
		// 방문상태 파악
		isVisited = new boolean[N][N];

		for (int i = 0; i &amp;lt; N; i++) {
			arr[i] = in.readLine().toCharArray();
		}

		// dfs
		for (int i = 0; i &amp;lt; N; i++) {
			for (int j = 0; j &amp;lt; N; j++) {
				if (arr[i][j] == '1' &amp;amp;&amp;amp; isVisited[i][j] == false) {
					cnt = 1;
					int cnt = dfs(i, j);
					list.add(cnt);
				}
			}
		}

		StringBuilder sb = new StringBuilder();

		Collections.sort(list);

		sb.append(list.size()).append('\n');

		for (int i = 0; i &amp;lt; list.size(); i++) {
			sb.append(list.get(i)).append('\n');
		}

		System.out.println(sb);

	}

	static int dfs(int x, int y) {

		isVisited[x][y] = true;

		for (int i = 0; i &amp;lt; 4; i++) {
			int dx = x + dir[i][0];
			int dy = y + dir[i][1];
			if (dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; N &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; N &amp;amp;&amp;amp; arr[dx][dy] == '1' &amp;amp;&amp;amp; isVisited[dx][dy] != true) {
				dfs(dx, dy);
				cnt++;
			}
		}
		return cnt;
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 단지번호붙이기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2567_색종이2_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2567" rel="alternate" type="text/html" title="BOJ_2567_색종이2_JAVA" />
      <published>2022-02-22T21:00:00+09:00</published>
      <updated>2022-02-22T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2567</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2567">&lt;h2 id=&quot;문제--색종이2&quot;&gt;문제 : 색종이2&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2567&quot;&gt;BOJ_2567_색종이2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;이전에 풀었던 색종이 문제의 확장형이다. 100*100크기에 색종이를 겹치는 건 같지만, 넓이를 구했던 그 때와 달리 이번에는 둘레를 구해야 한다. 넓이를 구할 때는 배열 내부의 값을 모두 카운트하면 해결되는 문제였다.&lt;/p&gt;

&lt;p&gt;둘레를 구하는 법은 막상 떠올릴려고 하면 어려웠다. 하지만 배열을 한 번 출력해보니 실마리가 보였다.&lt;/p&gt;

&lt;p&gt;핵심은 1과 인접한 0의 개수였다. 색종이의 크기는 10*10이고 정사각형이다. 색종이를 모두 1로 채워넣는다고 할 때 색종이의 모서리는 항상 0과 맞닿아있다. 꼭짓점 부분은 2개의 0과 인접하고, 그 부분은 길이를 2로 칠 수 있다. 이를 토대로 유추했을 때, 색종이의 둘레는 배열을 탐색하여 값이 1인 노드와 인접해있는 0의 개수일 것이다. 다만, 배열을 100, 100으로 설정할 경우, 0만 체크하면 안되고 배열의 경계값도 주의해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;100*100 크기의 int 타입 2차원 배열을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;색종이의 좌표를 읽어들여 각 좌표별로 10*10만큼 1을 입력한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열 전체를 탐색하며 1과 인접한 0의 개수를 센다. 1과 인접한 곳이 배열의 경계일 경우에도 카운트를 더해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탐색이 종료된 후 카운트한 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_2567_색종이2 {
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());
		StringTokenizer st;


		// 100*100 크기 배열 생성
		int[][] arr = new int[100][100];

		// 주어진 좌표로부터 10*10만큼 1 집어넣기
		for(int i=0;i&amp;lt;N;i++) {
			st = new StringTokenizer(in.readLine());

			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());

			for(int j = a; j &amp;lt;a+10;j++) {
				for(int k = b;k&amp;lt;b+10;k++) {
					arr[j][k] = 1;
				}
			}
		}
		// 둘레를 저장할 변수
		int cnt = 0;

		// 배열 전체 탐색 하며 1 주변의 0의 개수를 세기, 1 주변이 배열의 경계일 경우도 cnt를 더해준다
		for(int i=0;i&amp;lt;100;i++) {
			for(int j=0;j&amp;lt;100;j++) {
				// 배열에서 1을 만나면
				if(arr[i][j] == 1) {
					// 4방탐색
					for(int d = 0; d &amp;lt; 4; d++) {
						int dx = i + dir[d][0];
						int dy = j + dir[d][1];
						// 배열의 경계를 체크하여, 1 주변이 배열의 경계라면 cnt를 1 더해준다.
						if(dx &amp;lt; 0 || dx &amp;gt;= 100 || dy &amp;lt; 0 || dy &amp;gt;= 100) {
							cnt++;
						}
						// 배열의 경계 안에 있을 때, 1 주변에 0이 있다면 cnt를 1 더해준다.
						if(dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; 100 &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; 100 &amp;amp;&amp;amp; arr[dx][dy] == 0) {
							cnt++;
						}
					}
				}
			}
		}

		System.out.println(cnt);
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 색종이2</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1759_암호만들기_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1759" rel="alternate" type="text/html" title="BOJ_1759_암호만들기_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1759</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1759">&lt;h2 id=&quot;문제--암호만들기&quot;&gt;문제 : 암호만들기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1759&quot;&gt;BOJ_1759_암호만들기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;백트래킹 문제인데, 조합을 이용해서 푸는 문제라고 한다. 나는 이런 내용을 순열로 풀고 나서 알게 되었다. 나는 순열을 구하면서 가지치기를 통해 원하는 값을 리스트에 넣고, 그 리스트를 정렬하여 사전순으로 만들었다.&lt;/p&gt;

&lt;p&gt;C 개의 알파벳으로부터 L개의 길이의 암호문을 구하는 문제이다. 암호의 조건으로는 2가지가 있는데, 1가지는 왼쪽의 알파벳부터 오른쪽으로 갈 수록 값이 증가한다는 것, abc는 가능하지만 bac는 불가능하다.&lt;/p&gt;

&lt;p&gt;2번째 조건은 알파벳의 모음(a,e,i,o,u)은 최소 1개 이상 암호문에 포함되어야하며, 자음은 최소 2개 이상 암호문에 포함되어야 한다는 조건이다.&lt;/p&gt;

&lt;p&gt;나는 암호에 순서가 있다고 생각하여 순열을 이용하여 풀이해주었다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 값을 저장할 변수들을 전역으로 선언해주었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;알파벳의 개수와 암호문의 길이를 읽어와 변수에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 문자열을 읽어들일 배열을 생성해 값을 할당하고,  암호문 경우의 수를 저장할 배열을 암호문의 길이 L의 크기로 생성했다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열을 통해 경우의 수를 구하는데, 가지치기의 조건을 둔다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가지치기의 조건은, 현재 알파벳이 다음 알파벳보다 작을 경우에만 재귀호출을 하도록 하는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열이 완성되면, 각 순열별로 자음 카운트와 모음 카운트를 저장할 변수를 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만들어진 순열을 탐색하는데, 알파벳이 모음이면 모음 카운트를 증가시키고, 자음이라면 자음 카운트를 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열의 순회가 끝나고, 모음카운트가 1 이상, 자음카운트가 2 이상이라면 해당하는 수열을 문자열로 만들어 String 타입 리스트에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열이 모두 구해진 후, String 리스트를 Collections.sort 메서드를 이용하여 정렬한 후 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;

public class BOJ_1759_암호만들기 {
	static int C;
	static int L;
	static char[] chars;
	static char[] answer;
	static StringBuilder sb = new StringBuilder();
	static List&amp;lt;String&amp;gt; strs = new ArrayList&amp;lt;&amp;gt;();
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		L = Integer.parseInt(st.nextToken());
		C = Integer.parseInt(st.nextToken());

		chars = new char[C];
		answer = new char[L];
		st = new StringTokenizer(in.readLine(),&quot; &quot;);
		for(int i=0;i&amp;lt;C;i++) {
			chars[i] = st.nextToken().charAt(0);
		}

		perm(0,0,' ');
		Collections.sort(strs);

		for(int i=0;i&amp;lt;strs.size();i++) {
			sb.append(strs.get(i)).append('\n');
		}
		System.out.print(sb);
	}

	public static void perm(int cnt, int flag, char n) {

		if(cnt == L) {
			int mCnt = 0;
			int jCnt = 0;
			for(int i=0;i&amp;lt;L;i++) {
				switch(answer[i]) {
				case 'a':
				case 'e':
				case 'i':
				case 'o':
				case 'u':
					mCnt++;
					break;
				default:
					jCnt++;
				}
			}
			if(mCnt &amp;gt;= 1 &amp;amp;&amp;amp; jCnt &amp;gt;= 2) {
				String str = &quot;&quot;;
				for(int i=0;i&amp;lt;L;i++) {
					str = str + answer[i];
				}
				strs.add(str);
			}
			return;
		}


		for(int i=0;i&amp;lt;C;i++) {
			if((flag &amp;amp; 1&amp;lt;&amp;lt;i) != 0) {
				continue;
			}
			answer[cnt] = chars[i];
			// 가지치기 1 현재 알파벳이 다음 알파벳보다 작을 경우에만 재귀,
			if(n &amp;lt; answer[cnt]) {
				perm(cnt+1,flag | 1&amp;lt;&amp;lt;i, answer[cnt]);
			}
		}

	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 암호만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1417_국회의원선거_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1417" rel="alternate" type="text/html" title="BOJ_1417_국회의원선거_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1417</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1417">&lt;h2 id=&quot;문제--국회의원선거&quot;&gt;문제 : 국회의원선거&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1417&quot;&gt;BOJ_1417_국회의원선거&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;배열의 최댓값을 구하면서 인덱스 값을 같이 저장한다. 다솜의 번호는 가장 첫 번째이므로, 최댓값의 인덱스가 첫 번째 번호라면 투표를 뺏어올 필요가 없으니 0이다.&lt;/p&gt;

&lt;p&gt;그렇지 않은 경우라면, 배열의 최댓값에서 투표 수를 1 꺼내서 다솜의 투표에 추가하면 된다.&lt;/p&gt;

&lt;p&gt;문제는 최댓값이 다솜과 같은 인원이 다수 있을 때인데, 이 상황에서는, 최대 투표값을 크거나 같은 것으로 설정하면 해결된다. 그 이유는 다솜은 무조건 첫 번째 후보이기 때문에, 자신과 같은 투표수의 뒷 후보가 있다면 자동으로 본인은 최대 득표자에서 벗어나게 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;선거의 총 참여 인원수를 읽어와 저장하고, 각 후보의 투표 수를 N개 크기의 배열에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다솜의 투표 수가 최대가 될때까지 반복하는 반복문을 돌린다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열을 순회하며 최대 득표자를 찾고, 만약 최댓값이 다솜이라면 반복문을 나간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다솜이 최대 득표자가 아니라면, 최대 득표 후보는 -1을 다솜은 +1을 시켜준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복문이 한 번 돌아갈 때마다 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 카운트 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BOJ_1417_국회의원선거 {
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());

		int arr[] = new int[N];

		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = Integer.parseInt(in.readLine());
		}
		int cnt = 0;
		// 다솜이 최댓값이 될때까지 반복
		while(true) {
			int max = 0;
			int maxIndex = 0;
			for(int i=0;i&amp;lt;N;i++) {
				// 표 중에 최댓값을 구한다. index도 같이 저장한다.
				if(max &amp;lt;= arr[i]) {
					max = arr[i];
					maxIndex = i;
				}
			}
			// 최댓값이 다솜이라면
			if(maxIndex == 0) {
				break;
			}
			arr[maxIndex]--;
			arr[0]++;
			cnt++;
		}

		System.out.println(cnt);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 국회의원선거</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1260_DFS와BFS_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1260" rel="alternate" type="text/html" title="BOJ_1260_DFS와BFS_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1260</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1260">&lt;h2 id=&quot;문제--dfs와bfs&quot;&gt;문제 : DFS와BFS&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1260&quot;&gt;BOJ_1260_DFS와BFS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;주어진 노드를 읽어들여 그래프를 만들고, 그 그래프를 DFS와 BFS를 이용한 순회 결과를 출력하면 되는 문제이다.&lt;/p&gt;

&lt;p&gt;BFS와 DFS는 아래 링크의 게시글을 참고하여 공부하였다.&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://better-tomorrow.tistory.com/entry/DFS-BFS-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0?category=456505&quot;&gt;DFS와 BFS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;인접 행렬을 통해 주어진 인접 상태 좌표를 읽어들여 그래프를 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS를 이용하여 먼저 그래프를 순회한다. 인자값으로 boolean 배열(노드 수만큼), 생성한 그래프 배열, 시작할 노드를 받는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐를 생성한다. 초기 노드를 방문처리하고 큐에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐가 모두 비어있을 때까지 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐에서 값을 꺼내어 StringBuilder에 저장한다. 그 후 배열의 크기만큼 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 해당 노드의 행에 아직 방문하지 않고, 인접한 노드가 있다면 큐에 해당 노드를 추가하고 방문처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS 이용한 순회가 끝나면, DFS 이용하여 순회를 한다. 인자값으로는 BFS와 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리하고 StringBuilder에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순회가 끝나면 StringBuilder에 저장한 문자열을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_1260_DFS와BFS {
	static StringBuilder sb;
	static int N;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));




		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		int M = Integer.parseInt(st.nextToken());

		int V = Integer.parseInt(st.nextToken());

		int[][] adjMatrix = new int[N+1][N+1];



		for(int i=0;i&amp;lt;M;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);
			int v1 = Integer.parseInt(st.nextToken());
			int v2 = Integer.parseInt(st.nextToken());
			adjMatrix[v1][v2] = 1;
			adjMatrix[v2][v1] = 1;
		}

		boolean[] visited = new boolean[N+1];
		Arrays.fill(visited, false);
		sb = new StringBuilder();
		// dfs
		dfs(V, visited, adjMatrix);
		sb.setLength(sb.length()-1);
		sb.append('\n');

		Arrays.fill(visited, false);

		bfs(V,visited, adjMatrix);

		System.out.println(sb);

	}
	public static void bfs(int v, boolean[] visited, int[][] adjMatrix) {

		Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();

		visited[v] = true;
		queue.offer(v);

		while(!queue.isEmpty()) {
			int current = queue.poll();

			sb.append(current + &quot; &quot;);

			for(int i=1;i&amp;lt;=N;i++) {
				if(!visited[i] &amp;amp;&amp;amp; adjMatrix[current][i] != 0) {
					queue.offer(i);
					visited[i] = true;
				}
			}
		}


		sb.setLength(sb.length()-1);

	}

	public static void dfs(int v, boolean[] visited, int[][] adjMatrix) {
		visited[v] = true;
		sb.append(v + &quot; &quot;);
		for(int i=1;i&amp;lt;=N;i++) {
			if(!visited[i] &amp;amp;&amp;amp; adjMatrix[v][i] != 0) {
				visited[i] = true;
				dfs(i, visited, adjMatrix);
			}
		}
	}



}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : DFS와BFS</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2060_바이러스_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2060" rel="alternate" type="text/html" title="BOJ_2060_바이러스_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2060</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2060">&lt;h2 id=&quot;문제--바이러스&quot;&gt;문제 : 바이러스&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2060&quot;&gt;BOJ_2060_바이러스&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;DFS 또는 BFS를 이용하여 인접한 노드를 전체 순회하고 카운트 하면 되는 문제이다. 그래프 생성과 DFS, BFS중 한 가지라도 구현할 수 있다면 문제를 풀 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;인접 행렬을 통해 주어진 인접 상태 좌표를 읽어들여 그래프를 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS를 이용하여 인접 노드를 순회한다. DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다. 그리고 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순회가 끝나면 저장된 카운트 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_2060_바이러스 {
	static int N;
	static int cnt;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));


		N = Integer.parseInt(in.readLine());

		int C = Integer.parseInt(in.readLine());

		int[][] arr = new int[N+1][N+1];
		StringTokenizer st;
		for(int i=0;i&amp;lt;C;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);

			int from = Integer.parseInt(st.nextToken());

			int to = Integer.parseInt(st.nextToken());
			arr[from][to] = 1;
			arr[to][from] = 1;

		}

		dfs(arr,new boolean[N+1],1);


		System.out.println(cnt);
//		for(int i=1;i&amp;lt;=N;i++) {
//			System.out.println(Arrays.toString(arr[i]));
//		}

	}

	public static void dfs(int[][] arr, boolean[] isVisited, int V) {
		isVisited[V] = true;

		for(int i=1;i&amp;lt;=N;i++) {
			if(!isVisited[i] &amp;amp;&amp;amp; arr[V][i] == 1) {
				cnt++;
				dfs(arr, isVisited, i);
			}
		}

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 바이러스</summary>
      

      
      
    </entry>
  
</feed>
