<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hjs101.github.io/tag/boj/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hjs101.github.io/" rel="alternate" type="text/html" />
  <updated>2022-02-26T03:29:35+09:00</updated>
  <id>https://hjs101.github.io/tag/boj/feed.xml</id>

  
  
  

  
    <title type="html">hjs’s Blog | </title>
  

  
    <subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">BOJ_2116_주사위쌓기_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2116" rel="alternate" type="text/html" title="BOJ_2116_주사위쌓기_JAVA" />
      <published>2022-02-25T09:00:00+09:00</published>
      <updated>2022-02-25T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2116</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2116">&lt;h2 id=&quot;문제--주사위쌓기&quot;&gt;문제 : 주사위쌓기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2116&quot;&gt;BOJ_2116_주사위쌓기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;규칙 깔리는 주사위의 윗면과 놓는 주사위의 밑면의 숫자가 같아야한다.&lt;/p&gt;

&lt;p&gt;ABCDEF 순으로 값이 주어진다.&lt;/p&gt;

&lt;p&gt;순서는 1번 주사위부터 N번주사위까지 주어짐&lt;/p&gt;

&lt;p&gt;A-F, B-D, C-E가 윗면, 아랫면이 될 수 있다. 이 세가지 경우를 조사해&lt;/p&gt;

&lt;p&gt;경우의 수 별로 나머지 주사위들의 최댓값을 모아 출력하면 될 것 같았다. 하지만 모든 경우의 수를 따지려면, 주사위 개수만큼 for문을 중첩해야 할 것 같았다. 따라서 재귀를 이용해서 풀어보기로 했다.&lt;/p&gt;

&lt;p&gt;주사위를 숫자로 매칭했을 때 다음과 같다. 1-A, 2-B, 3-C, 4-D, 5-E, 6-F&lt;/p&gt;

&lt;p&gt;그리고, 어느 한 쪽을 주사위의 밑면으로 한다면 그 반대편 의 index는 다음과 같다. 1-6, 2-4, 3-5&lt;/p&gt;

&lt;p&gt;1번에서 먼저 1번 주사위를 선택한다. 그 다음부터는 주사위를 쌓는 방향을 바꿀수 없다. 첫 주사위의 방향대로 나머지 주사위의 옆면의 수가 정해진다.&lt;/p&gt;

&lt;p&gt;이게 DFS가 맞는지는 모르겠지만 1번주사위부터 6번주사위까지 경우의 수를 한 번씩 모두 구하는 것이라고 생각해서 DFS라고 이름지었다.&lt;/p&gt;

&lt;p&gt;함수의 실행은 대략 이렇게 이루어진다.&lt;/p&gt;

&lt;p&gt;먼저 주사위를 놓으면 반대편 주사위까지는 사용을 못한다.&lt;/p&gt;

&lt;p&gt;나머지 주사위 값 중에서 최댓값을 구해 더하고, 다음 주사위로 넘어간다. 반대편 주사위의 값을 다음 재귀로 넘겨준다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;주사위 개수를 읽어와 변수에 저장한다. 주사위 정보는 2차원 배열을 생성하여 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;i를 1부터 6까지 반복한다. 여기서 1~6은 첫 번째 주사위의 바닥에 두는 수를 뜻한다. 반복할 때마다 dfs 메서드를 호출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dfs 메서드는 인자값으로 int 타입과 1차원 배열을 받는다. int 타입에는 바닥에 놓을 1번주사위의 값이, 배열에는 1번 주사위의 정보가 주어진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 6의 크기의 1차원 boolean 배열을 선언한다. 그 후, 인자값으로 받아온 주사위 정보를 탐색하여 해당 밸류를 가지고 있는 index를 찾아 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;규칙(1-6, 2-4, 3-5)대로, 밑면과 밑면의 대응되는 윗면을 visited 배열에서 방문처리한다. 해당 규칙은 따로 메서드(search 메서드)로 꺼내두었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1부터 6까지 반복한다. 만약 해당 위치가 이미 방문한 상태라면 continue하고, 아닐 경우 주사위의 나머지 값 중에서 최댓값을 구해 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 최댓값을 누적시키고 재귀호출한다. 재귀호출하는 인자값으로는 현재 놓여진 주사위의 윗면의 index, 그리고 다음 주사위의 배열을 인자값으로 넘겨준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기저조건으로는 cnt가 N-1이 되었을 때, 즉 N번 주사위까지 탐색이 되었을 때 재귀가 종료된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1번 dfs를 돌릴 때마다 1면을 바닥으로 했을 때의 최댓값이 나타난다. 즉, 6번 dfs를 돌리면서 최댓값을 저장하면 주사위 N개를 쌓아올릴때의 옆면의 최댓값을 구할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;구한 최댓값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_2116_주사위쌓기 {


	/* 규칙 깔리는 주사위의 윗면과 놓는 주사위의 밑면의 숫자가 같아야한다.
	 * ABCDEF 순으로 값이 주어짐. A는 윗면, F는 아랫면
	 * 순서는 1번 주사위부터 6번주사위까지 주어짐
	 * A-F, B-D, C-E가 윗면, 아랫면이 될 수 있다. 이 세가지 경우를 조사해
	 * 경우의 수 별로 나머지 주사위들의최댓값을 모아 출력하면 되지않을까
	 *  */
	static int max, sum, N;
	static int arr[][];
	static int cnt = 0;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		N = Integer.parseInt(in.readLine());
		arr = new int[N][6];
		StringTokenizer st;
		for(int i=0;i&amp;lt;N;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);
			for(int j=0;j&amp;lt;6;j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
			}
		}


		// 1-A, 2-B, 3-C, 4-D, 5-E, 6-F
		// 1-6, 2-4, 3-5
		// 1-6 제외
		// 1번에서 가장 작은 수를 먼저 바닥으로 쓰면 그 반대편의 수는 다음 사람은 못쓴다.
		// 굳이 가장 작은수를 바닥으로 쓸 필요없이 6만 남길 수 있으면 된다.
		// 먼저 1번 주사위를 선택한다.(숫자 자유)그 다음부터는 그냥 바꿀수 없이 정해짐
		// dfs를 해보자
		// 먼저 주사위를 놓으면 반대편 주사위까지는 사용을 못한다.
		// 나머지 주사위 값 중에서 최댓값을 구해 더하고, 다음 주사위로 넘어간다. 반대편 주사위의 값을 다음 재귀로 넘겨준다.
		for(int i=1;i&amp;lt;=6;i++) {
			sum = 0;
			cnt = 0;
			dfs(i,arr[0]);
			max = Math.max(max, sum);
		}
		System.out.println(max);
	}

	public static void dfs(int value,int dice[]) {



		int index = 0;

		boolean[] visited = new boolean[6];

		for(int i=0;i&amp;lt;6;i++) {
			if(dice[i] == value) {
				index = i;
//				System.out.println(i);
			}
		}

		visited[index] = true;
		visited[search(index)] = true;
//		System.out.println(index+&quot;:&quot;+search(index)+&quot;:&quot;+value+&quot;:&quot;+cnt);
		int max = 0;
		for(int i=0;i&amp;lt;6;i++) {
			if(visited[i] == true) {
				continue;
			}
			max = Math.max(max, dice[i]);
		}

//		System.out.println(Arrays.toString(visited));

		sum = sum + max;

		if(cnt == N-1) {
//			System.out.println(sum);
			return;
		}

		dfs(dice[search(index)],arr[++cnt]);

	}


	public static int search(int index) {

		switch(index) {
		case 0:
			return 5;
		case 1:
			return 3;
		case 2:
			return 4;
		case 3:
			return 1;
		case 4:
			return 2;
		case 5:
			return 0;
		}

		return -1;
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 주사위쌓기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1697_숨바꼭질_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1697" rel="alternate" type="text/html" title="BOJ_1697_숨바꼭질_JAVA" />
      <published>2022-02-25T09:00:00+09:00</published>
      <updated>2022-02-25T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1697</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1697">&lt;h2 id=&quot;문제--숨바꼭질&quot;&gt;문제 : 숨바꼭질&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1697&quot;&gt;BOJ_1697_숨바꼭질&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;좌표를 x 한 가지만 사용하는 BFS 탐색 문제이다. 이 문제는 처음에 BFS를 사용하지 않고 풀어보려 했지만 조건문이 너무 복잡해져서 포기했다.&lt;/p&gt;

&lt;p&gt;문제 자체는 간단하다 N과 K가 주어지고 N에서 +1 하거나, -1하거나 *2하여 K와 N을 같게 만드는 최소 시간을 구하면 된다. 따라서 BFS를 통해서 위의 연산을 계속해서 실행해주고, K의 위치에 처음 도착했을 때의 깊이가 최소시간이 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;BFS에 사용할 Node 클래스를 하나 만들었다. 멤버변수로는 x좌표와 bfs의 깊이를 담을 int변수가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 값을 읽어들여 N과 K int형 변수에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 방문 범위의 최댓값인 100001으로 생성하여 bfs에 인자값으로 넘겨 호출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS는 다른 문제와 유사하게 진행된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N을 좌표로 하는 Node를 생성하여 Queue에 추가한다. visited 배열의 N번째 값을 방문처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐가 전부 빌 때까지 반복한다. Queue에서 poll하여 노드에 할당한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;+연산, -연산 *2연산을 배열에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3번 반복하는데, 위의 연산을 한번 씩 실행하여 queue에 추가해준다. 해당 구문은 해당하는 값이 10만보다 작거나 같을 때, 또는 음수가 아닐 때, 그리고 해당 위치를 방문한 적이 없을 때에만 수행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복의 종료조건으로 큐에서 꺼낸 node의 좌표가 K와 같다면 해당 node의 깊이(depth)를 전역변수 cnt에 저장하고 return한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bfs가 끝난 후, cnt값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_1697_숨바꼭질 {
	static int N, K, cnt;

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		K = Integer.parseInt(st.nextToken());

		bfs(new boolean[100001]);
		System.out.println(cnt);

	}

	static void bfs(boolean[] visited) {

		Queue&amp;lt;Node2&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();

		queue.offer(new Node2(N, 0));
		visited[N] = true;
		while (!queue.isEmpty()) {

			Node2 node = queue.poll();

			if (node.x == K) {
				cnt = node.depth;
				return;
			}


			int[] next = { node.x -1, node.x + 1, node.x*2 };

			for (int i = 0; i &amp;lt; 3; i++) {
				// 범위 체크 확실히 하자
				if (next[i] &amp;lt;= 100000 &amp;amp;&amp;amp; next[i] &amp;gt;= 0 &amp;amp;&amp;amp; !visited[next[i]]) {
					visited[next[i]] = true;
					queue.offer(new Node2(next[i], node.depth + 1));
				}
			}
		}
	}
}

class Node2 {

	int x;
	int depth;

	public Node2(int x, int depth) {
		super();
		this.x = x;
		this.depth = depth;
	}
}


// 경우의수 따지기 실패
//while(N != K) {
//	// N이 K보다 크면 N--
//	if(N &amp;gt; K) {
//		N--;
//	}
//	// N*2배가 K보다 작으면 무조건 2배
//	else if(N*2 &amp;lt; K ) {
//		N = N *2;
//	//	N*2가  K까지의 거리보다 크면서 N*2보다 N+1에서 K까지의 거리가 더 멀 때
//	}else if(N*2 &amp;gt; K) {
//		int M = N*2-K;
//		int temp = N;
//		int incnt = 0;
//		while(true) {
//			if(temp*2 - K &amp;gt; 2) {
//				temp--;
//				incnt++;
//			}else {
//				if(incnt &amp;lt; M) {
//					cnt = cnt + incnt;
//					N = temp;
//				}else {
//					N = N*2;
//				}
//				break;
//			}
//		}
//		N = N * 2;
// N*2가 K까지 거리보다 크지만 N+1에서 K까지의 거리가 더 가까울때

//	System.out.println(N);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 숨바꼭질</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2206_벽부수고이동하기_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2206" rel="alternate" type="text/html" title="BOJ_2206_벽부수고이동하기_JAVA" />
      <published>2022-02-25T09:00:00+09:00</published>
      <updated>2022-02-25T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2206</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2206">&lt;h2 id=&quot;문제--벽-부수고-이동하기&quot;&gt;문제 : 벽 부수고 이동하기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2206&quot;&gt;BOJ_2206_벽부수고이동하기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;BFS를 통한 최단경로 구하는 문제와 유사하다. 이 문제를 풀기 전에 어둠의 경로로 3차원 배열을 사용해야 문제가 풀린다는 정보를 입수했다. 나는 3차원 배열을 사용하지 않고 풀어보려고 했지만 실패했다.&lt;/p&gt;

&lt;p&gt;코드 자체는 기존 BFS 문제를 풀 때와 크게 다르지 않다. 바뀌는 점은 노드로 사용할 클래스의 멤버 변수에 벽을 부쉈는지 부수지 않았는지 확인하는 boolean 변수를 하나 추가한 것과, 방문정보를 체크하는 visited boolean 배열에 차원을 하나 늘려 벽을 부순 상태와 부수지 않은 상태의 공간을 분리해주는 부분이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;BFS에 사용할 Node 클래스를 하나 만들었다. 멤버변수로는 x,y좌표와 bfs의 깊이를 담을 int변수, 벽 파괴 여부를 저장할 boolean변수가 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 값을 읽어들여 2차원 배열을 생성해 저장한다. 크기는 N*M크기이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;0,0에서 N,M까지 이동하는 문제이므로, bfs를 호출하는데, Node를 하나 생성해주고,(좌표와 깊이는 0으로, 벽은 부수지 않았으니 false로 생성한다.) boolean 3차원 배열을 생성하여 인자값으로 보내준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS 내부에서는 일반적인 4방탐색 BFS와 동일하게 동작한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4방탐색을 하는 부분에서, 이미 벽을 부순 경우, 벽을 아직 부수지 않은 경우로 나누어서 큐에 offer해준다. 이미 벽을 부순 경우라면, 3차원을 구분하는 index를 1로 바꾸어 공간을 전환시켜준다. 만약 아직 벽을 부수지 않은 상태인데 1을 만난다면 벽을 부순다. 역시 3차원을 구분하는 index를 1로 바꾸어준 뒤 visit 처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;종료조건을 만족했을 때(좌표가 N,M에 도달했을 때) 종료 노드의 depth를 리턴한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 모든 탐색을 완료했는데도 N,M에 도달하지 못했다면 -1를 리턴한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;호출부로 돌아와서, 리턴받은 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_2206_벽부수고이동하기 {
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static int N, M;
	static char[][] arr;
	static boolean check;

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());

		arr = new char[N][M];

		for (int i = 0; i &amp;lt; N; i++) {
			arr[i] = in.readLine().toCharArray();
		}

		int A1 = bfs(new Node(0, 0, 1, false), new boolean[N][M][2]);

		System.out.println(A1);

	}

	static int bfs(Node node, boolean[][][] visited) {

		Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();

		queue.offer(node);

		visited[node.x][node.y][0] = true;
		while (!queue.isEmpty()) {

			Node temp = queue.poll();
			if (temp.x == N - 1 &amp;amp;&amp;amp; temp.y == M - 1) {
				return temp.depth;
			}

			for (int d = 0; d &amp;lt; 4; d++) {
				int dx = temp.x + dir[d][0];
				int dy = temp.y + dir[d][1];
				if (dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; N &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; M) {
					if (arr[dx][dy] == '0') {
						if (!temp.crash &amp;amp;&amp;amp; !visited[dx][dy][0]) {
							//
							visited[dx][dy][0] = true;
							queue.offer(new Node(dx, dy, temp.depth + 1, false));
						} else if (temp.crash &amp;amp;&amp;amp; !visited[dx][dy][1]) {
							visited[dx][dy][1] = true;
							queue.offer(new Node(dx, dy, temp.depth + 1, true));
						}
					} else if (arr[dx][dy] == '1') {
						if (!temp.crash) {
							queue.offer(new Node(dx, dy, temp.depth + 1, true));
							visited[dx][dy][1] = true;
						}

					}
				}
			}
		}
		return -1;
	}
}

class Node {

	int x;
	int y;
	boolean crash;
	int depth;

	public Node(int x, int y, int depth) {
		super();
		this.x = x;
		this.y = y;
		this.depth = depth;
	}

	public Node(int x, int y, int depth, boolean crash) {
		super();
		this.x = x;
		this.y = y;
		this.depth = depth;
		this.crash = crash;
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 벽 부수고 이동하기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_17473_단어뒤집기2_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-17473" rel="alternate" type="text/html" title="BOJ_17473_단어뒤집기2_JAVA" />
      <published>2022-02-24T09:00:00+09:00</published>
      <updated>2022-02-24T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-17473</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-17473">&lt;h2 id=&quot;문제--단어-뒤집기-2&quot;&gt;문제 : 단어 뒤집기 2&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/17473&quot;&gt;BOJ_17473_단어뒤집기2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;스택을 이용하면 문자열은 쉽게 뒤집을 수 있다. 괄호 안에 있는 문자열은 뒤집으면 안되는 것을 주의하자. 공백을 기준으로 뒤집기 때문에 공백이 나올 때까지 스택에 쌓다가, 공백을 만나면 스택에서 모두 POP 하는 방식으로 구현해보자.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;문자열을 읽어와 toCharArray 메서드를 이용해 char 배열로 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 길이만큼 반복한다. For문 안에서 가장 먼저 확인해야 하는 것은 ‘&amp;lt;’, 꺽쇠 여부이다. 현재 탐색하는 문자가 여는 꺽쇠를 만날 경우, 이전까지 push되어있던 스택을 모두 비워 StringBuilder에 추가한다. 추가로 check boolean 값을 false로 바꾼다.(단어 뒤집지 않는 flag 역할)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;두 번째로 스택에 쌓는 조건문이다. check가 true라면 현재 문자를 stack에 push한다. check가 false라면 스택에 push하지 않고 바로 StringBuilder에 append한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;닫는 꺽쇠 ‘&amp;gt;’ 를 만나는 조건문은 그 다음이다. 만약 닫는 꺽회를 만나면 check를 true로 바꿔준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음은 공백문자를 만났을 때의 조건문이다. 공백문자를 만났을 때, check가 true라면, 스택을 모두 비워 StringBuilder에 append 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마지막으로 현재 문자가 문자열의 끝일 때의 조건문이다. 스택에 남아있는 데이터들을 모두 pop 하여 StringBuilder에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 완성된 StringBuilder를 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;
import java.util.StringTokenizer;

public class BOJ_17413_단어뒤집기 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		char[] chars = in.readLine().toCharArray();

		StringBuilder sb = new StringBuilder();

		Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();

		boolean check = true;

		for (int i = 0; i &amp;lt; chars.length; i++) {

			if (chars[i] == '&amp;lt;') {
				while (!stack.isEmpty()) {
					sb.append(stack.pop());
				}
				check = false;
			}

			if (!check) {
				sb.append(chars[i]);
			} else {
				stack.push(chars[i]);
			}


			if (chars[i] == '&amp;gt;') {
				check = true;
			}

			if (chars[i] == ' ' &amp;amp;&amp;amp; check) {
				stack.pop();
				while (!stack.isEmpty()) {
					sb.append(stack.pop());
				}
				sb.append(' ');

			} else if (i == chars.length - 1 &amp;amp;&amp;amp; check) {
				while (!stack.isEmpty()) {
					sb.append(stack.pop());
				}
			}

		}

		System.out.println(sb);
	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 단어 뒤집기 2</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_7576_토마토_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-7576" rel="alternate" type="text/html" title="BOJ_7576_토마토_JAVA" />
      <published>2022-02-24T09:00:00+09:00</published>
      <updated>2022-02-24T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-7576</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-7576">&lt;h2 id=&quot;문제--토마토&quot;&gt;문제 : 토마토&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/7576&quot;&gt;BOJ_7576_토마토&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;BFS와 Depth를 이용하면 간단하게 풀 수 있는 문제였다. 나는 큐의 작동방식을 잊어버려 너무 복잡한 방식으로 접근하다가 시간을 엄청 허비했다.&lt;/p&gt;

&lt;p&gt;큐는 선입선출 방식이다. 따라서 2차원 배열에 존재하는 토마토를 순서대로 큐에 집어넣은 뒤 BFS를 실행하면, 자동으로 먼저 들어간 토마토가 탐색을 하고 다음 탐색 노드가 큐의 마지막으로 들어간다. 미리 큐에 집어넣어두면 자동적으로 모든 토마토로부터의 탐색이 이루어지는 것이다. 나는 이 부분을 놓쳐서 큐를 각각 리스트로 만들어서 해결하려 했다.&lt;/p&gt;

&lt;p&gt;아무튼, 문제풀이는 위와 같은 방법으로 하면 된다. 배열을 탐색하며 큐에 토마토의 위치와 깊이를 저장하고, bfs를 통해 모든 탐색이 완료 되었을 때 Depth 최댓값을 구한다. 그 후 배열을 다시 탐색하여 익지 않은 토마토(0)이 있다면 -1을 출력하고, 그렇지 않다면 저장한 Depth를 출력한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Node클래스를 생성한다. Node 클래스는 멤버변수로 x,y좌표와 depth 깊이를 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기 M과 N을 입력받아 저장하고, N*M 크기의 2차원 배열을 하나 생성한다. 같은 크기의 방문상태를 확인하는 배열, 그리고 토마토를 담을 queue도 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기만큼 반복한다. 배열에 값을 할당하면서, 그 값이 1(토마토)이라면 해당 토마토의 위치 Node를 생성해 큐에 offer한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS 메서드를 수행한다. BFS 메서드는 큐를 이용해 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐가 전부 빌 때까지 반복한다. 먼저 Node를 생성하여 큐에서 poll 하여 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;해당 노드의 위치를 방문처리하고, 4방탐색을 진행한다. 만약 탐색이 가능한 상태라면 그 위치를 방문처리, 배열의 값을 1로 바꾸고, 탐색할 위치에 depth를 1 증가시켜 새로운 Node를 생성해 큐에 offer한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1번 반복이 진행될 때마다 depth의 max값을 answer 변수에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이종료된 후 배열을 탐색한다. 배열에 0이 존재한다면 -1을 출력하고 프로그램을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그렇지 않다면 answer를 -1 해주고 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_7576_토마토2 {
	static int M, N, arr[][];
	static Queue&amp;lt;Node&amp;gt; queue;
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static boolean[][] visited;
	static int answer;

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		M = Integer.parseInt(st.nextToken());

		N = Integer.parseInt(st.nextToken());

		arr = new int[N][M];
		queue = new LinkedList&amp;lt;&amp;gt;();
		visited = new boolean[N][M];
		for (int i = 0; i &amp;lt; N; i++) {
			st = new StringTokenizer(in.readLine(), &quot; &quot;);
			for (int j = 0; j &amp;lt; M; j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());

				if (arr[i][j] == 1) {
					queue.offer(new Node(i, j, 1));
				}
			}
		}



		bfs();
		for(int i=0;i&amp;lt;N;i++) {
			for(int j=0;j&amp;lt;M;j++) {
				if(arr[i][j] == 0) {
					System.out.println(-1);
					return;
				}
			}
		}
		System.out.println(answer-1);
	}

	static void bfs() {

		while (!queue.isEmpty()) {

			Node node = queue.poll();

			answer = Math.max(answer, node.depth);

			visited[node.x][node.y] = true;

			for (int d = 0; d &amp;lt; 4; d++) {
				int dx = node.x + dir[d][0];
				int dy = node.y + dir[d][1];

				if (dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; N &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; M) {
					if (arr[dx][dy] == 0 &amp;amp;&amp;amp; !visited[dx][dy]) {
						visited[dx][dy] = true;
						arr[dx][dy] = 1;
						queue.offer(new Node(dx, dy, node.depth + 1));
					}
				}
			}
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 토마토</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2178_미로탐색_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2178" rel="alternate" type="text/html" title="BOJ_2178_미로탐색_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2178</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2178">&lt;h2 id=&quot;문제--미로탐색&quot;&gt;문제 : 미로탐색&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2178&quot;&gt;BOJ_2178_미로탐색&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;오늘 앞서 풀었던 아기 상어 문제에 있는 최단 거리를 구하는 BFS의 알고리즘을 그대로 사용해서 풀 수 있었다. 배열의 시작점부터 끝까지 BFS으로 탐색하면서 가장 먼저 목적지까지 도달하는 순간 그때의 거리를 출력하면 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;값을 읽어와 N*M 크기의 배열을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;방문정보를 저장할 동일한 크기의 boolean 배열도 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열에 값을 읽어와 저장하고, BFS를 호출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS에서 사방탐색을 통해 이동할 수 있는 경우를 확인하고, 방문하지 않은 곳이면서 이동이 가능할 경우 이동한다. 배열에서 벽이 0이므로, 0이 아닐경우 또는 1일경우 이동가능한 것으로 본다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탐색 도중 목적지에 도달한 최초 거리를 출력하고 return 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_2178_미로탐색 {


	static char[][] arr;
	static boolean[][] isVisited;
	static int N,M;
	static int[][] dir = { {1,0},{-1,0},{0,1},{0,-1} };
	static int cnt;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		M = Integer.parseInt(st.nextToken());
		arr = new char[N][M];
		isVisited = new boolean[N][M];
		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = in.readLine().toCharArray();
		}

		bfs(0,0);		


	}

	static void bfs(int x, int y) {

		Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();

		queue.offer(new int[]{x,y,0});

		isVisited[x][y] = true;

		while(!queue.isEmpty()) {


			int[] pos = queue.poll();
			if(pos[0] == N-1 &amp;amp;&amp;amp; pos[1] == M-1) {
				System.out.println(++pos[2]);
				break;
			}
			for(int d=0;d&amp;lt;4;d++) {
				int dx = pos[0] + dir[d][0];
				int dy = pos[1] + dir[d][1];
				if(dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; N &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; M) {
					if(arr[dx][dy] == '1' &amp;amp;&amp;amp; isVisited[dx][dy] == false) {
						isVisited[dx][dy] = true;
						queue.offer(new int[] {dx,dy,pos[2]+1});
					}
				}
			}

		}



	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 미로탐색</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_16236_아기 상어_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-16236" rel="alternate" type="text/html" title="BOJ_16236_아기 상어_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-16236</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-16236">&lt;h2 id=&quot;문제--아기-상어&quot;&gt;문제 : 아기 상어&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/16236&quot;&gt;BOJ_16236_아기상어&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;혼자 풀었던 방식의 개요는 아래와 같다.&lt;/p&gt;

&lt;p&gt;한 번 이동시마다 1초씩 증가&lt;/p&gt;

&lt;p&gt;배열을 탐색하며 상어의 크기보다 작은 물고기들을(먹을 수 있는 물고기) 리스트에 넣는다 집어넣는 값은 좌표.&lt;/p&gt;

&lt;p&gt;거리가 같다면 높이가 높은 쪽, 높이도 같다면 가장 왼쪽부터 먹는다.&lt;/p&gt;

&lt;p&gt;상어는 몸 크기가 2로 시작하며, 자신보다 크기가 큰 물고기는 지나가지 못한다 (벽 취급)&lt;/p&gt;

&lt;p&gt;리스트에서 하나씩 꺼내며 거리가 가장 짧은 좌표를 구한다. ( 이 때 먹을 수 있는지 없는지도 판단해야겠다. 만약 작은물고기가 있을 지라도 경로상 도달하지 못하면 못먹는 물고기이다.)&lt;/p&gt;

&lt;p&gt;해당 위치로 이동하고 거리만큼 시간을 더해준다.&lt;/p&gt;

&lt;p&gt;BFS 탐색을 통하면 현재 상어의 위치부터 물고기까지의 최단거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;한 번 물고기를 먹은 후 리스트를 초기화하고, 다시 배열을 탐색하며 물고기의 좌표를 리스트에 저장한다.&lt;/p&gt;

&lt;p&gt;위의 방식으로 정답을 맞추긴 했으나, 다른 풀이에 비해서 시간은 4~5배, 메모리는 8~9배 정도로 자원사용량이 너무 컸다. 한 번 이동할 때마다 리스트 새로 생성하고, 배열을 다시 탐색하면서 리스트에 값 집어넣고 하는 과정들이 시간과 메모리 소모가 너무 컸던 것으로 예상된다.&lt;/p&gt;

&lt;p&gt;이러한 문제의 해결 방법으로 우선순위 큐라는 것을 알게 되었다. 또한 로직도 배열 기준이 아닌 상어를 중심으로 움직이도록 일부 수정했다.&lt;/p&gt;

&lt;p&gt;이전처럼 배열을 탐색하며 물고기 위치를 저장해두는 것이 아니라, 상어의 위치만 기억해두고 BFS를 수행한다. BFS에서, 상어는 1번 움직일때마다 자신이 가지고 있는 dist값을 1씩 증가시키면서 이동한다.&lt;/p&gt;

&lt;p&gt;BFS 탐색 도중 만나는 물고기에 대해 먹을 수 있는 물고기인지 확인 후, 먹을 수 있는 물고이라면 상어의 dist값을 부여하고 생성하여 우선순위 큐에 추가한다.&lt;/p&gt;

&lt;p&gt;우선순위큐(오름차순)는 큐에 들어있는 값을 자동으로 오름차순으로 꺼내준다. 큐의 우선순위를 정하는 부분을 아래 문구에 맞게 CompareTo 메서드를 재정의 한다.&lt;/p&gt;

&lt;p&gt;“거리가 같다면 높이가 높은 쪽, 높이도 같다면 가장 왼쪽부터 먹는다.”&lt;/p&gt;

&lt;p&gt;이렇게 우선순위 큐에 먹을 수 있는 생선을 집어넣고, 가장 먼저 poll한 값이 현재 상어의 위치에서 가장 가까운 물고이의 위치이다.&lt;/p&gt;

&lt;p&gt;이후 재귀호출을 하여 다음 먹이를 계속해서 찾아주고, BFS 탐색을 한 뒤에 우선순위큐에 어떠한 값도 들어가 있지 않다면(기저조건) 더이상 먹을 수 있는 물고기가 없다는 뜻이므로 return한다.&lt;/p&gt;

&lt;p&gt;우선순위큐를 사용하자 코드가 훨씬 간결해졌고, 로직변경과 더해져 수행속도, 메모리 사용량이 대폭 감소했다.&lt;/p&gt;

&lt;h2 id=&quot;소스-코드--리스트-사용&quot;&gt;소스 코드 : 리스트 사용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

/*
 	거리
	|x-x1| + |y-y2|

	거리가 같다면 가장 왼쪽

	한 번 이동시마다 1초씩 증가
	배열을 탐색하며 상어의 크기보다 작은 물고기들을 리스트에 넣는다 집어넣는 값은 좌표

	리스트에서 하나씩 꺼내며 거리가 가장 짧은 좌표를 구한다. ( 이 때 먹을 수 있는지 없는지도 판단해야겠다)

	해당 위치로 이동하고 거리만큼 시간을 더해준다.

	위 내용을 반복하려고 했지만 안되네 자기보다 큰 물고기는 못지나가기 때문에 거리를 계산하지 말고 움직여야할듯.... 이거 어케하지? -&amp;gt; 찾아보니까 BFS 탐색을 통하면 최단거리를 구할 수 있다. 벽부수고이동하기 참고.
*/

class Distance implements Comparable&amp;lt;Distance&amp;gt; {
	int x;
	int y;
	int body;
	int dist;
	public Distance(int x, int y, int body) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
	}
	public Distance(int x, int y, int body, int dist) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
		this.dist = dist;
	}
	@Override
	public int compareTo(Distance o) {
		// TODO Auto-generated method stub
		return 0;
	}

}

public class BOJ_16236_아기상어 {

	static int N;
	static int[][] arr;
	static List&amp;lt;Distance&amp;gt; list;
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static int min;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		N = Integer.parseInt(in.readLine());

		arr = new int[N + 1][N + 1];

		list = new ArrayList&amp;lt;&amp;gt;();
		StringTokenizer st;

		Distance shark = null;
		// 배열에 값 할당, 초기에 상어가 먹을 수 있는 값의 위치 저장하기.
		for (int i = 1; i &amp;lt;= N; i++) {
			st = new StringTokenizer(in.readLine(), &quot; &quot;);
			for (int j = 1; j &amp;lt;= N; j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if (arr[i][j] == 1) {
					list.add(new Distance(i, j, arr[i][j]));
				}
				if (arr[i][j] == 9) {
					shark = new Distance(i, j, 2);
				}
			}
		}

		// 먹을 수 있는 먹이가 없을 때
		if (list.size() == 0) {
			System.out.println(0);
			return;
		}
		int answer =0;
		int cnt = 0;
		while (true) {
			Distance minfish = null;

			min = Integer.MAX_VALUE;
			for (int i = 0, n = list.size(); i &amp;lt; n; i++) {
				Distance temp = bfs(shark, list.get(i), new boolean[N+1][N+1]);

				if(temp.dist == 0) {
					continue;
				}

				if(temp.dist &amp;lt; min) {
					min = temp.dist;
					minfish = temp;
				}else if(temp.dist == min) {
					if(temp.x &amp;lt; minfish.x) {
						min = temp.dist;
						minfish = temp;
					}else if(temp.x == minfish.x) {
						if(temp.y &amp;lt; minfish.y) {
							min = temp.dist;
							minfish = temp;
						}
					}
				}
			}

			if(minfish == null) {
				System.out.println(answer);
				return;
			}

			cnt++;

			answer += minfish.dist;
//			System.out.println(answer);
//			for(int i=0;i&amp;lt;N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
//			}
			arr[shark.x][shark.y] = 0;
			arr[minfish.x][minfish.y] = 9;
			shark.x = minfish.x;
			shark.y = minfish.y;
			for(int i=1;i&amp;lt;=N;i++) {
				for(int j=1;j&amp;lt;=N;j++) {
					System.out.print(arr[i][j]+&quot; &quot;);
				}
				System.out.println();
			}
			System.out.println(&quot;dist:&quot;+minfish.dist);
			System.out.println(&quot;answer: &quot;+answer);
			System.out.println(&quot;====================&quot;);
			System.out.println();
			if(cnt == shark.body) {
				shark.body++;
				cnt = 0;
			}

			list = new ArrayList&amp;lt;&amp;gt;();

			for(int i =1 ;i&amp;lt;=N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
				for(int j=1;j&amp;lt;=N;j++) {
					if(arr[i][j] != 0 &amp;amp;&amp;amp; arr[i][j] &amp;lt; shark.body) {
						list.add(new Distance(i,j,arr[i][j]));
					}
				}
			}
		}

	}

	static Distance bfs(Distance shark, Distance fish, boolean[][] visited) {

		Queue&amp;lt;Distance&amp;gt; queue = new LinkedList&amp;lt;Distance&amp;gt;();

		int x;
		int y;

		queue.add(new Distance(shark.x,shark.y, shark.body));

		visited[shark.x][shark.y] = true;

		int sharkBody = shark.body;

		while(!queue.isEmpty()) {

			Distance point = queue.poll();
			x = point.x;
			y = point.y;

			if(x == fish.x &amp;amp;&amp;amp; y == fish.y) {
				return point;
			}

			for(int d=0;d&amp;lt;4;d++) {
				int dx = x + dir[d][0];
				int dy = y + dir[d][1];
				if(dx &amp;gt; 0&amp;amp;&amp;amp; dx&amp;lt;= N &amp;amp;&amp;amp; dy &amp;gt; 0 &amp;amp;&amp;amp; dy &amp;lt;= N) {
					if(sharkBody &amp;gt;= arr[dx][dy] &amp;amp;&amp;amp; !visited[dx][dy]) {
						visited[dx][dy] = true;
						queue.offer(new Distance(dx, dy, sharkBody,point.dist+1));
					}
				}
			}
		}
		// 경로가 없는 경우
		return new Distance(0,0,0);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;소스-코드--우선순위-큐-사용&quot;&gt;소스 코드 : 우선순위 큐 사용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

/*
 	거리
	|x-x1| + |y-y2|

	거리가 같다면 가장 왼쪽

	한 번 이동시마다 1초씩 증가
	배열을 탐색하며 상어의 크기보다 작은 물고기들을 리스트에 넣는다 집어넣는 값은 좌표

	리스트에서 하나씩 꺼내며 거리가 가장 짧은 좌표를 구한다. ( 이 때 먹을 수 있는지 없는지도 판단해야겠다)

	해당 위치로 이동하고 거리만큼 시간을 더해준다.

	위 내용을 반복하려고 했지만 안되네 자기보다 큰 물고기는 못지나가기 때문에 거리를 계산하지 말고 움직여야할듯.... 이거 어케하지? -&amp;gt; 찾아보니까 BFS 탐색을 통하면 최단거리를 구할 수 있다. 벽부수고이동하기 참고.
*/

class Distance implements Comparable&amp;lt;Distance&amp;gt; {
	int x;
	int y;
	int body;
	int dist;
	public Distance(int x, int y, int body) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
	}
	public Distance(int x, int y, int body, int dist) {
		super();
		this.x = x;
		this.y = y;
		this.body = body;
		this.dist = dist;
	}
	@Override
	public int compareTo(Distance o) {
		// TODO Auto-generated method stub
		return 0;
	}

}

public class BOJ_16236_아기상어 {

	static int N;
	static int[][] arr;
	static List&amp;lt;Distance&amp;gt; list;
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static int min;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		N = Integer.parseInt(in.readLine());

		arr = new int[N + 1][N + 1];

		list = new ArrayList&amp;lt;&amp;gt;();
		StringTokenizer st;

		Distance shark = null;
		// 배열에 값 할당, 초기에 상어가 먹을 수 있는 값의 위치 저장하기.
		for (int i = 1; i &amp;lt;= N; i++) {
			st = new StringTokenizer(in.readLine(), &quot; &quot;);
			for (int j = 1; j &amp;lt;= N; j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if (arr[i][j] == 1) {
					list.add(new Distance(i, j, arr[i][j]));
				}
				if (arr[i][j] == 9) {
					shark = new Distance(i, j, 2);
				}
			}
		}

		// 먹을 수 있는 먹이가 없을 때
		if (list.size() == 0) {
			System.out.println(0);
			return;
		}
		int answer =0;
		int cnt = 0;
		while (true) {
			Distance minfish = null;

			min = Integer.MAX_VALUE;
			for (int i = 0, n = list.size(); i &amp;lt; n; i++) {
				Distance temp = bfs(shark, list.get(i), new boolean[N+1][N+1]);

				if(temp.dist == 0) {
					continue;
				}

				if(temp.dist &amp;lt; min) {
					min = temp.dist;
					minfish = temp;
				}else if(temp.dist == min) {
					if(temp.x &amp;lt; minfish.x) {
						min = temp.dist;
						minfish = temp;
					}else if(temp.x == minfish.x) {
						if(temp.y &amp;lt; minfish.y) {
							min = temp.dist;
							minfish = temp;
						}
					}
				}
			}

			if(minfish == null) {
				System.out.println(answer);
				return;
			}

			cnt++;

			answer += minfish.dist;
//			System.out.println(answer);
//			for(int i=0;i&amp;lt;N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
//			}
			arr[shark.x][shark.y] = 0;
			arr[minfish.x][minfish.y] = 9;
			shark.x = minfish.x;
			shark.y = minfish.y;
			for(int i=1;i&amp;lt;=N;i++) {
				for(int j=1;j&amp;lt;=N;j++) {
					System.out.print(arr[i][j]+&quot; &quot;);
				}
				System.out.println();
			}
			System.out.println(&quot;dist:&quot;+minfish.dist);
			System.out.println(&quot;answer: &quot;+answer);
			System.out.println(&quot;====================&quot;);
			System.out.println();
			if(cnt == shark.body) {
				shark.body++;
				cnt = 0;
			}

			list = new ArrayList&amp;lt;&amp;gt;();

			for(int i =1 ;i&amp;lt;=N;i++) {
//				System.out.println(Arrays.toString(arr[i]));
				for(int j=1;j&amp;lt;=N;j++) {
					if(arr[i][j] != 0 &amp;amp;&amp;amp; arr[i][j] &amp;lt; shark.body) {
						list.add(new Distance(i,j,arr[i][j]));
					}
				}
			}
		}

	}

	static Distance bfs(Distance shark, Distance fish, boolean[][] visited) {

		Queue&amp;lt;Distance&amp;gt; queue = new LinkedList&amp;lt;Distance&amp;gt;();

		int x;
		int y;

		queue.add(new Distance(shark.x,shark.y, shark.body));

		visited[shark.x][shark.y] = true;

		int sharkBody = shark.body;

		while(!queue.isEmpty()) {

			Distance point = queue.poll();
			x = point.x;
			y = point.y;

			if(x == fish.x &amp;amp;&amp;amp; y == fish.y) {
				return point;
			}

			for(int d=0;d&amp;lt;4;d++) {
				int dx = x + dir[d][0];
				int dy = y + dir[d][1];
				if(dx &amp;gt; 0&amp;amp;&amp;amp; dx&amp;lt;= N &amp;amp;&amp;amp; dy &amp;gt; 0 &amp;amp;&amp;amp; dy &amp;lt;= N) {
					if(sharkBody &amp;gt;= arr[dx][dy] &amp;amp;&amp;amp; !visited[dx][dy]) {
						visited[dx][dy] = true;
						queue.offer(new Distance(dx, dy, sharkBody,point.dist+1));
					}
				}
			}
		}
		// 경로가 없는 경우
		return new Distance(0,0,0);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 아기 상어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_15686_치킨 배달_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-15686" rel="alternate" type="text/html" title="BOJ_15686_치킨 배달_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-15686</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-15686">&lt;h2 id=&quot;문제--치킨-배달&quot;&gt;문제 : 치킨 배달&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/15686&quot;&gt;BOJ_15686_치킨배달&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;N*N크기의 배열에 들어있는 값을 탐색하며 치킨집의 위치, 집의 위치를 각각 나누어 리스트에 저장한다.&lt;/p&gt;

&lt;p&gt;그 후, 치킨집의 개수에서 M개의 치킨집을 고르는 조합을 통해 가능한 치킨집의 경우의 수를 구한다.&lt;/p&gt;

&lt;p&gt;구해진 M개의 치킨집과 각각의 집의 최단 거리를 구해서 더한다.&lt;/p&gt;

&lt;p&gt;최단거리를 구해서 더한 값을 생성된 조합별로 비교해 그 중에서 가장 작은 값을 구하여 출력하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;좌표정보를 저장할 클래스 Vector을 생성한다. 해당 클래스는 x좌표, y좌표를 멤버 변수로써 가진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N*N 크기의 배열을 생성한다, 집의 정보를 저장할 리스트와, 치킨집의 정보를 저장할 리스트를 각각 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열에 주어진 값을 추가하는데, 해당하는 값이 1(집)이면 집 리스트에, 2(치킨집)이면 치킨집 리스트에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조합 메서드를 구현하여 적용한다. M개 이상의 치킨집에서 M개만큼 뽑는 조합을 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조합의 기저조건에서, 집 List 길이 * 구해진 치킨집의 개수만큼 이중반복문을 돌린다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;내부반복문에서 dist의 최소값을 먼저 구하고, 그것을 내부 통합 거리에 더해준다. 그리고, 그 바깥에서 내부통합거리의 최솟값을 구하는 로직을 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 조합에 대해 최소 거리를 구하는 작업이 끝난 후, 구해진 최소 통합 거리를 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;


class Vector{

	int x;
	int y;
	public Vector(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}


}

public class BOJ_15686_치킨배달 {


	static int N, M, arr[][];

	static ArrayList&amp;lt;Vector&amp;gt; chList;
	static ArrayList&amp;lt;Vector&amp;gt; hoList;
	static Vector[] chickens;
	static int totalDist = Integer.MAX_VALUE;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		N = Integer.parseInt(st.nextToken());


		M = Integer.parseInt(st.nextToken());



		arr = new int[N][N];
		chList = new ArrayList&amp;lt;&amp;gt;();
		hoList = new ArrayList&amp;lt;&amp;gt;();
		chickens = new Vector[M];

		for(int i=0;i&amp;lt;N;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);
			for(int j=0;j&amp;lt;N;j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if(arr[i][j] == 2) {
					chList.add(new Vector(i,j));
				}
				if(arr[i][j] == 1) {
					hoList.add(new Vector(i,j));
				}
			}
		}		

		comb(0,0);

		System.out.println(totalDist);
	}

	static void comb(int start, int cnt) {

		if(cnt == M) {
			int inTotalDist = 0;
			for(int i=0,n=hoList.size();i&amp;lt;n;i++) {
				int inMin = Integer.MAX_VALUE;
				for(int j=0;j&amp;lt;chickens.length;j++) {
					int row =  Math.abs(hoList.get(i).x - chickens[j].x);
					int col =  Math.abs(hoList.get(i).y - chickens[j].y);
					int dist = row + col;
					inMin = Math.min(inMin,dist);
				}
				inTotalDist += inMin;
			}
			totalDist = Math.min(totalDist, inTotalDist);
			return;
		}

		for(int i=start, n = chList.size();i&amp;lt;n;i++) {

			chickens[cnt] = new Vector(chList.get(i).x, chList.get(i).y);

			comb(i+1,cnt+1);
		}


	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 치킨 배달</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_11399_ATM_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-11399" rel="alternate" type="text/html" title="BOJ_11399_ATM_JAVA" />
      <published>2022-02-23T09:00:00+09:00</published>
      <updated>2022-02-23T09:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-11399</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-11399">&lt;h2 id=&quot;문제--atm&quot;&gt;문제 : ATM&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/11399&quot;&gt;BOJ_11399_ATM&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;오름차순 정렬한 뒤 모든 사람의 누적 시간의 합을 더해서 총 누적 시간을 출력하면 되는 간단한 문제이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;사람 수를 읽어올 변수, 사람별 대기 시간을 저장할 배열을 생성하고 값을 할당한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2중 반복하는데, 뒤에 사람이 늘어날 때마다 앞의 사람의 대기 시간을 누적하여 구할 수 있도록 내부 반복문은 1부터 점차적으로 증가하게끔 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 총 누적 대기 시간을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_11399_ATM {

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		int[] arr = new int[N];

		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}

		Arrays.sort(arr);

		/*
		    1
			12
			123
			1234
			12345
		*/
		int sum = 0;
		for(int i=0;i&amp;lt;N;i++) {
			for(int j=0;j&amp;lt;=i;j++) {
				sum = sum + arr[j];
			}
		}

		System.out.println(sum);

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : ATM</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2567_색종이2_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2567" rel="alternate" type="text/html" title="BOJ_2567_색종이2_JAVA" />
      <published>2022-02-22T21:00:00+09:00</published>
      <updated>2022-02-22T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2567</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2567">&lt;h2 id=&quot;문제--색종이2&quot;&gt;문제 : 색종이2&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2567&quot;&gt;BOJ_2567_색종이2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;이전에 풀었던 색종이 문제의 확장형이다. 100*100크기에 색종이를 겹치는 건 같지만, 넓이를 구했던 그 때와 달리 이번에는 둘레를 구해야 한다. 넓이를 구할 때는 배열 내부의 값을 모두 카운트하면 해결되는 문제였다.&lt;/p&gt;

&lt;p&gt;둘레를 구하는 법은 막상 떠올릴려고 하면 어려웠다. 하지만 배열을 한 번 출력해보니 실마리가 보였다.&lt;/p&gt;

&lt;p&gt;핵심은 1과 인접한 0의 개수였다. 색종이의 크기는 10*10이고 정사각형이다. 색종이를 모두 1로 채워넣는다고 할 때 색종이의 모서리는 항상 0과 맞닿아있다. 꼭짓점 부분은 2개의 0과 인접하고, 그 부분은 길이를 2로 칠 수 있다. 이를 토대로 유추했을 때, 색종이의 둘레는 배열을 탐색하여 값이 1인 노드와 인접해있는 0의 개수일 것이다. 다만, 배열을 100, 100으로 설정할 경우, 0만 체크하면 안되고 배열의 경계값도 주의해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;100*100 크기의 int 타입 2차원 배열을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;색종이의 좌표를 읽어들여 각 좌표별로 10*10만큼 1을 입력한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열 전체를 탐색하며 1과 인접한 0의 개수를 센다. 1과 인접한 곳이 배열의 경계일 경우에도 카운트를 더해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탐색이 종료된 후 카운트한 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_2567_색종이2 {
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());
		StringTokenizer st;


		// 100*100 크기 배열 생성
		int[][] arr = new int[100][100];

		// 주어진 좌표로부터 10*10만큼 1 집어넣기
		for(int i=0;i&amp;lt;N;i++) {
			st = new StringTokenizer(in.readLine());

			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());

			for(int j = a; j &amp;lt;a+10;j++) {
				for(int k = b;k&amp;lt;b+10;k++) {
					arr[j][k] = 1;
				}
			}
		}
		// 둘레를 저장할 변수
		int cnt = 0;

		// 배열 전체 탐색 하며 1 주변의 0의 개수를 세기, 1 주변이 배열의 경계일 경우도 cnt를 더해준다
		for(int i=0;i&amp;lt;100;i++) {
			for(int j=0;j&amp;lt;100;j++) {
				// 배열에서 1을 만나면
				if(arr[i][j] == 1) {
					// 4방탐색
					for(int d = 0; d &amp;lt; 4; d++) {
						int dx = i + dir[d][0];
						int dy = j + dir[d][1];
						// 배열의 경계를 체크하여, 1 주변이 배열의 경계라면 cnt를 1 더해준다.
						if(dx &amp;lt; 0 || dx &amp;gt;= 100 || dy &amp;lt; 0 || dy &amp;gt;= 100) {
							cnt++;
						}
						// 배열의 경계 안에 있을 때, 1 주변에 0이 있다면 cnt를 1 더해준다.
						if(dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; 100 &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; 100 &amp;amp;&amp;amp; arr[dx][dy] == 0) {
							cnt++;
						}
					}
				}
			}
		}

		System.out.println(cnt);
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 색종이2</summary>
      

      
      
    </entry>
  
</feed>
