<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hjs101.github.io/tag/boj/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hjs101.github.io/" rel="alternate" type="text/html" />
  <updated>2022-02-22T01:17:50+09:00</updated>
  <id>https://hjs101.github.io/tag/boj/feed.xml</id>

  
  
  

  
    <title type="html">hjs’s Blog | </title>
  

  
    <subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">BOJ_1759_암호만들기_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1759" rel="alternate" type="text/html" title="BOJ_1759_암호만들기_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1759</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1759">&lt;h2 id=&quot;문제--암호만들기&quot;&gt;문제 : 암호만들기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1759&quot;&gt;BOJ_1759_암호만들기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;백트래킹 문제인데, 조합을 이용해서 푸는 문제라고 한다. 나는 이런 내용을 순열로 풀고 나서 알게 되었다. 나는 순열을 구하면서 가지치기를 통해 원하는 값을 리스트에 넣고, 그 리스트를 정렬하여 사전순으로 만들었다.&lt;/p&gt;

&lt;p&gt;C 개의 알파벳으로부터 L개의 길이의 암호문을 구하는 문제이다. 암호의 조건으로는 2가지가 있는데, 1가지는 왼쪽의 알파벳부터 오른쪽으로 갈 수록 값이 증가한다는 것, abc는 가능하지만 bac는 불가능하다.&lt;/p&gt;

&lt;p&gt;2번째 조건은 알파벳의 모음(a,e,i,o,u)은 최소 1개 이상 암호문에 포함되어야하며, 자음은 최소 2개 이상 암호문에 포함되어야 한다는 조건이다.&lt;/p&gt;

&lt;p&gt;나는 암호에 순서가 있다고 생각하여 순열을 이용하여 풀이해주었다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 값을 저장할 변수들을 전역으로 선언해주었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;알파벳의 개수와 암호문의 길이를 읽어와 변수에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 문자열을 읽어들일 배열을 생성해 값을 할당하고,  암호문 경우의 수를 저장할 배열을 암호문의 길이 L의 크기로 생성했다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열을 통해 경우의 수를 구하는데, 가지치기의 조건을 둔다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가지치기의 조건은, 현재 알파벳이 다음 알파벳보다 작을 경우에만 재귀호출을 하도록 하는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열이 완성되면, 각 순열별로 자음 카운트와 모음 카운트를 저장할 변수를 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만들어진 순열을 탐색하는데, 알파벳이 모음이면 모음 카운트를 증가시키고, 자음이라면 자음 카운트를 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열의 순회가 끝나고, 모음카운트가 1 이상, 자음카운트가 2 이상이라면 해당하는 수열을 문자열로 만들어 String 타입 리스트에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열이 모두 구해진 후, String 리스트를 Collections.sort 메서드를 이용하여 정렬한 후 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;

public class BOJ_1759_암호만들기 {
	static int C;
	static int L;
	static char[] chars;
	static char[] answer;
	static StringBuilder sb = new StringBuilder();
	static List&amp;lt;String&amp;gt; strs = new ArrayList&amp;lt;&amp;gt;();
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		L = Integer.parseInt(st.nextToken());
		C = Integer.parseInt(st.nextToken());

		chars = new char[C];
		answer = new char[L];
		st = new StringTokenizer(in.readLine(),&quot; &quot;);
		for(int i=0;i&amp;lt;C;i++) {
			chars[i] = st.nextToken().charAt(0);
		}

		perm(0,0,' ');
		Collections.sort(strs);

		for(int i=0;i&amp;lt;strs.size();i++) {
			sb.append(strs.get(i)).append('\n');
		}
		System.out.print(sb);
	}

	public static void perm(int cnt, int flag, char n) {

		if(cnt == L) {
			int mCnt = 0;
			int jCnt = 0;
			for(int i=0;i&amp;lt;L;i++) {
				switch(answer[i]) {
				case 'a':
				case 'e':
				case 'i':
				case 'o':
				case 'u':
					mCnt++;
					break;
				default:
					jCnt++;
				}
			}
			if(mCnt &amp;gt;= 1 &amp;amp;&amp;amp; jCnt &amp;gt;= 2) {
				String str = &quot;&quot;;
				for(int i=0;i&amp;lt;L;i++) {
					str = str + answer[i];
				}
				strs.add(str);
			}
			return;
		}


		for(int i=0;i&amp;lt;C;i++) {
			if((flag &amp;amp; 1&amp;lt;&amp;lt;i) != 0) {
				continue;
			}
			answer[cnt] = chars[i];
			// 가지치기 1 현재 알파벳이 다음 알파벳보다 작을 경우에만 재귀,
			if(n &amp;lt; answer[cnt]) {
				perm(cnt+1,flag | 1&amp;lt;&amp;lt;i, answer[cnt]);
			}
		}

	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 암호만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1417_국회의원선거_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1417" rel="alternate" type="text/html" title="BOJ_1417_국회의원선거_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1417</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1417">&lt;h2 id=&quot;문제--국회의원선거&quot;&gt;문제 : 국회의원선거&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1417&quot;&gt;BOJ_1417_국회의원선거&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;배열의 최댓값을 구하면서 인덱스 값을 같이 저장한다. 다솜의 번호는 가장 첫 번째이므로, 최댓값의 인덱스가 첫 번째 번호라면 투표를 뺏어올 필요가 없으니 0이다.&lt;/p&gt;

&lt;p&gt;그렇지 않은 경우라면, 배열의 최댓값에서 투표 수를 1 꺼내서 다솜의 투표에 추가하면 된다.&lt;/p&gt;

&lt;p&gt;문제는 최댓값이 다솜과 같은 인원이 다수 있을 때인데, 이 상황에서는, 최대 투표값을 크거나 같은 것으로 설정하면 해결된다. 그 이유는 다솜은 무조건 첫 번째 후보이기 때문에, 자신과 같은 투표수의 뒷 후보가 있다면 자동으로 본인은 최대 득표자에서 벗어나게 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;선거의 총 참여 인원수를 읽어와 저장하고, 각 후보의 투표 수를 N개 크기의 배열에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다솜의 투표 수가 최대가 될때까지 반복하는 반복문을 돌린다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열을 순회하며 최대 득표자를 찾고, 만약 최댓값이 다솜이라면 반복문을 나간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다솜이 최대 득표자가 아니라면, 최대 득표 후보는 -1을 다솜은 +1을 시켜준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복문이 한 번 돌아갈 때마다 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 카운트 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BOJ_1417_국회의원선거 {
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());

		int arr[] = new int[N];

		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = Integer.parseInt(in.readLine());
		}
		int cnt = 0;
		// 다솜이 최댓값이 될때까지 반복
		while(true) {
			int max = 0;
			int maxIndex = 0;
			for(int i=0;i&amp;lt;N;i++) {
				// 표 중에 최댓값을 구한다. index도 같이 저장한다.
				if(max &amp;lt;= arr[i]) {
					max = arr[i];
					maxIndex = i;
				}
			}
			// 최댓값이 다솜이라면
			if(maxIndex == 0) {
				break;
			}
			arr[maxIndex]--;
			arr[0]++;
			cnt++;
		}

		System.out.println(cnt);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 국회의원선거</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1260_DFS와BFS_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1260" rel="alternate" type="text/html" title="BOJ_1260_DFS와BFS_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1260</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1260">&lt;h2 id=&quot;문제--dfs와bfs&quot;&gt;문제 : DFS와BFS&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1260&quot;&gt;BOJ_1260_DFS와BFS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;주어진 노드를 읽어들여 그래프를 만들고, 그 그래프를 DFS와 BFS를 이용한 순회 결과를 출력하면 되는 문제이다.&lt;/p&gt;

&lt;p&gt;BFS와 DFS는 아래 링크의 게시글을 참고하여 공부하였다.&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://better-tomorrow.tistory.com/entry/DFS-BFS-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0?category=456505&quot;&gt;DFS와 BFS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;인접 행렬을 통해 주어진 인접 상태 좌표를 읽어들여 그래프를 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS를 이용하여 먼저 그래프를 순회한다. 인자값으로 boolean 배열(노드 수만큼), 생성한 그래프 배열, 시작할 노드를 받는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐를 생성한다. 초기 노드를 방문처리하고 큐에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐가 모두 비어있을 때까지 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐에서 값을 꺼내어 StringBuilder에 저장한다. 그 후 배열의 크기만큼 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 해당 노드의 행에 아직 방문하지 않고, 인접한 노드가 있다면 큐에 해당 노드를 추가하고 방문처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS 이용한 순회가 끝나면, DFS 이용하여 순회를 한다. 인자값으로는 BFS와 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리하고 StringBuilder에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순회가 끝나면 StringBuilder에 저장한 문자열을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_1260_DFS와BFS {
	static StringBuilder sb;
	static int N;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));




		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		int M = Integer.parseInt(st.nextToken());

		int V = Integer.parseInt(st.nextToken());

		int[][] adjMatrix = new int[N+1][N+1];



		for(int i=0;i&amp;lt;M;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);
			int v1 = Integer.parseInt(st.nextToken());
			int v2 = Integer.parseInt(st.nextToken());
			adjMatrix[v1][v2] = 1;
			adjMatrix[v2][v1] = 1;
		}

		boolean[] visited = new boolean[N+1];
		Arrays.fill(visited, false);
		sb = new StringBuilder();
		// dfs
		dfs(V, visited, adjMatrix);
		sb.setLength(sb.length()-1);
		sb.append('\n');

		Arrays.fill(visited, false);

		bfs(V,visited, adjMatrix);

		System.out.println(sb);

	}
	public static void bfs(int v, boolean[] visited, int[][] adjMatrix) {

		Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();

		visited[v] = true;
		queue.offer(v);

		while(!queue.isEmpty()) {
			int current = queue.poll();

			sb.append(current + &quot; &quot;);

			for(int i=1;i&amp;lt;=N;i++) {
				if(!visited[i] &amp;amp;&amp;amp; adjMatrix[current][i] != 0) {
					queue.offer(i);
					visited[i] = true;
				}
			}
		}


		sb.setLength(sb.length()-1);

	}

	public static void dfs(int v, boolean[] visited, int[][] adjMatrix) {
		visited[v] = true;
		sb.append(v + &quot; &quot;);
		for(int i=1;i&amp;lt;=N;i++) {
			if(!visited[i] &amp;amp;&amp;amp; adjMatrix[v][i] != 0) {
				visited[i] = true;
				dfs(i, visited, adjMatrix);
			}
		}
	}



}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : DFS와BFS</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2060_바이러스_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2060" rel="alternate" type="text/html" title="BOJ_2060_바이러스_JAVA" />
      <published>2022-02-21T21:00:00+09:00</published>
      <updated>2022-02-21T21:00:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2060</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2060">&lt;h2 id=&quot;문제--바이러스&quot;&gt;문제 : 바이러스&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2060&quot;&gt;BOJ_2060_바이러스&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;DFS 또는 BFS를 이용하여 인접한 노드를 전체 순회하고 카운트 하면 되는 문제이다. 그래프 생성과 DFS, BFS중 한 가지라도 구현할 수 있다면 문제를 풀 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;인접 행렬을 통해 주어진 인접 상태 좌표를 읽어들여 그래프를 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS를 이용하여 인접 노드를 순회한다. DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다. 그리고 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순회가 끝나면 저장된 카운트 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_2060_바이러스 {
	static int N;
	static int cnt;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));


		N = Integer.parseInt(in.readLine());

		int C = Integer.parseInt(in.readLine());

		int[][] arr = new int[N+1][N+1];
		StringTokenizer st;
		for(int i=0;i&amp;lt;C;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);

			int from = Integer.parseInt(st.nextToken());

			int to = Integer.parseInt(st.nextToken());
			arr[from][to] = 1;
			arr[to][from] = 1;

		}

		dfs(arr,new boolean[N+1],1);


		System.out.println(cnt);
//		for(int i=1;i&amp;lt;=N;i++) {
//			System.out.println(Arrays.toString(arr[i]));
//		}

	}

	public static void dfs(int[][] arr, boolean[] isVisited, int V) {
		isVisited[V] = true;

		for(int i=1;i&amp;lt;=N;i++) {
			if(!isVisited[i] &amp;amp;&amp;amp; arr[V][i] == 1) {
				cnt++;
				dfs(arr, isVisited, i);
			}
		}

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 바이러스</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_9461_파도반수열_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-9461" rel="alternate" type="text/html" title="BOJ_9461_파도반수열_JAVA" />
      <published>2022-02-21T01:40:00+09:00</published>
      <updated>2022-02-21T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-9461</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-9461">&lt;h2 id=&quot;문제--파도반수열&quot;&gt;문제 : 파도반수열&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/9461&quot;&gt;BOJ_9461_파도반수열&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;삼각형이 나선으로 놓여져있고 변의 과정이고 어쩌고 규칙이 있기는 한데, 그림과 설명을 이용해서 수열을 이해하는것 보다 나열되어있는 숫자를 보고 알아채는 게 더 쉬웠다.&lt;/p&gt;

&lt;p&gt;1, 1, 1, 2, 2, 3, 4, 5, 7, 9&lt;/p&gt;

&lt;p&gt;이게 파도반 수열 P(1)부터 P(10)까지이다.&lt;/p&gt;

&lt;p&gt;기본값으로 P(1),P(2),P(3)은 1,1,1이다.&lt;/p&gt;

&lt;p&gt;P(4) =  P(4-3) + P(4-2) = P(1) + P(2) = 1+1 = 2&lt;br /&gt;
P(5) = P(5-3) + P(5-2) = P(2) + P(3) = 1+1 = 2&lt;br /&gt;
P(6) = P(6-3) + P(6-2) = P(3) + P(4) = 1 + 2 = 3&lt;/p&gt;

&lt;p&gt;위의 세 식을 보면 알겠듯이 해당 수열 P(N) = P(N-3) + P(N-2)의 규칙을 가진다.&lt;/p&gt;

&lt;p&gt;피보나치와 유사하게 DP로 위 점화식을 풀어나가면 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;테스트 케이스 수를 읽어와 테스트 케이스 수 만큼 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수 N에 주어지는 입력값을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dp용 배열을 N+2개만큼 선언한다. +2를 하는 이유는, N에 3 미만의 수가 주어졌을 때 배열의 값을 벗어나지 않게 하기 위함이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시작값을 3부터 N까지 반복하는데, 위의 점화식대로 계산하여 배열에 순차적으로 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 dp배열의 N-1번째 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BOJ_9461_파도반수열 {

	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int T = Integer.parseInt(in.readLine());

		for (int i = 0; i &amp;lt; T; i++) {

			int N = Integer.parseInt(in.readLine());

			long[] dp = new long[N+2];

			dp[0] = 1;
			dp[1] = 1;
			dp[2] = 1;

			for (int j = 3; j &amp;lt; N; j++) {
				dp[j] = dp[j - 2] + dp[j - 3];
			}

			System.out.println(dp[N - 1]);

		}

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 파도반수열</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2840_행운의바퀴_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2840" rel="alternate" type="text/html" title="BOJ_2840_행운의바퀴_JAVA" />
      <published>2022-02-20T01:40:00+09:00</published>
      <updated>2022-02-20T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2840</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2840">&lt;h2 id=&quot;문제--행운의바퀴&quot;&gt;문제 : 행운의바퀴&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2840&quot;&gt;BOJ_2840_행운의바퀴&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;원형으로 되어있는 배열에 값을 집어넣는다고 생각하면 이해가 조금 더 쉬울듯 싶다.&lt;/p&gt;

&lt;p&gt;배열의 시작을 0으로 하고, 주어진 값만큼 index를 증가시켜가면서 주어진 값을 배열에 넣는다. 다만, 배열의 범위를 벗어나면 다시 0부터 시작하도록 해야한다.&lt;/p&gt;

&lt;p&gt;모든 값의 입력이 끝나면, 마지막으로 입력된 배열의 index에서 배열의 크기만큼 index값을 1씩 줄여주면서 배열을 출력하면 된다. 배열의값이 0보다 작아지면 배열의 크기 - 1으로 index를 바꿔준다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기(N)와 바퀴를 돌리는 횟수(K)를 읽어와 각각 변수에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;타입은 char, N 크기의 1차원 배열을 생성하고, 사용한 알파벳을 체크하기 위한 ArrayList를 하나 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 초기값을 ‘?’으로 초기화해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;K만큼 반복하는데, 배열의 시작지점부터, 주어진 값만큼 index를 증가시킨다. 여기에 %N, N으로 나머지연산을 해주어, 배열의 값이 넘어설 경우 다시 0부터 증가하도록 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;한 자리에 1개의 알파벳만 들어있지 않거나 2개 이상의 자리에 같은 알파벳이 있으면 ‘!’를 출력하고 프로그램을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 조건에서 종료되지 않았다면, 인덱스 값에 해당하는 배열에 주어진 알파벳을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후, 배열의 크기만큼 반복하는데, 마지막으로 저장되어있는 index값부터 -1씩 시켜주면서 출력한다. 배열의 범위가 0보다 작아질 경우, index를 N-1로 바꾸어준뒤 다시 -1씩 시켜준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class BOJ_2840_행운의바퀴 {

	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		int N = Integer.parseInt(st.nextToken());

		int K = Integer.parseInt(st.nextToken());

		char arr[] = new char[N];

		ArrayList&amp;lt;Character&amp;gt; alpList = new ArrayList&amp;lt;&amp;gt;();

		// 초기값 '?'으로 초기화
		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = '?';
		}

		// 값을 증가시켜가면서 집어넣고, 모두 집어넣은 뒤에는 값을 1씩 빼면서 출력하면 될 것 같다.
		int start = 0;
		for(int i=0;i&amp;lt;K;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);

			int move = Integer.parseInt(st.nextToken());

			start = (start + move )%N;

			char alp = st.nextToken().charAt(0);

			if(alpList.contains(alp) &amp;amp;&amp;amp; arr[start] != alp) {
				System.out.println(&quot;!&quot;);
				return;
			}

			alpList.add(alp);
//			System.out.println(start+&quot;:&quot;+alp);
			if(arr[start] == '?' || arr[start] == alp) {
				arr[start] = alp;
			}else {
				System.out.println('!');
				return;
			}
		}
		StringBuilder sb = new StringBuilder();
		for(int i=0;i&amp;lt;N;i++) {
			sb.append(arr[start]);
			start--;
			if(start &amp;lt; 0) {
				start = N-1;
			}
		}

		System.out.println(sb);

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 행운의바퀴</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1063_킹_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1063" rel="alternate" type="text/html" title="BOJ_1063_킹_JAVA" />
      <published>2022-02-20T01:40:00+09:00</published>
      <updated>2022-02-20T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1063</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1063">&lt;h2 id=&quot;문제--킹&quot;&gt;문제 : 킹&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1063&quot;&gt;BOJ_1063_킹&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;킹과 돌의 초기 위치가 주어지고, 주어진 명령어에 따라서 킹을 움직인다. 킹이 움직이는 방향 앞에 돌이 있다면, 킹이 움직이는 방향으로 돌을 같이 움직여준다.&lt;/p&gt;

&lt;p&gt;위 규칙을 구현하면 되는 문제이다. 하지만 몇 가지 걸림돌이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;체스판의 번호와 방향
 체스판의 세로줄은 a~h까지, 가로줄은 1~8까지 있다. 배열로 이 문제를 푼다면, 배열의 넘버링에 주의할 필요가 있을 것이고, 또 영어 표기를 넘버링 할 방법도 찾아야 할 것이다. 또한, 가로번호를 셀 때 우리가 흔히 아는 방향인 위에서 아래로 내려가는 것이 아닌, 아래에서 위로 올라가는 부분 또한 고려해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;입력과 출력 처리
 킹과 돌의 좌표가 주어질 때, A1, A2와 같이 각 좌표가 공백으로 구분되지 않고 한 번에 들어온다. BufferedReader로 읽어온다고 하면, 읽어온 문자열을 구분할 방안이 필요하다. 만약 비교를 하는 도중 영어로 넘버링 되는 좌표를 숫자로 바꾸어 처리했다면, 출력할 때 이를 영어로 다시 바꿔주는 것도 잊으면 안된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 사항을 주의하면 로직 자체는 간단하기 때문에 쉽게 풀이할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;킹이 움직일 수 있는 방법에 따른 단위벡터 배열을 선언한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;킹의 좌표와 돌의 좌표를 읽어와 각각 변수에 저장한다. 세로줄에 대한 좌표를 읽어올 때는 -‘A’를 통해서 문자에 해당하는 정수값으로 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;명령어를 읽어들여 명령에 맞게 킹을 이동시킨다. 이동시키는 것의 의미는, 킹의 좌표에 해당 방향의 단위벡터만큼 더해주는 것이다. 킹이 범위 바깥으로 나가는 지 체크하는 것을 고려해야한다. 킹이 돌을 함께 움직이는 경우, 돌의 범위도 벗어나면 안된다는 것에 유의한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 명령을 수행시킨 후, 현재 킹의 위치와 돌의 위치를 출력한다. 세로줄에 좌표를 출력할 때는 다시 문자로 출력해야하므로 ‘A’를 더해주고 char로 형변환을 해준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_1063_킹 {

	// 우 좌 상 하 우상 좌상 우하 좌하 (문제기준)
	static int dir[][] = { { 0, 1 }, { 0, -1 }, { -1, 0 }, { 1, 0 }, { 1, 1 }, { 1, -1 }, { -1, 1 }, { -1, -1 } };

//	static int arr[][];

	static int xK, yK, xS, yS;

	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

//		// 뒤의 8은 a부터 h까지 매칭
//		arr = new int[9][9];

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		char[] pos = st.nextToken().toCharArray();

		// 왕의 위치를 1로
		xK = pos[1] - '0';
		yK = pos[0] - 'A' + 1;

		pos = st.nextToken().toCharArray();

		xS = pos[1] - '0';
		yS = pos[0] - 'A' + 1;
//		System.out.println(xK+&quot;,&quot;+yK);
//		System.out.println(xS+&quot;,&quot;+yS);
		int N = Integer.parseInt(st.nextToken());
		// 왕 이동할 값 읽어와서 이동시키기
		for (int i = 0; i &amp;lt; N; i++) {
			String command = in.readLine();

			switch (command) {
			case &quot;R&quot;:
				// 킹 이동 함수
				move(0);
				break;
			case &quot;L&quot;:
				move(1);
				break;
			case &quot;B&quot;:
				move(2);
				break;
			case &quot;T&quot;:
				move(3);
				break;
			case &quot;RT&quot;:
				move(4);
				break;
			case &quot;LT&quot;:
				move(5);
				break;
			case &quot;RB&quot;:
				move(6);
				break;
			case &quot;LB&quot;:
				move(7);
				break;
			}

		}

		System.out.printf(&quot;%c%d\n&quot;,(char)(yK+'A'-1),xK);
		System.out.printf(&quot;%c%d\n&quot;,(char)(yS+'A'-1),xS);		
	}

	public static void move(int dirr) {
		int dx = dir[dirr][0];
		int dy = dir[dirr][1];

		// 킹이 이동할 위치가 범위 밖인지 확인
		if (xK + dx &amp;gt; 0 &amp;amp;&amp;amp; xK + dx &amp;lt;= 8 &amp;amp;&amp;amp; yK + dy &amp;gt; 0 &amp;amp;&amp;amp; yK + dy &amp;lt;= 8) {
			// 킹의 위치를 변경할 곳에 돌이 있는지 확인
			if (xK + dx == xS &amp;amp;&amp;amp; yK + dy == yS) {
				// 돌이 이동할 위치가 범위 밖인지 확인
				if (xS + dx &amp;gt; 0 &amp;amp;&amp;amp; xS + dx &amp;lt;= 8 &amp;amp;&amp;amp; yS + dy &amp;gt; 0 &amp;amp;&amp;amp; yS + dy &amp;lt;= 8) {
					xK = xK + dx;
					yK = yK + dy;

					xS = xS + dx;
					yS = yS + dy;
				}
			}else{
				xK = xK + dx;
				yK = yK + dy;
			}
		}

	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 킹</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1904_01타일_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1904" rel="alternate" type="text/html" title="BOJ_1904_01타일_JAVA" />
      <published>2022-02-19T01:40:00+09:00</published>
      <updated>2022-02-19T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1904</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1904">&lt;h2 id=&quot;문제--01타일&quot;&gt;문제 : 01타일&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1904&quot;&gt;BOJ_1904_01타일&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;N이 1일때 1으로 1개&lt;/p&gt;

&lt;p&gt;N이 2일때 00, 11 2개&lt;/p&gt;

&lt;p&gt;N이3일때 001,100,111 3개&lt;/p&gt;

&lt;p&gt;N이 4일때 0011,0000,1001,1100,1111 5개,&lt;/p&gt;

&lt;p&gt;N이 5일때 11111, 11100, 11001, 10011, 00111, 10000, 00100, 00001 8개&lt;/p&gt;

&lt;p&gt;N이 6이라면 111111, 111100, 111001, 110011, 100111, 001111, 110000, 100001, 100100, 000011, 000011, 001001, 000000 13개이다.&lt;/p&gt;

&lt;p&gt;1, 2, 3, 5, 8, 13 … 어딘가 익숙할 것이다.&lt;/p&gt;

&lt;p&gt;이것은 다른 문제의 탈을 쓴 피보나치 수열 문제이다. 시간제한이 0.75초로 매우 짧은 것은 DP를 사용하라는 의미이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;결과값을 저장할 배열을 N+1개만큼 선언한다. N+1개만큼 선언하는 이유는, 해당 문제의 시작이 피보나치수열의 2번째부터이기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;피보나치 수열의 초기값을 dp배열의 0번, 1번에 할당한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;i는 2부터 N번까지 반복을 돌려서 피보나치 수열을 계산하여 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주의해야할 점은 문제에서 원하는 값은 15746으로 나눈 나머지이고, 주어지는 값이 매우 커서 허용가능한 int값을 넘어선다. (a + b) % c = a % c + b % c의 성질을 이용해서 값을 더할때마다 15746으로 나머지 연산을 해주어야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N번째까지 반복을 돈 후, dp배열의 N-1번째 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class BOJ_1904_01타일 {


	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());
		N = N + 1;
		int[] dp = new int[N];
		dp[0] = 1;
		dp[1] = 1;

		for(int i=2;i&amp;lt;N;i++) {
			dp[i] = (dp[i-1] + dp[i-2])%15746;

		}

		System.out.println(dp[N-1]);
	}

}

//
//	static long fiboDp(int N) {
//		
//		if(N == 0) {
//			return 0;
//		}
//		if(N == 1) {
//			return 1;
//		}

//		if(dp[N] != 0) {
//			return dp[N];
//		}
//		dp[N] = fiboDp(N-1) + fiboDp(N-2);
//		return dp[N];
//		

//	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 01타일</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_15683_감시_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-15683" rel="alternate" type="text/html" title="BOJ_15683_감시_JAVA" />
      <published>2022-02-19T01:40:00+09:00</published>
      <updated>2022-02-19T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-15683</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-15683">&lt;h2 id=&quot;문제--감시&quot;&gt;문제 : 감시&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/15683&quot;&gt;BOJ_15683_감시&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/감시_설명.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; title=&quot;title&quot; alt=&quot;anything&quot; /&gt;&lt;/center&gt;

&lt;p&gt;CCTV 번호 별 탐색 가능한 방향이다. CCTV으로 가능한 감시범위를 최대로 해야하기 때문에, CCTV의 방향에 따른 모든 경우의 수를 모두 테스트해보면서 최대 감시 범위를 찾아야한다.&lt;/p&gt;

&lt;p&gt;나는 중복순열을 약간 변형시켜서 이 문제를 풀려고 하였다. 처음에는 어떻게 해야할 지 감이 잡히지 않았지만, 유도조건에 0~4까지의 값으로 대입하게 하니 리스트의 개수만큼, 0~3까지의 값이 저장이 되었다.&lt;/p&gt;

&lt;p&gt;예를 들어 3개의 CCTV의 타입 순열을 구한다고 하면&lt;/p&gt;

&lt;p&gt;0 0 0&lt;br /&gt;
0 0 1&lt;br /&gt;
0 0 2&lt;br /&gt;
0 0 3&lt;br /&gt;
0 1 0&lt;br /&gt;
0 1 1&lt;br /&gt;
0 1 2&lt;br /&gt;
0 1 3&lt;br /&gt;
…&lt;/p&gt;

&lt;p&gt;이런 방식으로 순열이 생성되는 것이다.&lt;/p&gt;

&lt;p&gt;CCTV의 방향에 대한 모든 경우의 수가 구해졌으니, 이제 각 순열에 대해서 탐색만 진행하면 문제가 해결된다.&lt;/p&gt;

&lt;p&gt;탐색을 할 때 주의할 점은, 원본배열을 수정&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;사무실 크기, 정보를 읽어들여 배열에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CCTV는 따로 클래스로 만들고, 배열을 탐색하여 CCTV에 해당하는 수(1~5)라면 CCTV타입 list에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CCTV list의 0~3까지 값의 순열을 구한다. 해당 순열에 대해서 중복을 허용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열 함수의 기저조건에서, 구해진 순열을 토대로 사무실 배열을 수정한다. 배열을 수정할 때, 배열을 그대로 사용하는 게 아닌 복사해서 사용해야 하는 것에 유의해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CCTV의 타입번호 + 현재 순열을 이용하여 Switch문으로 배열의 감시되는 부분을 다른 수로 치환해준다. 나는 -1로 바꾸었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1번 CCTV의 경우 단방향이므로 순열의 값이 0,1,2,3의 경우 수정할 방향이 모두 다르다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2번 CCTV의 경우 좌,우 양방향이기때문에 0,2와 1,3번의 수정할 방향이 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이런 방식으로 경우의 수를 따져서 배열을 수정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 수정이 완료되었으면, 배열을 순회하며 0의 개수를 찾아서 카운팅한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;카운팅한 값을 최솟값을 저장할 변수 answer과 비교하여 최솟값을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순열에 대한 배열 수정과 순회가 끝나고 나서 저장되어있는 answer값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;


class CCTV{
	// X좌표
	int X;
	// Y좌표
	int Y;

	// CCTV 번호
	int num;

	public CCTV(int x, int y, int num) {
		super();
		X = x;
		Y = y;
		this.num = num;
	}

}


public class BOJ_15683_감시 {

	/*
	 * 1번 = 회전 4번 2번 = 회전 2번 3번 = 회전 4번 4번 = 회전 4번 5번 = 회전 0번
	 */

	static int N,M,arr[][],dir[][] ={ { 0, 1 }, { 0, -1 }, { -1, 0 }, { 1, 0 } };
	static ArrayList&amp;lt;CCTV&amp;gt; list;
	static int[] numbers;
	static int answer;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		M = Integer.parseInt(st.nextToken());

		arr = new int[N][M];

		list = new ArrayList&amp;lt;&amp;gt;();


		for (int i = 0; i &amp;lt; N; i++) {
			st = new StringTokenizer(in.readLine(), &quot; &quot;);
			for (int j = 0; j &amp;lt; M; j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if(arr[i][j] != 0 &amp;amp;&amp;amp; arr[i][j] != 6) {
					list.add(new CCTV(i,j,arr[i][j]));
				}
			}
		}
		numbers = new int[list.size()];
		answer =Integer.MAX_VALUE;
		perm(0);
		System.out.println(answer);

	}


	// 중복순열의 변형 1~4까지 있을 수 있는 값을 구한다. 리스트의 개수만큼?
	public static void perm(int cnt) {


		// 기저조건
		if(cnt == list.size()) {
			// 순열이 좌라락 나온다.
			/*
			 * 0,0,0
			 * 0,0,1
			 * 0,0,2
			 * 0,0,3
			 * 0,1,0
			 * 0,1,1
			 * 0,1,2
			 * 0,1,3 ...
			 *
			 * 0일때는 오른쪽
			 * 1일때는 왼쪽
			 * 2일때는 위쪽
			 * 3일때는 아랫쪽을 탐색한다.
			 *
			 */
//			System.out.println(Arrays.toString(numbers));
			int[][] copy =  new int[N][M];
			for(int i=0;i&amp;lt;N;i++) {
				copy[i] = arr[i].clone();
			}


			for(int i=0,n=list.size();i&amp;lt;n;i++) {
				int x = list.get(i).X;
				int y = list.get(i).Y;
				int num = list.get(i).num;
				// CCTV를 만나면
				search(numbers[i], x, y, num, copy);
			}

			int count = 0;
			for(int i=0;i&amp;lt;N;i++) {
				for(int j=0;j&amp;lt;M;j++) {
					if(copy[i][j] == 0) {
						count++;
					}
				}
			}
			answer = Math.min(answer, count);
			return;
		}


		// 유도파트
		for(int i=0;i&amp;lt;4;i++) {
			numbers[cnt] = i;
			perm(cnt+1);
		}

	}

	public static void search(int cctvNo, int x, int y, int cctvType, int[][] copy) {

		// CCTV의 탐색 범위에 따른 탐색
		switch(cctvType) {
		// 1번 CCTV
		case 1:
			// 1번일 경우 4번 회전 ( 탐색 방향은 우 좌 상 하)
			switch(cctvNo) {
			// 오른쪽 탐색
			case 0:
				detect(x, y, copy, 0);
				break;
			// 왼쪽 탐색
			case 1:
				detect(x, y, copy, 1);
				break;
			// 위쪽 탐색
			case 2:
				detect(x, y, copy, 2);
				break;
			// 아래쪽 탐색
			case 3:
				detect(x, y, copy, 3);
				break;				
			}
			break;
		case 2:
			// 2번일 경우 2가지 경우로 나누어 생각한다.
			switch(cctvNo) {
			// 좌우 탐색
			case 0:
			case 2:
				// 오른쪽 탐색
				detect(x,y,copy,0);
				// 왼쪽 탐색
				detect(x,y,copy,1);
				break;
			// 상하 탐색
			case 1:
			case 3:
				// 상
				detect(x,y,copy,2);
				// 하
				detect(x,y,copy,3);
				break;
			}
			break;
		case 3:
			// 3번일 경우 4가지 경우로 나누어 생각한다.
			switch(cctvNo) {
			// 우,상 탐색
			case 0:
				//우
				detect(x,y,copy,0);
				//상
				detect(x,y,copy,2);
				break;
			// 좌,하 탐색
			case 1:
				//좌
				detect(x,y,copy,1);
				//하
				detect(x,y,copy,3);
				break;
			// 상, 좌 탐색
			case 2:
				//상
				detect(x,y,copy,2);
				//좌
				detect(x,y,copy,1);
				break;
			// 하, 우 탐색
			case 3:
				//하
				detect(x,y,copy,3);
				//우
				detect(x,y,copy,0);
				break;
			}
			break;
		// 4번일 경우 4가지 경우로 나누어 생각한다.
		case 4:
			switch(cctvNo) {
			// 우 상 좌
			case 0:
				//우
				detect(x,y,copy,0);
				//상
				detect(x,y,copy,2);
				//좌
				detect(x,y,copy,1);
				break;
			//좌 하 우
			case 1:
				//좌
				detect(x,y,copy,1);
				//하
				detect(x,y,copy,3);
				//우
				detect(x,y,copy,0);
				break;
			// 상 좌 하
			case 2:
				//상
				detect(x,y,copy,2);
				//좌
				detect(x,y,copy,1);
				//하
				detect(x,y,copy,3);
				break;
			// 하 우 상
			case 3:
				//하
				detect(x,y,copy,3);
				//우
				detect(x,y,copy,0);
				//상
				detect(x,y,copy,2);
				break;
			}
			break;
		// 5번일 경우, 회전 상관 없이 탐색한다.
		case 5:
			for(int i=0;i&amp;lt;4;i++) {
				detect(x,y,copy,i);
			}
		}

	}

	public static void detect(int x, int y, int[][] copy, int dirNo) {
		while(true) {
			int dx = x + dir[dirNo][0];
			int dy = y + dir[dirNo][1];
			if(dx &amp;lt; 0 || dx &amp;gt;= N || dy &amp;lt; 0 || dy &amp;gt;= M || copy[dx][dy] == 6) {
				break;
			}
			else if(copy[dx][dy] == 0) {
				copy[dx][dy] = -1;
			}
			x = dx;
			y = dy;
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 감시</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_3060_욕심쟁이돼지_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-3060" rel="alternate" type="text/html" title="BOJ_3060_욕심쟁이돼지_JAVA" />
      <published>2022-02-19T01:40:00+09:00</published>
      <updated>2022-02-19T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-3060</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-3060">&lt;h2 id=&quot;문제-&quot;&gt;문제 :&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/3060&quot;&gt;BOJ_3060_욕심쟁이돼지&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;원탁에 6명이 앉아있고, 각자 인접한 돼지와 맞은편의 돼지가 먹은 식량만큼 자신의 값에 더해줘야한다. 원탁을 기반으로 하기 때문에 배열의 참조를 원형처럼 접근해야한다. 이는 나머지연산으로 간단하게 할 수 있다.&lt;/p&gt;

&lt;p&gt;조건에서 6마리로 정해져 있기 떄문에 6으로 나머지연산을 시켜주면서 index에 적절한 값을 더해주면된다.&lt;/p&gt;

&lt;p&gt;나머지연산을 쓰지 않으려면 직접 어떻게 되는지 다 체크해서 모든 경우의 수를 코딩 할 수도 있다.&lt;/p&gt;

&lt;p&gt;또 하나의 방법으로, 수학적으로 풀 수도 있다. 이번 문제의 경우에, 매 날짜마다 돼지들이 원하는 사료의 양은 4배씩 증가한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;배열에 첫 날 돼지들이 먹고 싶어하는 사료의 양을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;맨 처음, 배열의 값을 다 더해서 sum변수에 저장한다. sum이 N보다 크다면 먹일 수 없다는 의미이므로 1을 출력하고 다음 테스트 케이스로 넘어간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sum이 N보다 작다면, 날짜 반복으로 넘어간다. 카운트를 1 증가시키고, sum을 4배 증가시켜준다. 만약 증가시킨 sum값이 N보다 작다면 위 내용을 반복하고, N보다 크다면 반복을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복이종료된 후 카운트 값을 출력하고, 다음 테스트케이스로 넘어간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 테스트 케이스가 테스트되었다면 프로그램을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class BOJ_3060_욕심쟁이돼지 {

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int T = Integer.parseInt(in.readLine());

		for(int tc = 0; tc&amp;lt;T;tc++) {

			long N = Integer.parseInt(in.readLine());


			long arr[] = new long[6];

			StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);
			for(int i=0;i&amp;lt;6;i++) {
				arr[i] = Integer.parseInt(st.nextToken());
			}
			long sum = 0;
			int cnt = 1;
			for(int i=0;i&amp;lt;6;i++) {
				sum = sum + arr[i];
			}

			if(sum &amp;gt; N) {
				System.out.println(cnt);
				continue;
			}
			while(true) {
				cnt++;
				sum = sum*4;
//				for(int i=0;i&amp;lt;6;i++) {
//					arr[i] = arr[i] + arr[(i+3)%6] + arr[(i+5)%6] + arr[(i+1)%6];
//					sum += arr[i];
//				}
				if(sum &amp;gt; N) {
					break;
				}


			}

			System.out.println(cnt);

		}


	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 :</summary>
      

      
      
    </entry>
  
</feed>
