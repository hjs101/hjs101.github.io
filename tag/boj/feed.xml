<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hjs101.github.io/tag/boj/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hjs101.github.io/" rel="alternate" type="text/html" />
  <updated>2022-02-21T00:04:29+09:00</updated>
  <id>https://hjs101.github.io/tag/boj/feed.xml</id>

  
  
  

  
    <title type="html">hjs’s Blog | </title>
  

  
    <subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">BOJ_1063_킹_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1063" rel="alternate" type="text/html" title="BOJ_1063_킹_JAVA" />
      <published>2022-02-20T01:40:00+09:00</published>
      <updated>2022-02-20T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1063</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1063">&lt;h2 id=&quot;문제--킹&quot;&gt;문제 : 킹&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1063&quot;&gt;BOJ_1063_킹&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;킹과 돌의 초기 위치가 주어지고, 주어진 명령어에 따라서 킹을 움직인다. 킹이 움직이는 방향 앞에 돌이 있다면, 킹이 움직이는 방향으로 돌을 같이 움직여준다.&lt;/p&gt;

&lt;p&gt;위 규칙을 구현하면 되는 문제이다. 하지만 몇 가지 걸림돌이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;체스판의 번호와 방향
 체스판의 세로줄은 a~h까지, 가로줄은 1~8까지 있다. 배열로 이 문제를 푼다면, 배열의 넘버링에 주의할 필요가 있을 것이고, 또 영어 표기를 넘버링 할 방법도 찾아야 할 것이다. 또한, 가로번호를 셀 때 우리가 흔히 아는 방향인 위에서 아래로 내려가는 것이 아닌, 아래에서 위로 올라가는 부분 또한 고려해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;입력과 출력 처리
 킹과 돌의 좌표가 주어질 때, A1, A2와 같이 각 좌표가 공백으로 구분되지 않고 한 번에 들어온다. BufferedReader로 읽어온다고 하면, 읽어온 문자열을 구분할 방안이 필요하다. 만약 비교를 하는 도중 영어로 넘버링 되는 좌표를 숫자로 바꾸어 처리했다면, 출력할 때 이를 영어로 다시 바꿔주는 것도 잊으면 안된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 사항을 주의하면 로직 자체는 간단하기 때문에 쉽게 풀이할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;킹이 움직일 수 있는 방법에 따른 단위벡터 배열을 선언한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;킹의 좌표와 돌의 좌표를 읽어와 각각 변수에 저장한다. 세로줄에 대한 좌표를 읽어올 때는 -‘A’를 통해서 문자에 해당하는 정수값으로 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;명령어를 읽어들여 명령에 맞게 킹을 이동시킨다. 이동시키는 것의 의미는, 킹의 좌표에 해당 방향의 단위벡터만큼 더해주는 것이다. 킹이 범위 바깥으로 나가는 지 체크하는 것을 고려해야한다. 킹이 돌을 함께 움직이는 경우, 돌의 범위도 벗어나면 안된다는 것에 유의한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 명령을 수행시킨 후, 현재 킹의 위치와 돌의 위치를 출력한다. 세로줄에 좌표를 출력할 때는 다시 문자로 출력해야하므로 ‘A’를 더해주고 char로 형변환을 해준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_1063_킹 {

	// 우 좌 상 하 우상 좌상 우하 좌하 (문제기준)
	static int dir[][] = { { 0, 1 }, { 0, -1 }, { -1, 0 }, { 1, 0 }, { 1, 1 }, { 1, -1 }, { -1, 1 }, { -1, -1 } };

//	static int arr[][];

	static int xK, yK, xS, yS;

	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

//		// 뒤의 8은 a부터 h까지 매칭
//		arr = new int[9][9];

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		char[] pos = st.nextToken().toCharArray();

		// 왕의 위치를 1로
		xK = pos[1] - '0';
		yK = pos[0] - 'A' + 1;

		pos = st.nextToken().toCharArray();

		xS = pos[1] - '0';
		yS = pos[0] - 'A' + 1;
//		System.out.println(xK+&quot;,&quot;+yK);
//		System.out.println(xS+&quot;,&quot;+yS);
		int N = Integer.parseInt(st.nextToken());
		// 왕 이동할 값 읽어와서 이동시키기
		for (int i = 0; i &amp;lt; N; i++) {
			String command = in.readLine();

			switch (command) {
			case &quot;R&quot;:
				// 킹 이동 함수
				move(0);
				break;
			case &quot;L&quot;:
				move(1);
				break;
			case &quot;B&quot;:
				move(2);
				break;
			case &quot;T&quot;:
				move(3);
				break;
			case &quot;RT&quot;:
				move(4);
				break;
			case &quot;LT&quot;:
				move(5);
				break;
			case &quot;RB&quot;:
				move(6);
				break;
			case &quot;LB&quot;:
				move(7);
				break;
			}

		}

		System.out.printf(&quot;%c%d\n&quot;,(char)(yK+'A'-1),xK);
		System.out.printf(&quot;%c%d\n&quot;,(char)(yS+'A'-1),xS);		
	}

	public static void move(int dirr) {
		int dx = dir[dirr][0];
		int dy = dir[dirr][1];

		// 킹이 이동할 위치가 범위 밖인지 확인
		if (xK + dx &amp;gt; 0 &amp;amp;&amp;amp; xK + dx &amp;lt;= 8 &amp;amp;&amp;amp; yK + dy &amp;gt; 0 &amp;amp;&amp;amp; yK + dy &amp;lt;= 8) {
			// 킹의 위치를 변경할 곳에 돌이 있는지 확인
			if (xK + dx == xS &amp;amp;&amp;amp; yK + dy == yS) {
				// 돌이 이동할 위치가 범위 밖인지 확인
				if (xS + dx &amp;gt; 0 &amp;amp;&amp;amp; xS + dx &amp;lt;= 8 &amp;amp;&amp;amp; yS + dy &amp;gt; 0 &amp;amp;&amp;amp; yS + dy &amp;lt;= 8) {
					xK = xK + dx;
					yK = yK + dy;

					xS = xS + dx;
					yS = yS + dy;
				}
			}else{
				xK = xK + dx;
				yK = yK + dy;
			}
		}

	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 킹</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2840_행운의바퀴_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2840" rel="alternate" type="text/html" title="BOJ_2840_행운의바퀴_JAVA" />
      <published>2022-02-20T01:40:00+09:00</published>
      <updated>2022-02-20T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2840</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2840">&lt;h2 id=&quot;문제--행운의바퀴&quot;&gt;문제 : 행운의바퀴&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2840&quot;&gt;BOJ_2840_행운의바퀴&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;원형으로 되어있는 배열에 값을 집어넣는다고 생각하면 이해가 조금 더 쉬울듯 싶다.&lt;/p&gt;

&lt;p&gt;배열의 시작을 0으로 하고, 주어진 값만큼 index를 증가시켜가면서 주어진 값을 배열에 넣는다. 다만, 배열의 범위를 벗어나면 다시 0부터 시작하도록 해야한다.&lt;/p&gt;

&lt;p&gt;모든 값의 입력이 끝나면, 마지막으로 입력된 배열의 index에서 배열의 크기만큼 index값을 1씩 줄여주면서 배열을 출력하면 된다. 배열의값이 0보다 작아지면 배열의 크기 - 1으로 index를 바꿔준다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기(N)와 바퀴를 돌리는 횟수(K)를 읽어와 각각 변수에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;타입은 char, N 크기의 1차원 배열을 생성하고, 사용한 알파벳을 체크하기 위한 ArrayList를 하나 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 초기값을 ‘?’으로 초기화해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;K만큼 반복하는데, 배열의 시작지점부터, 주어진 값만큼 index를 증가시킨다. 여기에 %N, N으로 나머지연산을 해주어, 배열의 값이 넘어설 경우 다시 0부터 증가하도록 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;한 자리에 1개의 알파벳만 들어있지 않거나 2개 이상의 자리에 같은 알파벳이 있으면 ‘!’를 출력하고 프로그램을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 조건에서 종료되지 않았다면, 인덱스 값에 해당하는 배열에 주어진 알파벳을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후, 배열의 크기만큼 반복하는데, 마지막으로 저장되어있는 index값부터 -1씩 시켜주면서 출력한다. 배열의 범위가 0보다 작아질 경우, index를 N-1로 바꾸어준뒤 다시 -1씩 시켜준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class BOJ_2840_행운의바퀴 {

	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		int N = Integer.parseInt(st.nextToken());

		int K = Integer.parseInt(st.nextToken());

		char arr[] = new char[N];

		ArrayList&amp;lt;Character&amp;gt; alpList = new ArrayList&amp;lt;&amp;gt;();

		// 초기값 '?'으로 초기화
		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = '?';
		}

		// 값을 증가시켜가면서 집어넣고, 모두 집어넣은 뒤에는 값을 1씩 빼면서 출력하면 될 것 같다.
		int start = 0;
		for(int i=0;i&amp;lt;K;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);

			int move = Integer.parseInt(st.nextToken());

			start = (start + move )%N;

			char alp = st.nextToken().charAt(0);

			if(alpList.contains(alp) &amp;amp;&amp;amp; arr[start] != alp) {
				System.out.println(&quot;!&quot;);
				return;
			}

			alpList.add(alp);
//			System.out.println(start+&quot;:&quot;+alp);
			if(arr[start] == '?' || arr[start] == alp) {
				arr[start] = alp;
			}else {
				System.out.println('!');
				return;
			}
		}
		StringBuilder sb = new StringBuilder();
		for(int i=0;i&amp;lt;N;i++) {
			sb.append(arr[start]);
			start--;
			if(start &amp;lt; 0) {
				start = N-1;
			}
		}

		System.out.println(sb);

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 행운의바퀴</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_3060_욕심쟁이돼지_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-3060" rel="alternate" type="text/html" title="BOJ_3060_욕심쟁이돼지_JAVA" />
      <published>2022-02-19T01:40:00+09:00</published>
      <updated>2022-02-19T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-3060</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-3060">&lt;h2 id=&quot;문제-&quot;&gt;문제 :&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/3060&quot;&gt;BOJ_3060_욕심쟁이돼지&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;원탁에 6명이 앉아있고, 각자 인접한 돼지와 맞은편의 돼지가 먹은 식량만큼 자신의 값에 더해줘야한다. 원탁을 기반으로 하기 때문에 배열의 참조를 원형처럼 접근해야한다. 이는 나머지연산으로 간단하게 할 수 있다.&lt;/p&gt;

&lt;p&gt;조건에서 6마리로 정해져 있기 떄문에 6으로 나머지연산을 시켜주면서 index에 적절한 값을 더해주면된다.&lt;/p&gt;

&lt;p&gt;나머지연산을 쓰지 않으려면 직접 어떻게 되는지 다 체크해서 모든 경우의 수를 코딩 할 수도 있다.&lt;/p&gt;

&lt;p&gt;또 하나의 방법으로, 수학적으로 풀 수도 있다. 이번 문제의 경우에, 매 날짜마다 돼지들이 원하는 사료의 양은 4배씩 증가한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;배열에 첫 날 돼지들이 먹고 싶어하는 사료의 양을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;맨 처음, 배열의 값을 다 더해서 sum변수에 저장한다. sum이 N보다 크다면 먹일 수 없다는 의미이므로 1을 출력하고 다음 테스트 케이스로 넘어간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sum이 N보다 작다면, 날짜 반복으로 넘어간다. 카운트를 1 증가시키고, sum을 4배 증가시켜준다. 만약 증가시킨 sum값이 N보다 작다면 위 내용을 반복하고, N보다 크다면 반복을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복이종료된 후 카운트 값을 출력하고, 다음 테스트케이스로 넘어간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 테스트 케이스가 테스트되었다면 프로그램을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class BOJ_3060_욕심쟁이돼지 {

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int T = Integer.parseInt(in.readLine());

		for(int tc = 0; tc&amp;lt;T;tc++) {

			long N = Integer.parseInt(in.readLine());


			long arr[] = new long[6];

			StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);
			for(int i=0;i&amp;lt;6;i++) {
				arr[i] = Integer.parseInt(st.nextToken());
			}
			long sum = 0;
			int cnt = 1;
			for(int i=0;i&amp;lt;6;i++) {
				sum = sum + arr[i];
			}

			if(sum &amp;gt; N) {
				System.out.println(cnt);
				continue;
			}
			while(true) {
				cnt++;
				sum = sum*4;
//				for(int i=0;i&amp;lt;6;i++) {
//					arr[i] = arr[i] + arr[(i+3)%6] + arr[(i+5)%6] + arr[(i+1)%6];
//					sum += arr[i];
//				}
				if(sum &amp;gt; N) {
					break;
				}


			}

			System.out.println(cnt);

		}


	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 :</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_1904_01타일_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-1904" rel="alternate" type="text/html" title="BOJ_1904_01타일_JAVA" />
      <published>2022-02-19T01:40:00+09:00</published>
      <updated>2022-02-19T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-1904</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-1904">&lt;h2 id=&quot;문제--01타일&quot;&gt;문제 : 01타일&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1904&quot;&gt;BOJ_1904_01타일&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;N이 1일때 1으로 1개&lt;/p&gt;

&lt;p&gt;N이 2일때 00, 11 2개&lt;/p&gt;

&lt;p&gt;N이3일때 001,100,111 3개&lt;/p&gt;

&lt;p&gt;N이 4일때 0011,0000,1001,1100,1111 5개,&lt;/p&gt;

&lt;p&gt;N이 5일때 11111, 11100, 11001, 10011, 00111, 10000, 00100, 00001 8개&lt;/p&gt;

&lt;p&gt;N이 6이라면 111111, 111100, 111001, 110011, 100111, 001111, 110000, 100001, 100100, 000011, 000011, 001001, 000000 13개이다.&lt;/p&gt;

&lt;p&gt;1, 2, 3, 5, 8, 13 … 어딘가 익숙할 것이다.&lt;/p&gt;

&lt;p&gt;이것은 다른 문제의 탈을 쓴 피보나치 수열 문제이다. 시간제한이 0.75초로 매우 짧은 것은 DP를 사용하라는 의미이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;결과값을 저장할 배열을 N+1개만큼 선언한다. N+1개만큼 선언하는 이유는, 해당 문제의 시작이 피보나치수열의 2번째부터이기 때문이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;피보나치 수열의 초기값을 dp배열의 0번, 1번에 할당한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;i는 2부터 N번까지 반복을 돌려서 피보나치 수열을 계산하여 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주의해야할 점은 문제에서 원하는 값은 15746으로 나눈 나머지이고, 주어지는 값이 매우 커서 허용가능한 int값을 넘어선다. (a + b) % c = a % c + b % c의 성질을 이용해서 값을 더할때마다 15746으로 나머지 연산을 해주어야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;N번째까지 반복을 돈 후, dp배열의 N-1번째 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class BOJ_1904_01타일 {


	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());
		N = N + 1;
		int[] dp = new int[N];
		dp[0] = 1;
		dp[1] = 1;

		for(int i=2;i&amp;lt;N;i++) {
			dp[i] = (dp[i-1] + dp[i-2])%15746;

		}

		System.out.println(dp[N-1]);
	}

}

//
//	static long fiboDp(int N) {
//		
//		if(N == 0) {
//			return 0;
//		}
//		if(N == 1) {
//			return 1;
//		}

//		if(dp[N] != 0) {
//			return dp[N];
//		}
//		dp[N] = fiboDp(N-1) + fiboDp(N-2);
//		return dp[N];
//		

//	}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 01타일</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_15683_감시_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-15683" rel="alternate" type="text/html" title="BOJ_15683_감시_JAVA" />
      <published>2022-02-19T01:40:00+09:00</published>
      <updated>2022-02-19T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-15683</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-15683">&lt;h2 id=&quot;문제--감시&quot;&gt;문제 : 감시&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/15683&quot;&gt;BOJ_15683_감시&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/감시_설명.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; title=&quot;title&quot; alt=&quot;anything&quot; /&gt;&lt;/center&gt;

&lt;p&gt;CCTV 번호 별 탐색 가능한 방향이다. CCTV으로 가능한 감시범위를 최대로 해야하기 때문에, CCTV의 방향에 따른 모든 경우의 수를 모두 테스트해보면서 최대 감시 범위를 찾아야한다.&lt;/p&gt;

&lt;p&gt;나는 중복순열을 약간 변형시켜서 이 문제를 풀려고 하였다. 처음에는 어떻게 해야할 지 감이 잡히지 않았지만, 유도조건에 0~4까지의 값으로 대입하게 하니 리스트의 개수만큼, 0~3까지의 값이 저장이 되었다.&lt;/p&gt;

&lt;p&gt;예를 들어 3개의 CCTV의 타입 순열을 구한다고 하면&lt;/p&gt;

&lt;p&gt;0 0 0&lt;br /&gt;
0 0 1&lt;br /&gt;
0 0 2&lt;br /&gt;
0 0 3&lt;br /&gt;
0 1 0&lt;br /&gt;
0 1 1&lt;br /&gt;
0 1 2&lt;br /&gt;
0 1 3&lt;br /&gt;
…&lt;/p&gt;

&lt;p&gt;이런 방식으로 순열이 생성되는 것이다.&lt;/p&gt;

&lt;p&gt;CCTV의 방향에 대한 모든 경우의 수가 구해졌으니, 이제 각 순열에 대해서 탐색만 진행하면 문제가 해결된다.&lt;/p&gt;

&lt;p&gt;탐색을 할 때 주의할 점은, 원본배열을 수정&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;사무실 크기, 정보를 읽어들여 배열에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CCTV는 따로 클래스로 만들고, 배열을 탐색하여 CCTV에 해당하는 수(1~5)라면 CCTV타입 list에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CCTV list의 0~3까지 값의 순열을 구한다. 해당 순열에 대해서 중복을 허용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열 함수의 기저조건에서, 구해진 순열을 토대로 사무실 배열을 수정한다. 배열을 수정할 때, 배열을 그대로 사용하는 게 아닌 복사해서 사용해야 하는 것에 유의해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CCTV의 타입번호 + 현재 순열을 이용하여 Switch문으로 배열의 감시되는 부분을 다른 수로 치환해준다. 나는 -1로 바꾸었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1번 CCTV의 경우 단방향이므로 순열의 값이 0,1,2,3의 경우 수정할 방향이 모두 다르다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2번 CCTV의 경우 좌,우 양방향이기때문에 0,2와 1,3번의 수정할 방향이 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이런 방식으로 경우의 수를 따져서 배열을 수정한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 수정이 완료되었으면, 배열을 순회하며 0의 개수를 찾아서 카운팅한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;카운팅한 값을 최솟값을 저장할 변수 answer과 비교하여 최솟값을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순열에 대한 배열 수정과 순회가 끝나고 나서 저장되어있는 answer값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;


class CCTV{
	// X좌표
	int X;
	// Y좌표
	int Y;

	// CCTV 번호
	int num;

	public CCTV(int x, int y, int num) {
		super();
		X = x;
		Y = y;
		this.num = num;
	}

}


public class BOJ_15683_감시 {

	/*
	 * 1번 = 회전 4번 2번 = 회전 2번 3번 = 회전 4번 4번 = 회전 4번 5번 = 회전 0번
	 */

	static int N,M,arr[][],dir[][] ={ { 0, 1 }, { 0, -1 }, { -1, 0 }, { 1, 0 } };
	static ArrayList&amp;lt;CCTV&amp;gt; list;
	static int[] numbers;
	static int answer;
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		M = Integer.parseInt(st.nextToken());

		arr = new int[N][M];

		list = new ArrayList&amp;lt;&amp;gt;();


		for (int i = 0; i &amp;lt; N; i++) {
			st = new StringTokenizer(in.readLine(), &quot; &quot;);
			for (int j = 0; j &amp;lt; M; j++) {
				arr[i][j] = Integer.parseInt(st.nextToken());
				if(arr[i][j] != 0 &amp;amp;&amp;amp; arr[i][j] != 6) {
					list.add(new CCTV(i,j,arr[i][j]));
				}
			}
		}
		numbers = new int[list.size()];
		answer =Integer.MAX_VALUE;
		perm(0);
		System.out.println(answer);

	}


	// 중복순열의 변형 1~4까지 있을 수 있는 값을 구한다. 리스트의 개수만큼?
	public static void perm(int cnt) {


		// 기저조건
		if(cnt == list.size()) {
			// 순열이 좌라락 나온다.
			/*
			 * 0,0,0
			 * 0,0,1
			 * 0,0,2
			 * 0,0,3
			 * 0,1,0
			 * 0,1,1
			 * 0,1,2
			 * 0,1,3 ...
			 *
			 * 0일때는 오른쪽
			 * 1일때는 왼쪽
			 * 2일때는 위쪽
			 * 3일때는 아랫쪽을 탐색한다.
			 *
			 */
//			System.out.println(Arrays.toString(numbers));
			int[][] copy =  new int[N][M];
			for(int i=0;i&amp;lt;N;i++) {
				copy[i] = arr[i].clone();
			}


			for(int i=0,n=list.size();i&amp;lt;n;i++) {
				int x = list.get(i).X;
				int y = list.get(i).Y;
				int num = list.get(i).num;
				// CCTV를 만나면
				search(numbers[i], x, y, num, copy);
			}

			int count = 0;
			for(int i=0;i&amp;lt;N;i++) {
				for(int j=0;j&amp;lt;M;j++) {
					if(copy[i][j] == 0) {
						count++;
					}
				}
			}
			answer = Math.min(answer, count);
			return;
		}


		// 유도파트
		for(int i=0;i&amp;lt;4;i++) {
			numbers[cnt] = i;
			perm(cnt+1);
		}

	}

	public static void search(int cctvNo, int x, int y, int cctvType, int[][] copy) {

		// CCTV의 탐색 범위에 따른 탐색
		switch(cctvType) {
		// 1번 CCTV
		case 1:
			// 1번일 경우 4번 회전 ( 탐색 방향은 우 좌 상 하)
			switch(cctvNo) {
			// 오른쪽 탐색
			case 0:
				detect(x, y, copy, 0);
				break;
			// 왼쪽 탐색
			case 1:
				detect(x, y, copy, 1);
				break;
			// 위쪽 탐색
			case 2:
				detect(x, y, copy, 2);
				break;
			// 아래쪽 탐색
			case 3:
				detect(x, y, copy, 3);
				break;				
			}
			break;
		case 2:
			// 2번일 경우 2가지 경우로 나누어 생각한다.
			switch(cctvNo) {
			// 좌우 탐색
			case 0:
			case 2:
				// 오른쪽 탐색
				detect(x,y,copy,0);
				// 왼쪽 탐색
				detect(x,y,copy,1);
				break;
			// 상하 탐색
			case 1:
			case 3:
				// 상
				detect(x,y,copy,2);
				// 하
				detect(x,y,copy,3);
				break;
			}
			break;
		case 3:
			// 3번일 경우 4가지 경우로 나누어 생각한다.
			switch(cctvNo) {
			// 우,상 탐색
			case 0:
				//우
				detect(x,y,copy,0);
				//상
				detect(x,y,copy,2);
				break;
			// 좌,하 탐색
			case 1:
				//좌
				detect(x,y,copy,1);
				//하
				detect(x,y,copy,3);
				break;
			// 상, 좌 탐색
			case 2:
				//상
				detect(x,y,copy,2);
				//좌
				detect(x,y,copy,1);
				break;
			// 하, 우 탐색
			case 3:
				//하
				detect(x,y,copy,3);
				//우
				detect(x,y,copy,0);
				break;
			}
			break;
		// 4번일 경우 4가지 경우로 나누어 생각한다.
		case 4:
			switch(cctvNo) {
			// 우 상 좌
			case 0:
				//우
				detect(x,y,copy,0);
				//상
				detect(x,y,copy,2);
				//좌
				detect(x,y,copy,1);
				break;
			//좌 하 우
			case 1:
				//좌
				detect(x,y,copy,1);
				//하
				detect(x,y,copy,3);
				//우
				detect(x,y,copy,0);
				break;
			// 상 좌 하
			case 2:
				//상
				detect(x,y,copy,2);
				//좌
				detect(x,y,copy,1);
				//하
				detect(x,y,copy,3);
				break;
			// 하 우 상
			case 3:
				//하
				detect(x,y,copy,3);
				//우
				detect(x,y,copy,0);
				//상
				detect(x,y,copy,2);
				break;
			}
			break;
		// 5번일 경우, 회전 상관 없이 탐색한다.
		case 5:
			for(int i=0;i&amp;lt;4;i++) {
				detect(x,y,copy,i);
			}
		}

	}

	public static void detect(int x, int y, int[][] copy, int dirNo) {
		while(true) {
			int dx = x + dir[dirNo][0];
			int dy = y + dir[dirNo][1];
			if(dx &amp;lt; 0 || dx &amp;gt;= N || dy &amp;lt; 0 || dy &amp;gt;= M || copy[dx][dy] == 6) {
				break;
			}
			else if(copy[dx][dy] == 0) {
				copy[dx][dy] = -1;
			}
			x = dx;
			y = dy;
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 감시</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_14888_연산자끼워넣기_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-14888" rel="alternate" type="text/html" title="BOJ_14888_연산자끼워넣기_JAVA" />
      <published>2022-02-18T01:40:00+09:00</published>
      <updated>2022-02-18T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-14888</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-14888">&lt;h2 id=&quot;문제--연산자끼워넣기&quot;&gt;문제 : 연산자끼워넣기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/14888&quot;&gt;BOJ_14888_연산자끼워넣기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;위치가 고정되어있는 숫자가 주어지고, 연산자의 개수가 숫자의 개수 -1개만큼 주어진다. 이 연산자의 계산은 우선순위법칙을 따르지 않는다. 주어진 연산자로 가능한 경우의 수 중에서 가능한 최댓값과 최솟값을 출력해야한다.&lt;/p&gt;

&lt;p&gt;나는 이 문제를 연산자를 순열 완전탐색으로 구하여 숫자에 연산을 적용해보는 방법으로 풀었다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;숫자의 개수 N값을 입력받아 숫자 개수만큼 1차우너 배열을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그 후 주어지는 덧셈, 뺄셈, 곱셈, 나눗셈의 개수를 입력받는데, 입력이 연산자의 개수, 즉 숫자로 주어지기 때문에, 주어진 숫자만큼 반복하여 연산자의 리스트(Character)에 추가해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열을 이용해 주어진 연산자 리스트로부터 가능한 연산자 배치의 경우의 수를 모두 찾는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열 메서드의 기저조건에서, 만들어진 연산자의 배치대로 주어진 숫자배열을 대입하여 연산을 진행하고, 연산을 마친 후, 최댓값과 최솟값을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순열이 탐색된 후 최댓값과 최솟값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;

public class BOJ_14888_연산자끼워넣기 {
	static int[] nums;
	static int[] cal;
	static List&amp;lt;Character&amp;gt; operactor = new ArrayList&amp;lt;&amp;gt;();
	static char[] opPerm;
	static int max,min;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		nums = new int[N];

		for(int i=0;i&amp;lt;N;i++) {
			nums[i] = Integer.parseInt(st.nextToken());
		}
		st = new StringTokenizer(in.readLine(),&quot; &quot;);

		// 덧셈
		int k = Integer.parseInt(st.nextToken());
		for(int i=0;i&amp;lt;k;i++) {
			operactor.add('+');
		}
		// 뺄셈
		k = Integer.parseInt(st.nextToken());
		for(int i=0;i&amp;lt;k;i++) {
			operactor.add('-');
		}
		// 곱셈
		k = Integer.parseInt(st.nextToken());
		for(int i=0;i&amp;lt;k;i++) {
			operactor.add('*');
		}
		// 나눗셈
		k = Integer.parseInt(st.nextToken());
		for(int i=0;i&amp;lt;k;i++) {
			operactor.add('/');
		}
		opPerm = new char[operactor.size()];
		max = Integer.MIN_VALUE;
		min = Integer.MAX_VALUE;
		perm(0,0);
		System.out.println(max);
		System.out.println(min);
	}

	static void perm(int cnt, int flag) {

		// 기저조건
		if(cnt == operactor.size()) {
			int num = nums[0];
			for(int i=0;i&amp;lt;nums.length-1;i++) {
				switch(opPerm[i]){
				case '+':
					num = num + nums[i+1];
					break;
				case '-':
					num = num - nums[i+1];					
					break;
				case '*':
					num = num * nums[i+1];
					break;
				case '/':
					num = num / nums[i+1];
					break;
				}
			}
			max = Math.max(max, num);
			min = Math.min(min, num);
			return;
		}


		// 유도파트

		for(int i=0,n=operactor.size();i&amp;lt;n;i++) {

			if((flag &amp;amp; 1&amp;lt;&amp;lt;i) != 0) {
				continue;
			}

			opPerm[cnt] = operactor.get(i);
			perm(cnt+1,flag | 1&amp;lt;&amp;lt;i);
		}

	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 연산자끼워넣기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_3085_사탕게임_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-3085" rel="alternate" type="text/html" title="BOJ_3085_사탕게임_JAVA" />
      <published>2022-02-18T01:40:00+09:00</published>
      <updated>2022-02-18T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-3085</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-3085">&lt;h2 id=&quot;문제--사탕게임&quot;&gt;문제 : 사탕게임&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/3085&quot;&gt;BOJ_3085_사탕게임&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;문제가 설명하고자 하는 내용 중, 사탕을 서로 교환하는 내용은 옛날에 유행하던 게임 애니팡을 생각하면 직관적으로 다가갈 수 있다.&lt;/p&gt;

&lt;p&gt;먼저, 인접한 서로 다른 사탕을 찾는다. 이는 가로도 될 수 있고 세로도 될 수 있다. 그 후, 두 개의 사탕의 위치를 서로 바꾸고, 행열을 탐색하여 같은 사탕으로 연속된 가장 긴 길이를 저장한다. 가장 긴 길이를 저장했다면, 사탕의 위치를 원래대로 돌려놓고 다음 인접한 서로 다른 사탕을 찾는다.&lt;/p&gt;

&lt;p&gt;이것을 행열이 끝날때까지 반복한 후, 저장된 같은 사탕의 연속된 길이를 출력한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;N값을 입력받아 N*N만큼 char 2차원 배열을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성한 배열에 주어진 사탕의 정보를 입력한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열을 먼저 열 기준으로 비교하여 인접한 사탕을 찾는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인접한 사탕을 찾은 후에는, 서로 자리를 바꾼다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2차원배열을 순회하며 가장 연속된 사탕 수 중 가장 큰 값을 전역변수 max에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;바꾼 사탕의 위치를 원래 자리로 돌려놓는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;행을 기준으로 위의 작업을 한 번 더 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;저장되어있는 연속된 사탕의 개수의 최댓값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class BOJ_3085_사탕게임 {

	static char[][] arr;
	static int max;
	static int N;

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		N = Integer.parseInt(in.readLine());

		arr = new char[N][N];

		for (int i = 0; i &amp;lt; N; i++) {
			arr[i] = in.readLine().toCharArray();
		}

		for (int i = 0; i &amp;lt; N; i++) {
			for (int j = 0; j &amp;lt; N - 1; j++) {
				if (arr[i][j] == arr[i][j + 1]) {
					continue;
				}
				char temp = arr[i][j];
				arr[i][j] = arr[i][j + 1];
				arr[i][j + 1] = temp;

				mapCheck();

				temp = arr[i][j];
				arr[i][j] = arr[i][j + 1];
				arr[i][j + 1] = temp;

			}
		}

		for (int j = 0; j &amp;lt; N; j++) {
			for (int i = 0; i &amp;lt; N - 1; i++) {
				if (arr[i][j] == arr[i + 1][j]) {
					continue;
				}
				char temp = arr[i][j];
				arr[i][j] = arr[i + 1][j];
				arr[i + 1][j] = temp;

				mapCheck();

				temp = arr[i][j];
				arr[i][j] = arr[i + 1][j];
				arr[i + 1][j] = temp;

			}
		}
		System.out.println(max);
	}

	public static void mapCheck() {
		int cnt = 1;
		for (int i = 0; i &amp;lt; N; i++) {
			cnt = 1;
			for (int j = 0; j &amp;lt; N - 1; j++) {
				if (arr[i][j] == arr[i][j + 1]) {
					cnt++;
				} else {
					max = Math.max(max, cnt);
					cnt = 1;
				}
			}
			max = Math.max(max, cnt);
		}
		max = Math.max(max, cnt);

		for (int j = 0; j &amp;lt; N; j++) {
			cnt = 1;
			for (int i = 0; i &amp;lt; N - 1; i++) {
				if (arr[i][j] == arr[i + 1][j]) {
					cnt++;

				} else {
					max = Math.max(max, cnt);
					cnt = 1;
				}
			}
			max = Math.max(max, cnt);
		}
		max = Math.max(cnt, max);

	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 사탕게임</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2980_도로와신호등_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2980" rel="alternate" type="text/html" title="BOJ_2980_도로와신호등_JAVA" />
      <published>2022-02-17T01:40:00+09:00</published>
      <updated>2022-02-17T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2980</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2980">&lt;h2 id=&quot;문제--도로와-신호등&quot;&gt;문제 : 도로와 신호등&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2980&quot;&gt;BOJ_2980_도로와신호등&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;1초에 1미터를 움직이는 트럭이 신호등을 만났을 때, 신호등의 상태에 따라서 전진할 지 멈출지 결정하여 최종 목적지까지 도착했을 때 흐른 시간을 출력하면 되는 문제이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;p&gt;나는 이 문제를 푸는 방법으로 신호등 객체를 생성하여 이용했다. 신호등 객체의 각각의 타이머를 돌려 스스로의 신호 상태를 바꾸게 하고, 트럭이 해당 위치에 도착했을 때, 객체의 신호 상태를 읽어들여 빨간불이면 멈추고, 초록불이면 이동하게 하였다.&lt;/p&gt;

&lt;p&gt;신호등 객체는 자신의 위치정보, 빨간불의 지속시간, 초록불의 지속시간, 타이머, 현재 자신의 상태(빨간불,초록불)를 멤버변수로 갖는다.&lt;/p&gt;

&lt;p&gt;신호등에 대한 정보를 입력받아, 신호등 객체 배열로 저장하고, 저장된 모든 신호등의 타이머를 1씩 증가시킨다.&lt;/p&gt;

&lt;p&gt;각각의 빨간불, 초록불에 지속시간에 따라서 각 신호등 객체는 스스로의 상태를 변경시킨다. 나머지연산을 이용해서 변하는 시점을 구했다.&lt;/p&gt;

&lt;p&gt;신호등 객체의 상태가 정해지면, 트럭을 1 증가시켜 이동시킨다.&lt;/p&gt;

&lt;p&gt;이동시킨 후, 신호등을 순회하여 트럭과 같은 위치에 신호등이 있는지 확인한다. 만약 신호등이 있다면 빨간불일 경우 이동한 거리에서 -1을, 초록불이라면 그대로 둔다.&lt;/p&gt;

&lt;p&gt;트럭이 1부터 시작하여 L에 도달했을 때, 반복을 종료하고 이때까지 걸린 시간을 출력한다.&lt;/p&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class BOJ_2980_도로와신호등 {


	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		int N = Integer.parseInt(st.nextToken());

		int L = Integer.parseInt(st.nextToken());

		TrafficLight[] traf = new TrafficLight[N];

		for(int i=0;i&amp;lt;N;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);
			int dic = Integer.parseInt(st.nextToken());
			int red = Integer.parseInt(st.nextToken());
			int green = Integer.parseInt(st.nextToken());
			traf[i] = new TrafficLight(dic, red, green);
		}
		int time = 0;
		for(int i=1;i&amp;lt;L;i++) {
			for(int j=0;j&amp;lt;N;j++) {
				if(traf[j].timer % traf[j].red == 0 &amp;amp;&amp;amp; traf[j].traffic == false) {
					traf[j].timer = 0;
					traf[j].traffic = true;
				}else if(traf[j].timer % traf[j].green == 0 &amp;amp;&amp;amp; traf[j].traffic==true) {
					traf[j].timer = 0;
					traf[j].traffic = false;
				}
				traf[j].timer++;
//				System.out.print(traf[j].traffic + &quot; &quot;);
			}
//			System.out.println();
			for(int j=0;j&amp;lt;N;j++) {
				if(i == traf[j].dic &amp;amp;&amp;amp; traf[j].traffic == false) {
					i--;
				}
			}
			time++;
		}

		System.out.println(time);

	}

}

class TrafficLight{
	int dic;
	int red;
	int green;
	int timer;
	boolean traffic = true;


	public TrafficLight(int dic, int red, int green) {
		super();
		this.dic = dic;
		this.red = red;
		this.green = green;
	}


}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 도로와 신호등</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_9184_신나는함수실행_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-9184" rel="alternate" type="text/html" title="BOJ_9184_신나는함수실행_JAVA" />
      <published>2022-02-17T01:40:00+09:00</published>
      <updated>2022-02-17T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-9184</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-9184">&lt;h2 id=&quot;문제--신나는함수실행&quot;&gt;문제 : 신나는함수실행&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/9184&quot;&gt;BOJ_9184_신나는함수실행&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;인자값을 3개를 사용하는 재귀함수의 수행속도를 줄이기 위해, DP, 메모이제이션 기법을 사용해야 하는 문제이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;p&gt;DP란 무엇일까?&lt;/p&gt;

&lt;p&gt;동적계획법이라고도 부른다. 하지만 이 글을 쓰는 지금도 DP에 개념에 대해 제대로 알지 못하겠다.&lt;/p&gt;

&lt;p&gt;DP의 조건은 3가지가 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;먼저 큰 문제가 작은 문제로 쪼개질 수 있는가.&lt;/li&gt;
  &lt;li&gt;작은문제들의 해로 큰 문제의 해를 구할 수 있는가.&lt;/li&gt;
  &lt;li&gt;그리고, 이 해들이 중복되는가.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 3가지 조건이 충족되면 DP를 적용할 수 있다고 한다.&lt;/p&gt;

&lt;p&gt;하지만 이러한 내용은 내게 너무 낮설고 적용하기도 어려웠다.&lt;/p&gt;

&lt;p&gt;나는 이 문제를 풀면서 어떻게 DP를 사용하는 지에만 집중했다.&lt;/p&gt;

&lt;p&gt;결론은 이것이다. 재귀를 통해 호출되는 함수의 결과를 기억해두고, 재귀를 통해 호출하는 함수가 기억되어있는 함수와 같다면, 재귀를 호출하지 않고 기억되어있는 함수의 값을 리턴한다.&lt;/p&gt;

&lt;p&gt;메모이제이션은 이것을 말하는 것이다. ‘기억’하는 것.&lt;/p&gt;

&lt;p&gt;그렇기 때문에, 3개의 인자값을 받는 이 재귀함수의 파라미터 a,b,c. 이 값을 배열로 선언해 0으로 초기화 해두고, 호출된 함수의 위치에 결과값을 저장했다. 그 후 같은 인자값을 사용하는 함수가 재귀호출될 경우, 그 함수는 추가적인 작업 없이 저장되어있는 결과값을 리턴하고 종료된다.&lt;/p&gt;

&lt;p&gt;이번 문제에서는 DP에 대해 이정도까지밖에 이해하지 못했다. 몇몇 문제를 더 풀어보며 이해력을 늘려야 한다.&lt;/p&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class BOJ_9184_신나는함수실행 {

	static int[][][] dp;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		StringBuilder sb = new StringBuilder();
		dp = new int[21][21][21];
		while(true) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);

			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			int c = Integer.parseInt(st.nextToken());

			if(a==-1&amp;amp;&amp;amp;b==-1&amp;amp;&amp;amp;c==-1) {
				break;
			}
			long n = w(a,b,c);

			sb.append(String.format(&quot;w(%d, %d, %d) = %d\n&quot;,a,b,c, n));
		}
		System.out.print(sb);
	}

	public static int w(int a, int b, int c) {

		if((a&amp;gt;=0 &amp;amp;&amp;amp; a &amp;lt;=20 &amp;amp;&amp;amp; b &amp;gt;= 0 &amp;amp;&amp;amp; b &amp;lt;= 20 &amp;amp;&amp;amp; c &amp;gt;= 0 &amp;amp;&amp;amp; c &amp;lt;= 20) &amp;amp;&amp;amp; dp[a][b][c] != 0) {
			return dp[a][b][c];
		}

		if(a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) {
			return 1;
		}

		if(a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) {
			dp[20][20][20] = w(20,20,20);
			return dp[20][20][20];
		}

		if(a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) {
			dp[a][b][c] =w(a,b,c-1)+w(a,b-1,c-1) - w(a,b-1,c);
			return dp[a][b][c];
		}
		dp[a][b][c] = w(a-1,b,c) + w(a-1,b-1,c) + w(a-1,b,c-1) - w(a-1,b-1,c-1);
		return dp[a][b][c];

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 신나는함수실행</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ_2947_나무조각_JAVA</title>
      <link href="https://hjs101.github.io/BOJ-2947" rel="alternate" type="text/html" title="BOJ_2947_나무조각_JAVA" />
      <published>2022-02-16T01:40:00+09:00</published>
      <updated>2022-02-16T01:40:00+09:00</updated>
      <id>https://hjs101.github.io/BOJ-2947</id>
      <content type="html" xml:base="https://hjs101.github.io/BOJ-2947">&lt;h2 id=&quot;문제--나무조각&quot;&gt;문제 : 나무조각&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2947&quot;&gt;BOJ_2947_나무조각&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;버블정렬을 구현하면 되는 문제이다.&lt;/p&gt;

&lt;p&gt;버블정렬을 구현하는데, 각 스텝별로 출력해가면서 구현하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;5개의 값을 입력받아서 배열에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;버블정렬을 직접 구현하여 1번 스와핑이 일어날 때마다 배열의 상태를 출력해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정렬이 완료되면 프로그램을 종료한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class BOJ_2947_나무조각 {

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);
		int[] arr = new int[5];
		arr[0] = Integer.parseInt(st.nextToken());
		arr[1] = Integer.parseInt(st.nextToken());
		arr[2] = Integer.parseInt(st.nextToken());
		arr[3] = Integer.parseInt(st.nextToken());
		arr[4] = Integer.parseInt(st.nextToken());
		while(true) {
			for(int i=0;i&amp;lt;5;i++) {
				if(i+1 &amp;gt;=5)continue;

				if(arr[i] &amp;gt; arr[i+1]) {
					swap(arr,i,i+1);
					System.out.printf(&quot;%d %d %d %d %d\n&quot;,arr[0],arr[1],arr[2],arr[3],arr[4]);
				}
			}
			int cnt = 0;
			for(int i=0;i&amp;lt;5;i++) {
				if(arr[i] != i+1) {
					break;
				}
				cnt++;
			}
			if(cnt == 5) return;
		}
	}

	public static void swap(int[] arr, int a, int b) {
		int temp = arr[a];
		arr[a] = arr[b];
		arr[b] = temp;
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>hjs</name>
        
        
      </author>

      

      
        <category term="BOJ" />
      

      
        <summary type="html">문제 : 나무조각</summary>
      

      
      
    </entry>
  
</feed>
