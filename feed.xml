<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://hjs101.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hjs101.github.io/" rel="alternate" type="text/html" /><updated>2022-02-23T01:48:52+09:00</updated><id>https://hjs101.github.io/feed.xml</id><title type="html">hjs’s Blog</title><subtitle>기술 블로그 알고리즘 공부 및 프로젝트</subtitle><entry><title type="html">BOJ_2567_색종이2_JAVA</title><link href="https://hjs101.github.io/BOJ-2567" rel="alternate" type="text/html" title="BOJ_2567_색종이2_JAVA" /><published>2022-02-22T21:00:00+09:00</published><updated>2022-02-22T21:00:00+09:00</updated><id>https://hjs101.github.io/BOJ-2567</id><content type="html" xml:base="https://hjs101.github.io/BOJ-2567">&lt;h2 id=&quot;문제--색종이2&quot;&gt;문제 : 색종이2&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2567&quot;&gt;BOJ_2567_색종이2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;이전에 풀었던 색종이 문제의 확장형이다. 100*100크기에 색종이를 겹치는 건 같지만, 넓이를 구했던 그 때와 달리 이번에는 둘레를 구해야 한다. 넓이를 구할 때는 배열 내부의 값을 모두 카운트하면 해결되는 문제였다.&lt;/p&gt;

&lt;p&gt;둘레를 구하는 법은 막상 떠올릴려고 하면 어려웠다. 하지만 배열을 한 번 출력해보니 실마리가 보였다.&lt;/p&gt;

&lt;p&gt;핵심은 1과 인접한 0의 개수였다. 색종이의 크기는 10*10이고 정사각형이다. 색종이를 모두 1로 채워넣는다고 할 때 색종이의 모서리는 항상 0과 맞닿아있다. 꼭짓점 부분은 2개의 0과 인접하고, 그 부분은 길이를 2로 칠 수 있다. 이를 토대로 유추했을 때, 색종이의 둘레는 배열을 탐색하여 값이 1인 노드와 인접해있는 0의 개수일 것이다. 다만, 배열을 100, 100으로 설정할 경우, 0만 체크하면 안되고 배열의 경계값도 주의해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;100*100 크기의 int 타입 2차원 배열을 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;색종이의 좌표를 읽어들여 각 좌표별로 10*10만큼 1을 입력한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열 전체를 탐색하며 1과 인접한 0의 개수를 센다. 1과 인접한 곳이 배열의 경계일 경우에도 카운트를 더해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탐색이 종료된 후 카운트한 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_2567_색종이2 {
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());
		StringTokenizer st;


		// 100*100 크기 배열 생성
		int[][] arr = new int[100][100];

		// 주어진 좌표로부터 10*10만큼 1 집어넣기
		for(int i=0;i&amp;lt;N;i++) {
			st = new StringTokenizer(in.readLine());

			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());

			for(int j = a; j &amp;lt;a+10;j++) {
				for(int k = b;k&amp;lt;b+10;k++) {
					arr[j][k] = 1;
				}
			}
		}
		// 둘레를 저장할 변수
		int cnt = 0;

		// 배열 전체 탐색 하며 1 주변의 0의 개수를 세기, 1 주변이 배열의 경계일 경우도 cnt를 더해준다
		for(int i=0;i&amp;lt;100;i++) {
			for(int j=0;j&amp;lt;100;j++) {
				// 배열에서 1을 만나면
				if(arr[i][j] == 1) {
					// 4방탐색
					for(int d = 0; d &amp;lt; 4; d++) {
						int dx = i + dir[d][0];
						int dy = j + dir[d][1];
						// 배열의 경계를 체크하여, 1 주변이 배열의 경계라면 cnt를 1 더해준다.
						if(dx &amp;lt; 0 || dx &amp;gt;= 100 || dy &amp;lt; 0 || dy &amp;gt;= 100) {
							cnt++;
						}
						// 배열의 경계 안에 있을 때, 1 주변에 0이 있다면 cnt를 1 더해준다.
						if(dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; 100 &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; 100 &amp;amp;&amp;amp; arr[dx][dy] == 0) {
							cnt++;
						}
					}
				}
			}
		}

		System.out.println(cnt);
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : 색종이2</summary></entry><entry><title type="html">SWEA__서로소집합_JAVA</title><link href="https://hjs101.github.io/SWEA-3289" rel="alternate" type="text/html" title="SWEA__서로소집합_JAVA" /><published>2022-02-22T21:00:00+09:00</published><updated>2022-02-22T21:00:00+09:00</updated><id>https://hjs101.github.io/SWEA-3289</id><content type="html" xml:base="https://hjs101.github.io/SWEA-3289">&lt;h2 id=&quot;문제--서로소집합&quot;&gt;문제 : 서로소집합&lt;/h2&gt;

&lt;h4 id=&quot;swea문제는-로그인을-해야-열람할-수-있습니다&quot;&gt;SWEA문제는 로그인을 해야 열람할 수 있습니다.&lt;/h4&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWBJKA6qr2oDFAWr&amp;amp;categoryId=AWBJKA6qr2oDFAWr&amp;amp;categoryType=CODE&amp;amp;problemTitle=%EC%84%9C%EB%A1%9C%EC%86%8C&amp;amp;orderBy=FIRST_REG_DATETIME&amp;amp;selectCodeLang=ALL&amp;amp;select-1=&amp;amp;pageSize=10&amp;amp;pageIndex=1&quot;&gt;SWEA_3289_서로소집합&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;서로소 집합의 개념을 배울 수 있는 문제이다. 서로소집합은 말 그대로 서로소인 집합, 즉 공통 원소가 없는 두 집합을 의미한다.&lt;/p&gt;

&lt;p&gt;문제를 통해 합집합, Union과 집합 안에 특정 값이 포함되어 있는지 확인하는 findSet를 사용해볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;p&gt;이번 문제는 인접 리스트와 트리 두가지를 이용하여 풀었다. 인접 리스트로 서로소 집합을 구현할 때는 각 노드별로 집합의 대표 노드의 주소와 같은 집합의 다음 노드의 주소를 함께 가지고 있도록 구현해야 하는 부분에 주의해야 한다. 트리는 1차원 배열의 인덱스와 값을 이용해서 구현하였다.&lt;/p&gt;

&lt;p&gt;문제 자체는 간단했다. Union과 FindSet을 구현한 후 각 명령어에 따라서 출력만 진행하면 된다.&lt;/p&gt;

&lt;p&gt;먼저 Union 메서드이다. 2개의 노드를 인자값으로 받아 두 노드의 대표 노드가 같은 노드라면 union이 불가능하므로 false를 리턴한다. 만약 리턴되지 않았다면, a에 b를 연결하고 b에 연결되어있는 노드의 대표 노드 정보를 a의 대표노드로 바꿔준다.&lt;/p&gt;

&lt;p&gt;findSet 메서드는, 값을 입력받아서 계속해서 재귀호출을 하며 상위 노드를 불러온다. 그 상위 노드가 주어진 값과 같아지면 해당 값을 리턴하도록 한다.&lt;/p&gt;

&lt;p&gt;위 두 가지의 메서드는 코드를 보면 더 이해가 쉬울 듯 하다.&lt;/p&gt;

&lt;p&gt;코드를 잘못 짠 건지, 인접리스트를 사용한 코드에서는 문제풀이시 시간초과가 일어났다.&lt;/p&gt;

&lt;h2 id=&quot;소스-코드--인접-리스트-사용&quot;&gt;소스 코드 : 인접 리스트 사용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class D4_1238_Contact {

	static class Node{
		int V;
		Node link;
		public Node(int v, Node link) {
			super();
			V = v;
			this.link = link;
		}

		@Override
		public String toString() {
			return &quot;Node [V=&quot; + V + &quot;, link=&quot; + link + &quot;]&quot;;
		}


	}
	static int cnt;
	static ArrayList&amp;lt;Integer&amp;gt; ansNumbers;
	public static void main(String[] args) throws NumberFormatException, IOException {

		System.setIn(new FileInputStream(&quot;input_1238.txt&quot;));

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		String str;
		int tc = 1;
		while((str = in.readLine()) != null) {

			String splitStr[] = str.split(&quot; &quot;);

			int N = Integer.parseInt(splitStr[0]);

			int V = Integer.parseInt(splitStr[1]);

			Node[] nodeList = new Node[N];

			str = in.readLine();

			splitStr = str.split(&quot; &quot;);
			//유향 그래프 생성
			for(int i=0,n=splitStr.length;i&amp;lt;n;i+=2) {

				int from = Integer.parseInt(splitStr[i]);
				int to = Integer.parseInt(splitStr[i+1]);

				nodeList[from] = new Node(to,nodeList[from]);

			}
			ansNumbers = new ArrayList&amp;lt;&amp;gt;();
//			for(Node is : nodeList) {
//				System.out.println(is);
//			}



			System.out.printf(&quot;#%d %d\n&quot;,tc++,bfs(V,nodeList));
		}

	}

	public static int bfs(int start, Node[] nodeList) {
		Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();

		boolean[] visited = new boolean[nodeList.length];

		// 노드의 깊이를 저장할 배열
		int[] depth = new int[nodeList.length];
		// 처음 시작하는 곳은 깊이가 1
		depth[start] = 1;
		queue.offer(start);
		visited[start] = true;
		while(!queue.isEmpty()) {
			int current = queue.poll();
			ansNumbers.add(current);
//			System.out.print(current+&quot; &quot;);
			// current 정점의 인접 정점 처리(단, 방문하지 않은 인접 정점만)
			for(Node temp=nodeList[current]; temp!=null;temp = temp.link) {
				if(!visited[temp.V]) {
					queue.offer(temp.V);
					visited[temp.V] = true;
					// 깊이 기록
					depth[temp.V] += depth[current]+1;
				}
			}
		}
		// 가장 깊은 깊이에 있는 노드 중 가장 큰 값 찾기
		int ans = 0;
		for(int i=0;i&amp;lt;nodeList.length;i++) {
			if(depth[i] &amp;gt;= depth[ans]) {
				ans = i;
			}
		}

		return ans;
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;소스-코드--트리-사용&quot;&gt;소스 코드 : 트리 사용&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


// 링크드로 해봤는데 개느리다 왤까
public class D4_3289_서로소집합 {

	static class Node{
		int zip;

		Node link;

		Node parent;

		public Node(int zip, Node link, Node parent) {
			super();
			this.zip = zip;
			this.link = link;
			this.parent = parent;
		}

	}

	public static void main(String[] args) throws IOException {

		System.setIn(new FileInputStream(&quot;input_3289.txt&quot;));

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int T = Integer.parseInt(in.readLine());

		for (int tc = 1; tc &amp;lt;= T; tc++) {

			StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

			int N = Integer.parseInt(st.nextToken());

			int M = Integer.parseInt(st.nextToken());

			Node arr[] = new Node[N+1];

			for(int i=1;i&amp;lt;=N;i++) {
				arr[i] = new Node(i,null,arr[i]);
				arr[i].parent = arr[i];
			}

			StringBuilder sb = new StringBuilder();

			sb.append(&quot;#&quot;).append(tc).append(&quot; &quot;);

			for(int i=0;i&amp;lt;M;i++) {
				st = new StringTokenizer(in.readLine(),&quot; &quot;);
				int command = Integer.parseInt(st.nextToken());
				int a = Integer.parseInt(st.nextToken());
				int b = Integer.parseInt(st.nextToken());
				if(command == 0) {
					union(arr[a],arr[b]);
				}else if(command == 1) {
					if(findSet(arr[a],arr[b])) {
						sb.append(1);
					}else {
						sb.append(0);
					}
				}
			}
			System.out.println(sb);
		}


	}

	static boolean union(Node a, Node b) {

		if(a.parent == b.parent) {
			return false;
		}

		a.link = b;

		for(Node k = b;k!=null;k=k.link) {
			k.parent = a.parent;
		}
		return true;

	}

	static boolean findSet(Node a, Node b) {
		if(a.parent == b.parent) {
			return true;
		}else {
			return false;
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="SWEA" /><summary type="html">문제 : 서로소집합</summary></entry><entry><title type="html">BOJ_2667_단지번호붙이기_JAVA</title><link href="https://hjs101.github.io/BOJ-2667" rel="alternate" type="text/html" title="BOJ_2667_단지번호붙이기_JAVA" /><published>2022-02-22T21:00:00+09:00</published><updated>2022-02-22T21:00:00+09:00</updated><id>https://hjs101.github.io/BOJ-2667</id><content type="html" xml:base="https://hjs101.github.io/BOJ-2667">&lt;h2 id=&quot;문제--단지번호붙이기&quot;&gt;문제 : 단지번호붙이기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2667&quot;&gt;BOJ_2667_단지번호붙이기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;DFS 또는 BFS를 이용하여 2차원 배열의 서로 인접한 노드의 개수를 탐색한다. 인접한 노드의 집합을 묶어서 카운트하고, 각 집합의 개수도 추가로 카운트한다. 최종적으로 2차원 배열의 인접한 노드의 집합의 개수와 각 집합의 노드 개수를 구하여 출력하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 배열의 크기를 읽어들여 char타입 2차원 배열을 생성한다. 같은 크기로 boolean 배열도 함께 선언한다.(false 기본초기화)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성한 2차원 배열에 입력값을 할당한다. 노드의 집합을 저장할 list를 하나 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열을 탐색하여 값이 ‘1’이면서 아직 방문하지 않은 노드일 경우 카운트를 1로 두고 DFS 메서드를 호출한다. 방문처리는 앞서 선언했던 boolean 배열을 이용한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS를 이용하여 인접 노드를 순회한다. DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리한다. 배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다. 그리고 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS 순회가 끝난 후 cnt값을 list에 추가하고 이어서 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열 탐색이 모두 끝나면 리스트를 정렬하여 리스트의 길이와 리스트에 들어있는 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BOJ_2667_단지번호붙이기 {
	static int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } };
	static boolean[][] isVisited;
	static int N;
	static char arr[][];
	static int cnt;

	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

		N = Integer.parseInt(in.readLine());

		// 값 저장할 배열
		arr = new char[N][N];
		// 방문상태 파악
		isVisited = new boolean[N][N];

		for (int i = 0; i &amp;lt; N; i++) {
			arr[i] = in.readLine().toCharArray();
		}

		// dfs
		for (int i = 0; i &amp;lt; N; i++) {
			for (int j = 0; j &amp;lt; N; j++) {
				if (arr[i][j] == '1' &amp;amp;&amp;amp; isVisited[i][j] == false) {
					cnt = 1;
					int cnt = dfs(i, j);
					list.add(cnt);
				}
			}
		}

		StringBuilder sb = new StringBuilder();

		Collections.sort(list);

		sb.append(list.size()).append('\n');

		for (int i = 0; i &amp;lt; list.size(); i++) {
			sb.append(list.get(i)).append('\n');
		}

		System.out.println(sb);

	}

	static int dfs(int x, int y) {

		isVisited[x][y] = true;

		for (int i = 0; i &amp;lt; 4; i++) {
			int dx = x + dir[i][0];
			int dy = y + dir[i][1];
			if (dx &amp;gt;= 0 &amp;amp;&amp;amp; dx &amp;lt; N &amp;amp;&amp;amp; dy &amp;gt;= 0 &amp;amp;&amp;amp; dy &amp;lt; N &amp;amp;&amp;amp; arr[dx][dy] == '1' &amp;amp;&amp;amp; isVisited[dx][dy] != true) {
				dfs(dx, dy);
				cnt++;
			}
		}
		return cnt;
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : 단지번호붙이기</summary></entry><entry><title type="html">SWEA_1238_Contact_JAVA</title><link href="https://hjs101.github.io/SWEA-1238" rel="alternate" type="text/html" title="SWEA_1238_Contact_JAVA" /><published>2022-02-22T01:40:00+09:00</published><updated>2022-02-22T01:40:00+09:00</updated><id>https://hjs101.github.io/SWEA-1238</id><content type="html" xml:base="https://hjs101.github.io/SWEA-1238">&lt;h2 id=&quot;문제--contact&quot;&gt;문제 : Contact&lt;/h2&gt;

&lt;h4 id=&quot;swea문제는-로그인을-해야-열람할-수-있습니다&quot;&gt;SWEA문제는 로그인을 해야 열람할 수 있습니다.&lt;/h4&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15B1cKAKwCFAYD&amp;amp;categoryId=AV15B1cKAKwCFAYD&amp;amp;categoryType=CODE&amp;amp;problemTitle=contact&amp;amp;orderBy=FIRST_REG_DATETIME&amp;amp;selectCodeLang=ALL&amp;amp;select-1=&amp;amp;pageSize=10&amp;amp;pageIndex=1&quot;&gt;SWEA_1238_Contact&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;BFS를 통해 유향 그래프를 탐색하고, 그 깊이가 가장 깊은 노드들 중에 최댓값을 구해 출력하면 되는 문제이다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;p&gt;이번 문제는 인접 리스트로 만들었다. 기존의 무향 그래프를 만들던 것에서 양방향으로 저장하는 부분을 단방향으로 바꿔주면 그래프는 어렵지 않게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;BFS도 기존에 사용하던 방식대로 사용하면 되는데, 문제는 깊이가 가장 깊은 노드들 중에 최댓값을 구해야 한다는 점이다. 트리의 경우라면 쉽게 깊이를 측정할 수 있지만, 그래프에서는 어렵게 느껴졌다.&lt;/p&gt;

&lt;p&gt;해결 방법으로는 기존 BFS 알고리즘에 depth 개념을 추가하여, 노드 별로 깊이를 저장해두는 것이다.&lt;/p&gt;

&lt;p&gt;각 노드가 다음 노드를 방문할 때마다 자신의 노드의 깊이에서 1 더하여 다음 노드로 넘어가는 방식을 통해 깊이를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;노드 별 깊이를 구했다면 최댓값을 찾는 건 쉽다.&lt;/p&gt;

&lt;p&gt;노드의 개수만큼 순회하며 깊이가 가장 깊은 노드의 값 중 가장 큰 값을 찾아주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class D4_1238_Contact {

	static class Node{
		int V;
		Node link;
		public Node(int v, Node link) {
			super();
			V = v;
			this.link = link;
		}

		@Override
		public String toString() {
			return &quot;Node [V=&quot; + V + &quot;, link=&quot; + link + &quot;]&quot;;
		}


	}
	static int cnt;
	static ArrayList&amp;lt;Integer&amp;gt; ansNumbers;
	public static void main(String[] args) throws NumberFormatException, IOException {

		System.setIn(new FileInputStream(&quot;input_1238.txt&quot;));

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		String str;
		int tc = 1;
		while((str = in.readLine()) != null) {

			String splitStr[] = str.split(&quot; &quot;);

			int N = Integer.parseInt(splitStr[0]);

			int V = Integer.parseInt(splitStr[1]);

			Node[] nodeList = new Node[N];

			str = in.readLine();

			splitStr = str.split(&quot; &quot;);
			//유향 그래프 생성
			for(int i=0,n=splitStr.length;i&amp;lt;n;i+=2) {

				int from = Integer.parseInt(splitStr[i]);
				int to = Integer.parseInt(splitStr[i+1]);

				nodeList[from] = new Node(to,nodeList[from]);

			}
			ansNumbers = new ArrayList&amp;lt;&amp;gt;();
//			for(Node is : nodeList) {
//				System.out.println(is);
//			}



			System.out.printf(&quot;#%d %d\n&quot;,tc++,bfs(V,nodeList));
		}

	}

	public static int bfs(int start, Node[] nodeList) {
		Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();

		boolean[] visited = new boolean[nodeList.length];

		// 노드의 깊이를 저장할 배열
		int[] depth = new int[nodeList.length];
		// 처음 시작하는 곳은 깊이가 1
		depth[start] = 1;
		queue.offer(start);
		visited[start] = true;
		while(!queue.isEmpty()) {
			int current = queue.poll();
			ansNumbers.add(current);
//			System.out.print(current+&quot; &quot;);
			// current 정점의 인접 정점 처리(단, 방문하지 않은 인접 정점만)
			for(Node temp=nodeList[current]; temp!=null;temp = temp.link) {
				if(!visited[temp.V]) {
					queue.offer(temp.V);
					visited[temp.V] = true;
					// 깊이 기록
					depth[temp.V] += depth[current]+1;
				}
			}
		}
		// 가장 깊은 깊이에 있는 노드 중 가장 큰 값 찾기
		int ans = 0;
		for(int i=0;i&amp;lt;nodeList.length;i++) {
			if(depth[i] &amp;gt;= depth[ans]) {
				ans = i;
			}
		}

		return ans;
	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="SWEA" /><summary type="html">문제 : Contact</summary></entry><entry><title type="html">BOJ_2060_바이러스_JAVA</title><link href="https://hjs101.github.io/BOJ-2060" rel="alternate" type="text/html" title="BOJ_2060_바이러스_JAVA" /><published>2022-02-21T21:00:00+09:00</published><updated>2022-02-21T21:00:00+09:00</updated><id>https://hjs101.github.io/BOJ-2060</id><content type="html" xml:base="https://hjs101.github.io/BOJ-2060">&lt;h2 id=&quot;문제--바이러스&quot;&gt;문제 : 바이러스&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/2060&quot;&gt;BOJ_2060_바이러스&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;DFS 또는 BFS를 이용하여 인접한 노드를 전체 순회하고 카운트 하면 되는 문제이다. 그래프 생성과 DFS, BFS중 한 가지라도 구현할 수 있다면 문제를 풀 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;인접 행렬을 통해 주어진 인접 상태 좌표를 읽어들여 그래프를 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS를 이용하여 인접 노드를 순회한다. DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다. 그리고 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순회가 끝나면 저장된 카운트 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_2060_바이러스 {
	static int N;
	static int cnt;
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));


		N = Integer.parseInt(in.readLine());

		int C = Integer.parseInt(in.readLine());

		int[][] arr = new int[N+1][N+1];
		StringTokenizer st;
		for(int i=0;i&amp;lt;C;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);

			int from = Integer.parseInt(st.nextToken());

			int to = Integer.parseInt(st.nextToken());
			arr[from][to] = 1;
			arr[to][from] = 1;

		}

		dfs(arr,new boolean[N+1],1);


		System.out.println(cnt);
//		for(int i=1;i&amp;lt;=N;i++) {
//			System.out.println(Arrays.toString(arr[i]));
//		}

	}

	public static void dfs(int[][] arr, boolean[] isVisited, int V) {
		isVisited[V] = true;

		for(int i=1;i&amp;lt;=N;i++) {
			if(!isVisited[i] &amp;amp;&amp;amp; arr[V][i] == 1) {
				cnt++;
				dfs(arr, isVisited, i);
			}
		}

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : 바이러스</summary></entry><entry><title type="html">BOJ_1759_암호만들기_JAVA</title><link href="https://hjs101.github.io/BOJ-1759" rel="alternate" type="text/html" title="BOJ_1759_암호만들기_JAVA" /><published>2022-02-21T21:00:00+09:00</published><updated>2022-02-21T21:00:00+09:00</updated><id>https://hjs101.github.io/BOJ-1759</id><content type="html" xml:base="https://hjs101.github.io/BOJ-1759">&lt;h2 id=&quot;문제--암호만들기&quot;&gt;문제 : 암호만들기&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1759&quot;&gt;BOJ_1759_암호만들기&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;백트래킹 문제인데, 조합을 이용해서 푸는 문제라고 한다. 나는 이런 내용을 순열로 풀고 나서 알게 되었다. 나는 순열을 구하면서 가지치기를 통해 원하는 값을 리스트에 넣고, 그 리스트를 정렬하여 사전순으로 만들었다.&lt;/p&gt;

&lt;p&gt;C 개의 알파벳으로부터 L개의 길이의 암호문을 구하는 문제이다. 암호의 조건으로는 2가지가 있는데, 1가지는 왼쪽의 알파벳부터 오른쪽으로 갈 수록 값이 증가한다는 것, abc는 가능하지만 bac는 불가능하다.&lt;/p&gt;

&lt;p&gt;2번째 조건은 알파벳의 모음(a,e,i,o,u)은 최소 1개 이상 암호문에 포함되어야하며, 자음은 최소 2개 이상 암호문에 포함되어야 한다는 조건이다.&lt;/p&gt;

&lt;p&gt;나는 암호에 순서가 있다고 생각하여 순열을 이용하여 풀이해주었다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 값을 저장할 변수들을 전역으로 선언해주었다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;알파벳의 개수와 암호문의 길이를 읽어와 변수에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주어진 문자열을 읽어들일 배열을 생성해 값을 할당하고,  암호문 경우의 수를 저장할 배열을 암호문의 길이 L의 크기로 생성했다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열을 통해 경우의 수를 구하는데, 가지치기의 조건을 둔다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가지치기의 조건은, 현재 알파벳이 다음 알파벳보다 작을 경우에만 재귀호출을 하도록 하는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열이 완성되면, 각 순열별로 자음 카운트와 모음 카운트를 저장할 변수를 생성한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만들어진 순열을 탐색하는데, 알파벳이 모음이면 모음 카운트를 증가시키고, 자음이라면 자음 카운트를 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열의 순회가 끝나고, 모음카운트가 1 이상, 자음카운트가 2 이상이라면 해당하는 수열을 문자열로 만들어 String 타입 리스트에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순열이 모두 구해진 후, String 리스트를 Collections.sort 메서드를 이용하여 정렬한 후 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;

public class BOJ_1759_암호만들기 {
	static int C;
	static int L;
	static char[] chars;
	static char[] answer;
	static StringBuilder sb = new StringBuilder();
	static List&amp;lt;String&amp;gt; strs = new ArrayList&amp;lt;&amp;gt;();
	public static void main(String[] args) throws IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		StringTokenizer st = new StringTokenizer(in.readLine(),&quot; &quot;);

		L = Integer.parseInt(st.nextToken());
		C = Integer.parseInt(st.nextToken());

		chars = new char[C];
		answer = new char[L];
		st = new StringTokenizer(in.readLine(),&quot; &quot;);
		for(int i=0;i&amp;lt;C;i++) {
			chars[i] = st.nextToken().charAt(0);
		}

		perm(0,0,' ');
		Collections.sort(strs);

		for(int i=0;i&amp;lt;strs.size();i++) {
			sb.append(strs.get(i)).append('\n');
		}
		System.out.print(sb);
	}

	public static void perm(int cnt, int flag, char n) {

		if(cnt == L) {
			int mCnt = 0;
			int jCnt = 0;
			for(int i=0;i&amp;lt;L;i++) {
				switch(answer[i]) {
				case 'a':
				case 'e':
				case 'i':
				case 'o':
				case 'u':
					mCnt++;
					break;
				default:
					jCnt++;
				}
			}
			if(mCnt &amp;gt;= 1 &amp;amp;&amp;amp; jCnt &amp;gt;= 2) {
				String str = &quot;&quot;;
				for(int i=0;i&amp;lt;L;i++) {
					str = str + answer[i];
				}
				strs.add(str);
			}
			return;
		}


		for(int i=0;i&amp;lt;C;i++) {
			if((flag &amp;amp; 1&amp;lt;&amp;lt;i) != 0) {
				continue;
			}
			answer[cnt] = chars[i];
			// 가지치기 1 현재 알파벳이 다음 알파벳보다 작을 경우에만 재귀,
			if(n &amp;lt; answer[cnt]) {
				perm(cnt+1,flag | 1&amp;lt;&amp;lt;i, answer[cnt]);
			}
		}

	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : 암호만들기</summary></entry><entry><title type="html">BOJ_1417_국회의원선거_JAVA</title><link href="https://hjs101.github.io/BOJ-1417" rel="alternate" type="text/html" title="BOJ_1417_국회의원선거_JAVA" /><published>2022-02-21T21:00:00+09:00</published><updated>2022-02-21T21:00:00+09:00</updated><id>https://hjs101.github.io/BOJ-1417</id><content type="html" xml:base="https://hjs101.github.io/BOJ-1417">&lt;h2 id=&quot;문제--국회의원선거&quot;&gt;문제 : 국회의원선거&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1417&quot;&gt;BOJ_1417_국회의원선거&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;배열의 최댓값을 구하면서 인덱스 값을 같이 저장한다. 다솜의 번호는 가장 첫 번째이므로, 최댓값의 인덱스가 첫 번째 번호라면 투표를 뺏어올 필요가 없으니 0이다.&lt;/p&gt;

&lt;p&gt;그렇지 않은 경우라면, 배열의 최댓값에서 투표 수를 1 꺼내서 다솜의 투표에 추가하면 된다.&lt;/p&gt;

&lt;p&gt;문제는 최댓값이 다솜과 같은 인원이 다수 있을 때인데, 이 상황에서는, 최대 투표값을 크거나 같은 것으로 설정하면 해결된다. 그 이유는 다솜은 무조건 첫 번째 후보이기 때문에, 자신과 같은 투표수의 뒷 후보가 있다면 자동으로 본인은 최대 득표자에서 벗어나게 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;선거의 총 참여 인원수를 읽어와 저장하고, 각 후보의 투표 수를 N개 크기의 배열에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다솜의 투표 수가 최대가 될때까지 반복하는 반복문을 돌린다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열을 순회하며 최대 득표자를 찾고, 만약 최댓값이 다솜이라면 반복문을 나간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다솜이 최대 득표자가 아니라면, 최대 득표 후보는 -1을 다솜은 +1을 시켜준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복문이 한 번 돌아갈 때마다 카운트를 1 증가시킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 카운트 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BOJ_1417_국회의원선거 {
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(in.readLine());

		int arr[] = new int[N];

		for(int i=0;i&amp;lt;N;i++) {
			arr[i] = Integer.parseInt(in.readLine());
		}
		int cnt = 0;
		// 다솜이 최댓값이 될때까지 반복
		while(true) {
			int max = 0;
			int maxIndex = 0;
			for(int i=0;i&amp;lt;N;i++) {
				// 표 중에 최댓값을 구한다. index도 같이 저장한다.
				if(max &amp;lt;= arr[i]) {
					max = arr[i];
					maxIndex = i;
				}
			}
			// 최댓값이 다솜이라면
			if(maxIndex == 0) {
				break;
			}
			arr[maxIndex]--;
			arr[0]++;
			cnt++;
		}

		System.out.println(cnt);
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : 국회의원선거</summary></entry><entry><title type="html">BOJ_1260_DFS와BFS_JAVA</title><link href="https://hjs101.github.io/BOJ-1260" rel="alternate" type="text/html" title="BOJ_1260_DFS와BFS_JAVA" /><published>2022-02-21T21:00:00+09:00</published><updated>2022-02-21T21:00:00+09:00</updated><id>https://hjs101.github.io/BOJ-1260</id><content type="html" xml:base="https://hjs101.github.io/BOJ-1260">&lt;h2 id=&quot;문제--dfs와bfs&quot;&gt;문제 : DFS와BFS&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1260&quot;&gt;BOJ_1260_DFS와BFS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;주어진 노드를 읽어들여 그래프를 만들고, 그 그래프를 DFS와 BFS를 이용한 순회 결과를 출력하면 되는 문제이다.&lt;/p&gt;

&lt;p&gt;BFS와 DFS는 아래 링크의 게시글을 참고하여 공부하였다.&lt;/p&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://better-tomorrow.tistory.com/entry/DFS-BFS-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0?category=456505&quot;&gt;DFS와 BFS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;인접 행렬을 통해 주어진 인접 상태 좌표를 읽어들여 그래프를 구현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS를 이용하여 먼저 그래프를 순회한다. 인자값으로 boolean 배열(노드 수만큼), 생성한 그래프 배열, 시작할 노드를 받는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐를 생성한다. 초기 노드를 방문처리하고 큐에 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐가 모두 비어있을 때까지 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;큐에서 값을 꺼내어 StringBuilder에 저장한다. 그 후 배열의 크기만큼 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 해당 노드의 행에 아직 방문하지 않고, 인접한 노드가 있다면 큐에 해당 노드를 추가하고 방문처리한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BFS 이용한 순회가 끝나면, DFS 이용하여 순회를 한다. 인자값으로는 BFS와 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DFS는 재귀로 구현한다. 먼저, 해당 노드를 방문처리하고 StringBuilder에 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열의 크기만큼 반복하는데, 해당 노드의 행에 아직 방문하지 않은 상태의 인접한 노드가 있다면, 해당 노드를 방문처리하고 재귀함수를 호출한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 순회가 끝나면 StringBuilder에 저장한 문자열을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class BOJ_1260_DFS와BFS {
	static StringBuilder sb;
	static int N;
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));




		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		N = Integer.parseInt(st.nextToken());

		int M = Integer.parseInt(st.nextToken());

		int V = Integer.parseInt(st.nextToken());

		int[][] adjMatrix = new int[N+1][N+1];



		for(int i=0;i&amp;lt;M;i++) {
			st = new StringTokenizer(in.readLine(),&quot; &quot;);
			int v1 = Integer.parseInt(st.nextToken());
			int v2 = Integer.parseInt(st.nextToken());
			adjMatrix[v1][v2] = 1;
			adjMatrix[v2][v1] = 1;
		}

		boolean[] visited = new boolean[N+1];
		Arrays.fill(visited, false);
		sb = new StringBuilder();
		// dfs
		dfs(V, visited, adjMatrix);
		sb.setLength(sb.length()-1);
		sb.append('\n');

		Arrays.fill(visited, false);

		bfs(V,visited, adjMatrix);

		System.out.println(sb);

	}
	public static void bfs(int v, boolean[] visited, int[][] adjMatrix) {

		Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();

		visited[v] = true;
		queue.offer(v);

		while(!queue.isEmpty()) {
			int current = queue.poll();

			sb.append(current + &quot; &quot;);

			for(int i=1;i&amp;lt;=N;i++) {
				if(!visited[i] &amp;amp;&amp;amp; adjMatrix[current][i] != 0) {
					queue.offer(i);
					visited[i] = true;
				}
			}
		}


		sb.setLength(sb.length()-1);

	}

	public static void dfs(int v, boolean[] visited, int[][] adjMatrix) {
		visited[v] = true;
		sb.append(v + &quot; &quot;);
		for(int i=1;i&amp;lt;=N;i++) {
			if(!visited[i] &amp;amp;&amp;amp; adjMatrix[v][i] != 0) {
				visited[i] = true;
				dfs(i, visited, adjMatrix);
			}
		}
	}



}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : DFS와BFS</summary></entry><entry><title type="html">BOJ_9461_파도반수열_JAVA</title><link href="https://hjs101.github.io/BOJ-9461" rel="alternate" type="text/html" title="BOJ_9461_파도반수열_JAVA" /><published>2022-02-21T01:40:00+09:00</published><updated>2022-02-21T01:40:00+09:00</updated><id>https://hjs101.github.io/BOJ-9461</id><content type="html" xml:base="https://hjs101.github.io/BOJ-9461">&lt;h2 id=&quot;문제--파도반수열&quot;&gt;문제 : 파도반수열&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/9461&quot;&gt;BOJ_9461_파도반수열&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;삼각형이 나선으로 놓여져있고 변의 과정이고 어쩌고 규칙이 있기는 한데, 그림과 설명을 이용해서 수열을 이해하는것 보다 나열되어있는 숫자를 보고 알아채는 게 더 쉬웠다.&lt;/p&gt;

&lt;p&gt;1, 1, 1, 2, 2, 3, 4, 5, 7, 9&lt;/p&gt;

&lt;p&gt;이게 파도반 수열 P(1)부터 P(10)까지이다.&lt;/p&gt;

&lt;p&gt;기본값으로 P(1),P(2),P(3)은 1,1,1이다.&lt;/p&gt;

&lt;p&gt;P(4) =  P(4-3) + P(4-2) = P(1) + P(2) = 1+1 = 2&lt;br /&gt;
P(5) = P(5-3) + P(5-2) = P(2) + P(3) = 1+1 = 2&lt;br /&gt;
P(6) = P(6-3) + P(6-2) = P(3) + P(4) = 1 + 2 = 3&lt;/p&gt;

&lt;p&gt;위의 세 식을 보면 알겠듯이 해당 수열 P(N) = P(N-3) + P(N-2)의 규칙을 가진다.&lt;/p&gt;

&lt;p&gt;피보나치와 유사하게 DP로 위 점화식을 풀어나가면 된다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;테스트 케이스 수를 읽어와 테스트 케이스 수 만큼 반복한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변수 N에 주어지는 입력값을 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dp용 배열을 N+2개만큼 선언한다. +2를 하는 이유는, N에 3 미만의 수가 주어졌을 때 배열의 값을 벗어나지 않게 하기 위함이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시작값을 3부터 N까지 반복하는데, 위의 점화식대로 계산하여 배열에 순차적으로 추가한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 반복이 종료된 후 dp배열의 N-1번째 값을 출력한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class BOJ_9461_파도반수열 {

	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

		int T = Integer.parseInt(in.readLine());

		for (int i = 0; i &amp;lt; T; i++) {

			int N = Integer.parseInt(in.readLine());

			long[] dp = new long[N+2];

			dp[0] = 1;
			dp[1] = 1;
			dp[2] = 1;

			for (int j = 3; j &amp;lt; N; j++) {
				dp[j] = dp[j - 2] + dp[j - 3];
			}

			System.out.println(dp[N - 1]);

		}

	}

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : 파도반수열</summary></entry><entry><title type="html">BOJ_1063_킹_JAVA</title><link href="https://hjs101.github.io/BOJ-1063" rel="alternate" type="text/html" title="BOJ_1063_킹_JAVA" /><published>2022-02-20T01:40:00+09:00</published><updated>2022-02-20T01:40:00+09:00</updated><id>https://hjs101.github.io/BOJ-1063</id><content type="html" xml:base="https://hjs101.github.io/BOJ-1063">&lt;h2 id=&quot;문제--킹&quot;&gt;문제 : 킹&lt;/h2&gt;

&lt;p&gt;링크 : &lt;a href=&quot;https://www.acmicpc.net/problem/1063&quot;&gt;BOJ_1063_킹&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;접근-방식&quot;&gt;접근 방식&lt;/h2&gt;

&lt;p&gt;킹과 돌의 초기 위치가 주어지고, 주어진 명령어에 따라서 킹을 움직인다. 킹이 움직이는 방향 앞에 돌이 있다면, 킹이 움직이는 방향으로 돌을 같이 움직여준다.&lt;/p&gt;

&lt;p&gt;위 규칙을 구현하면 되는 문제이다. 하지만 몇 가지 걸림돌이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;체스판의 번호와 방향
 체스판의 세로줄은 a~h까지, 가로줄은 1~8까지 있다. 배열로 이 문제를 푼다면, 배열의 넘버링에 주의할 필요가 있을 것이고, 또 영어 표기를 넘버링 할 방법도 찾아야 할 것이다. 또한, 가로번호를 셀 때 우리가 흔히 아는 방향인 위에서 아래로 내려가는 것이 아닌, 아래에서 위로 올라가는 부분 또한 고려해야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;입력과 출력 처리
 킹과 돌의 좌표가 주어질 때, A1, A2와 같이 각 좌표가 공백으로 구분되지 않고 한 번에 들어온다. BufferedReader로 읽어온다고 하면, 읽어온 문자열을 구분할 방안이 필요하다. 만약 비교를 하는 도중 영어로 넘버링 되는 좌표를 숫자로 바꾸어 처리했다면, 출력할 때 이를 영어로 다시 바꿔주는 것도 잊으면 안된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 사항을 주의하면 로직 자체는 간단하기 때문에 쉽게 풀이할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;풀이-방법&quot;&gt;풀이 방법&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;킹이 움직일 수 있는 방법에 따른 단위벡터 배열을 선언한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;킹의 좌표와 돌의 좌표를 읽어와 각각 변수에 저장한다. 세로줄에 대한 좌표를 읽어올 때는 -‘A’를 통해서 문자에 해당하는 정수값으로 저장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;명령어를 읽어들여 명령에 맞게 킹을 이동시킨다. 이동시키는 것의 의미는, 킹의 좌표에 해당 방향의 단위벡터만큼 더해주는 것이다. 킹이 범위 바깥으로 나가는 지 체크하는 것을 고려해야한다. 킹이 돌을 함께 움직이는 경우, 돌의 범위도 벗어나면 안된다는 것에 유의한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 명령을 수행시킨 후, 현재 킹의 위치와 돌의 위치를 출력한다. 세로줄에 좌표를 출력할 때는 다시 문자로 출력해야하므로 ‘A’를 더해주고 char로 형변환을 해준다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;소스-코드&quot;&gt;소스 코드&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class BOJ_1063_킹 {

	// 우 좌 상 하 우상 좌상 우하 좌하 (문제기준)
	static int dir[][] = { { 0, 1 }, { 0, -1 }, { -1, 0 }, { 1, 0 }, { 1, 1 }, { 1, -1 }, { -1, 1 }, { -1, -1 } };

//	static int arr[][];

	static int xK, yK, xS, yS;

	public static void main(String[] args) throws NumberFormatException, IOException {

		// 버퍼드리더로 값 읽어오기
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

//		// 뒤의 8은 a부터 h까지 매칭
//		arr = new int[9][9];

		StringTokenizer st = new StringTokenizer(in.readLine(), &quot; &quot;);

		char[] pos = st.nextToken().toCharArray();

		// 왕의 위치를 1로
		xK = pos[1] - '0';
		yK = pos[0] - 'A' + 1;

		pos = st.nextToken().toCharArray();

		xS = pos[1] - '0';
		yS = pos[0] - 'A' + 1;
//		System.out.println(xK+&quot;,&quot;+yK);
//		System.out.println(xS+&quot;,&quot;+yS);
		int N = Integer.parseInt(st.nextToken());
		// 왕 이동할 값 읽어와서 이동시키기
		for (int i = 0; i &amp;lt; N; i++) {
			String command = in.readLine();

			switch (command) {
			case &quot;R&quot;:
				// 킹 이동 함수
				move(0);
				break;
			case &quot;L&quot;:
				move(1);
				break;
			case &quot;B&quot;:
				move(2);
				break;
			case &quot;T&quot;:
				move(3);
				break;
			case &quot;RT&quot;:
				move(4);
				break;
			case &quot;LT&quot;:
				move(5);
				break;
			case &quot;RB&quot;:
				move(6);
				break;
			case &quot;LB&quot;:
				move(7);
				break;
			}

		}

		System.out.printf(&quot;%c%d\n&quot;,(char)(yK+'A'-1),xK);
		System.out.printf(&quot;%c%d\n&quot;,(char)(yS+'A'-1),xS);		
	}

	public static void move(int dirr) {
		int dx = dir[dirr][0];
		int dy = dir[dirr][1];

		// 킹이 이동할 위치가 범위 밖인지 확인
		if (xK + dx &amp;gt; 0 &amp;amp;&amp;amp; xK + dx &amp;lt;= 8 &amp;amp;&amp;amp; yK + dy &amp;gt; 0 &amp;amp;&amp;amp; yK + dy &amp;lt;= 8) {
			// 킹의 위치를 변경할 곳에 돌이 있는지 확인
			if (xK + dx == xS &amp;amp;&amp;amp; yK + dy == yS) {
				// 돌이 이동할 위치가 범위 밖인지 확인
				if (xS + dx &amp;gt; 0 &amp;amp;&amp;amp; xS + dx &amp;lt;= 8 &amp;amp;&amp;amp; yS + dy &amp;gt; 0 &amp;amp;&amp;amp; yS + dy &amp;lt;= 8) {
					xK = xK + dx;
					yK = yK + dy;

					xS = xS + dx;
					yS = yS + dy;
				}
			}else{
				xK = xK + dx;
				yK = yK + dy;
			}
		}

	}

}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>hjs</name></author><category term="BOJ" /><summary type="html">문제 : 킹</summary></entry></feed>